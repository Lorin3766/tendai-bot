# -*- coding: utf-8 -*-
# TendAI main.py ‚Äî –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–µ –ø—Ä–∞–≤–∫–∏ –±–µ–∑ —Å–º–µ–Ω—ã –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã:
# 1) on_callback + –º–µ–Ω—é/—á–∏–ø—ã –æ–ø—Ä–µ–¥–µ–ª–µ–Ω—ã –î–û build_app()
# 2) –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω CallbackQueryHandler(on_callback)
# 3) —É–¥–∞–ª–µ–Ω—ã —Å–ª–µ–¥—ã Updater; —Ç–æ–ª—å–∫–æ Application.run_polling()
# 4) render_main_menu ‚Äî –æ–¥–Ω–∞ –∞–∫—Ç—É–∞–ª—å–Ω–∞—è –≤–µ—Ä—Å–∏—è
# 5) —Ñ–∏–∫—Å NameError –∏–∑-–∑–∞ _build_app_orig

import os, re, json, uuid, logging, random
from datetime import datetime, timedelta, timezone, time as dtime, date
from typing import List, Tuple, Dict, Optional, Any
from difflib import SequenceMatcher

from dotenv import load_dotenv
from langdetect import detect, DetectorFactory

from telegram import (
    Update, InlineKeyboardButton, InlineKeyboardMarkup,
    ReplyKeyboardRemove
)
from telegram.ext import (
    ApplicationBuilder, CommandHandler, MessageHandler,
    CallbackQueryHandler, ContextTypes, filters
)

# --- SAFE import of optional PRO-intake plugin ---
try:
    from intake_pro import register_intake_pro  # noqa: F401
    HAVE_INTAKE_PRO = True
except Exception:
    HAVE_INTAKE_PRO = False
    def register_intake_pro(app, gclient=None, on_complete_cb=None):
        logging.warning("intake_pro not found ‚Äî PRO-–æ–ø—Ä–æ—Å –æ—Ç–∫–ª—é—á—ë–Ω.")
        async def _fallback_cb(update: Update, context: ContextTypes.DEFAULT_TYPE):
            q = update.callback_query
            await q.answer()
            await q.message.reply_text(
                "PRO-–æ–ø—Ä–æ—Å –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω –Ω–∞ —ç—Ç–æ–º –¥–µ–ø–ª–æ–µ. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /profile."
            )
        app.add_handler(CallbackQueryHandler(_fallback_cb, pattern=r"^intake:"))

# ---------- OpenAI (optional) ----------
from openai import OpenAI
oai: Optional[OpenAI] = None

# ---------- Google Sheets (robust + memory fallback) ----------
import gspread
from gspread.exceptions import SpreadsheetNotFound
import gspread.utils as gsu
from oauth2client.service_account import ServiceAccountCredentials

# ---------------- Boot & Config ----------------
load_dotenv()
logging.basicConfig(level=logging.INFO, format="%(asctime)s | %(levelname)s | %(message)s")
DetectorFactory.seed = 0

TELEGRAM_TOKEN = os.getenv("TELEGRAM_TOKEN")
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY", "")
OPENAI_MODEL = os.getenv("OPENAI_MODEL", "gpt-4o")

SHEET_NAME = os.getenv("SHEET_NAME", "TendAI Sheets")
SHEET_ID = os.getenv("SHEET_ID", "")
ALLOW_CREATE_SHEET = os.getenv("ALLOW_CREATE_SHEET", "0") == "1"
DEFAULT_CHECKIN_LOCAL = "08:30"

try:
    if OPENAI_API_KEY:
        os.environ["OPENAI_API_KEY"] = OPENAI_API_KEY
        oai = OpenAI()
except Exception as e:
    logging.error(f"OpenAI init error: {e}")
    oai = None

# ---------------- i18n ----------------
SUPPORTED = {"ru", "en", "uk", "es"}

def norm_lang(code: Optional[str]) -> str:
    if not code:
        return "en"
    c = code.split("-")[0].lower()
    return c if c in SUPPORTED else "en"

T = {
    "en": {
        "welcome": "Hi! I‚Äôm TendAI ‚Äî your health & longevity assistant.\nDescribe what‚Äôs bothering you; I‚Äôll guide you. Let‚Äôs do a quick 40s intake to tailor advice.",
        "help": "Short checkups, 24‚Äì48h plans, reminders, daily check-ins.\nCommands: /help /privacy /pause /resume /delete_data /profile /checkin_on 08:30 /checkin_off /settz +2 /health60 /energy /mood /water /skin /ru /uk /en /es /menu",
        "privacy": "TendAI is not a medical service and can‚Äôt replace a doctor. We provide navigation and self-care tips. Minimal data stored for reminders. /delete_data to erase.",
        "paused_on": "Notifications paused. Use /resume to enable.",
        "paused_off": "Notifications resumed.",
        "deleted": "All your data was deleted. Use /start to begin again.",
        "ask_consent": "May I send you a follow-up to check how you feel later?",
        "yes":"Yes","no":"No",
        "unknown":"I need a bit more info: where exactly and for how long?",
        "profile_intro":"Quick intake (~40s). Use buttons or type your answer.",
        "p_step_1":"Step 1/10. Sex:",
        "p_step_2":"Step 2/10. Age:",
        "p_step_3":"Step 3/10. Height (cm):",
        "p_step_4":"Step 4/10. Weight (kg):",
        "p_step_5":"Step 5/10. Main goal:",
        "p_step_6":"Step 6/10. Chronic conditions:",
        "p_step_7":"Step 7/10. Meds:",
        "p_step_8":"Step 8/10. Supplements:",
        "p_step_9":"Step 9/10. Sleep (bed/wake, e.g., 23:30/07:00):",
        "p_step_10":"Step 10/10. Activity:",
        "write":"‚úçÔ∏è Write",
        "skip":"‚è≠Ô∏è Skip",
        "saved_profile":"Saved: ",
        "start_where":"Where do you want to start now? ‚Äî or tap /menu",
        "daily_gm":"Good morning! Quick daily check-in:",
        "daily_pm":"Evening check-in: how was your day?",
        "mood_good":"üòÉ Good","mood_ok":"üòê Okay","mood_bad":"üò£ Poor","mood_note":"‚úçÔ∏è Comment",
        "mood_thanks":"Thanks! Have a smooth day üëã",
        "triage_pain_q1":"Where does it hurt?",
        "triage_pain_q1_opts":["Head","Throat","Back","Belly","Other"],
        "triage_pain_q2":"What kind of pain?",
        "triage_pain_q2_opts":["Dull","Sharp","Pulsating","Pressing"],
        "triage_pain_q3":"How long has it lasted?",
        "triage_pain_q3_opts":["<3h","3‚Äì24h",">1 day",">1 week"],
        "triage_pain_q4":"Rate the pain (0‚Äì10):",
        "triage_pain_q5":"Any of these now?",
        "triage_pain_q5_opts":["High fever","Vomiting","Weakness/numbness","Speech/vision problems","Trauma","None"],
        "plan_header":"Your 24‚Äì48h plan:",
        "plan_accept":"Will you try this today?",
        "accept_opts":["‚úÖ Yes","üîÅ Later","‚úñÔ∏è No"],
        "remind_when":"When shall I check on you?",
        "remind_opts":["in 4h","this evening","tomorrow morning","no need"],
        "thanks":"Got it üôå",
        "checkin_ping":"Quick check-in: how is it now (0‚Äì10)?",
        "checkin_better":"Nice! Keep it up üí™",
        "checkin_worse":"Sorry to hear. If any red flags or pain ‚â•7/10 ‚Äî consider medical help.",
        "act_rem_2h":"‚è∞ Remind in 2h",
        "act_rem_4h":"‚è∞ Remind in 4h",
        "act_rem_eve":"‚è∞ This evening",
        "act_rem_morn":"‚è∞ Tomorrow morning",
        "act_save_episode":"üíæ Save as episode",
        "act_ex_neck":"üßò 5-min neck routine",
        "act_find_lab":"üß™ Find a lab",
        "act_er":"üöë Emergency info",
        "act_city_prompt":"Type your city/area so I can suggest a lab (text only).",
        "act_saved":"Saved.",
        "er_text":"If symptoms worsen, severe shortness of breath, chest pain, confusion, or persistent high fever ‚Äî seek urgent care/emergency.",
        "px":"Considering your profile: {sex}, {age}y; goal ‚Äî {goal}.",
        "back":"‚óÄ Back",
        "exit":"Exit",
        "ask_fb":"Was this helpful?",
        "fb_thanks":"Thanks for your feedback! ‚úÖ",
        "fb_write":"Write a short feedback message:",
        "fb_good":"üëç Like",
        "fb_bad":"üëé Dislike",
        "fb_free":"üìù Feedback",
        "h60_btn": "Health in 60 seconds",
        "h60_intro": "Write briefly what bothers you (e.g., ‚Äúheadache‚Äù, ‚Äúfatigue‚Äù, ‚Äústomach pain‚Äù). I‚Äôll give you 3 key tips in 60 seconds.",
        "h60_t1": "Possible causes",
        "h60_t2": "Do now (next 24‚Äì48h)",
        "h60_t3": "When to see a doctor",
        "h60_serious": "Serious to rule out",
        "energy_title": "Energy for today:",
        "water_prompt": "Drink 300‚Äì500 ml of water. Remind in 2 hours?",
        "skin_title": "Skin/Body tip:",
        "m_menu_title": "Main menu",
        "m_sym": "üß≠ Symptoms",
        "m_h60": "ü©∫ Health in 60 seconds",
        "m_mini": "üîÅ Mini-plans",
        "m_care": "üß™ Find care",
        "m_hab": "üìä Habits Quick-log",
        "m_rem": "üóì Remind me",
        "m_lang": "üåê Language",
        "m_privacy": "üîí Privacy & how it works",
        "m_smart": "üß† Smart check-in",
        "m_soon": "üè† At-home labs/ECG ‚Äî coming soon",
        "chips_hb": "Avoid triggers ‚Ä¢ OTC options ‚Ä¢ When to see a doctor",
        "chips_neck": "5-min routine ‚Ä¢ Heat/Ice tips ‚Ä¢ Red flags",
    },
    "ru": {
        "welcome":"–ü—Ä–∏–≤–µ—Ç! –Ø TendAI ‚Äî –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç –∑–¥–æ—Ä–æ–≤—å—è –∏ –¥–æ–ª–≥–æ–ª–µ—Ç–∏—è.\n–†–∞—Å—Å–∫–∞–∂–∏, —á—Ç–æ –±–µ—Å–ø–æ–∫–æ–∏—Ç; —è –ø–æ–¥—Å–∫–∞–∂—É. –°–Ω–∞—á–∞–ª–∞ –∫–æ—Ä–æ—Ç–∫–∏–π –æ–ø—Ä–æ—Å (~40—Å), —á—Ç–æ–±—ã —Å–æ–≤–µ—Ç—ã –±—ã–ª–∏ —Ç–æ—á–Ω–µ–µ.",
        "help":"–ö–æ—Ä–æ—Ç–∫–∏–µ –ø—Ä–æ–≤–µ—Ä–∫–∏, –ø–ª–∞–Ω –Ω–∞ 24‚Äì48 —á, –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è, –µ–∂–µ–¥–Ω–µ–≤–Ω—ã–µ —á–µ–∫-–∏–Ω—ã.\n–ö–æ–º–∞–Ω–¥—ã: /help /privacy /pause /resume /delete_data /profile /checkin_on 08:30 /checkin_off /settz +3 /health60 /energy /mood /water /skin /ru /uk /en /es /menu",
        "privacy":"TendAI –Ω–µ –∑–∞–º–µ–Ω—è–µ—Ç –≤—Ä–∞—á–∞. –≠—Ç–æ –Ω–∞–≤–∏–≥–∞—Ü–∏—è –∏ —Å–æ–≤–µ—Ç—ã –ø–æ —Å–∞–º–æ–ø–æ–º–æ—â–∏. –•—Ä–∞–Ω–∏–º –º–∏–Ω–∏–º—É–º –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π. /delete_data ‚Äî —É–¥–∞–ª–∏—Ç—å.",
        "paused_on":"–ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è –ø–æ—Å—Ç–∞–≤–ª–µ–Ω—ã –Ω–∞ –ø–∞—É–∑—É. /resume ‚Äî –≤–∫–ª—é—á–∏—Ç—å.",
        "paused_off":"–ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è —Å–Ω–æ–≤–∞ –≤–∫–ª—é—á–µ–Ω—ã.",
        "deleted":"–í—Å–µ –¥–∞–Ω–Ω—ã–µ —É–¥–∞–ª–µ–Ω—ã. /start ‚Äî –Ω–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ.",
        "ask_consent":"–ú–æ–∂–Ω–æ –ø—Ä–∏—Å–ª–∞—Ç—å –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ –ø–æ–∑–∂–µ, —á—Ç–æ–±—ã —É–∑–Ω–∞—Ç—å, –∫–∞–∫ –≤—ã?",
        "yes":"–î–∞","no":"–ù–µ—Ç",
        "unknown":"–ù—É–∂–Ω–æ —á—É—Ç—å –±–æ–ª—å—à–µ –¥–µ—Ç–∞–ª–µ–π: –≥–¥–µ –∏–º–µ–Ω–Ω–æ –∏ —Å–∫–æ–ª—å–∫–æ –¥–ª–∏—Ç—Å—è?",
        "profile_intro":"–ë—ã—Å—Ç—Ä—ã–π –æ–ø—Ä–æ—Å (~40—Å). –ú–æ–∂–Ω–æ –Ω–∞–∂–∏–º–∞—Ç—å –∫–Ω–æ–ø–∫–∏ –∏–ª–∏ –ø–∏—Å–∞—Ç—å —Å–≤–æ–π –æ—Ç–≤–µ—Ç.",
        "p_step_1":"–®–∞–≥ 1/10. –ü–æ–ª:",
        "p_step_2":"–®–∞–≥ 2/10. –í–æ–∑—Ä–∞—Å—Ç:",
        "p_step_3":"–®–∞–≥ 3/10. –†–æ—Å—Ç (—Å–º):",
        "p_step_4":"–®–∞–≥ 4/10. –í–µ—Å (–∫–≥):",
        "p_step_5":"–®–∞–≥ 5/10. –ì–ª–∞–≤–Ω–∞—è —Ü–µ–ª—å:",
        "p_step_6":"–®–∞–≥ 6/10. –•—Ä–æ–Ω–∏—á–µ—Å–∫–∏–µ –±–æ–ª–µ–∑–Ω–∏:",
        "p_step_7":"–®–∞–≥ 7/10. –õ–µ–∫–∞—Ä—Å—Ç–≤–∞:",
        "p_step_8":"–®–∞–≥ 8/10. –î–æ–±–∞–≤–∫–∏:",
        "p_step_9":"–®–∞–≥ 9/10. –°–æ–Ω (–æ—Ç–±–æ–π/–ø–æ–¥—ä—ë–º, –Ω–∞–ø—Ä. 23:30/07:00):",
        "p_step_10":"–®–∞–≥ 10/10. –ê–∫—Ç–∏–≤–Ω–æ—Å—Ç—å:",
        "write":"‚úçÔ∏è –ù–∞–ø–∏—Å–∞—Ç—å",
        "skip":"‚è≠Ô∏è –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å",
        "saved_profile":"–°–æ—Ö—Ä–∞–Ω–∏–ª: ",
        "start_where":"–° —á–µ–≥–æ –Ω–∞—á–Ω—ë–º? ‚Äî –∏–ª–∏ –Ω–∞–∂–º–∏ /menu",
        "daily_gm":"–î–æ–±—Ä–æ–µ —É—Ç—Ä–æ! –ë—ã—Å—Ç—Ä—ã–π —á–µ–∫-–∏–Ω:",
        "daily_pm":"–í–µ—á–µ—Ä–Ω–∏–π —á–µ–∫-–∏–Ω: –∫–∞–∫ –ø—Ä–æ—à—ë–ª –¥–µ–Ω—å?",
        "mood_good":"üòÉ –•–æ—Ä–æ—à–æ","mood_ok":"üòê –ù–æ—Ä–º–∞–ª—å–Ω–æ","mood_bad":"üò£ –ü–ª–æ—Ö–æ","mood_note":"‚úçÔ∏è –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π",
        "mood_thanks":"–°–ø–∞—Å–∏–±–æ! –•–æ—Ä–æ—à–µ–≥–æ –¥–Ω—è üëã",
        "triage_pain_q1":"–ì–¥–µ –±–æ–ª–∏—Ç?",
        "triage_pain_q1_opts":["–ì–æ–ª–æ–≤–∞","–ì–æ—Ä–ª–æ","–°–ø–∏–Ω–∞","–ñ–∏–≤–æ—Ç","–î—Ä—É–≥–æ–µ"],
        "triage_pain_q2":"–ö–∞–∫–æ–π —Ö–∞—Ä–∞–∫—Ç–µ—Ä –±–æ–ª–∏?",
        "triage_pain_q2_opts":["–¢—É–ø–∞—è","–û—Å—Ç—Ä–∞—è","–ü—É–ª—å—Å–∏—Ä—É—é—â–∞—è","–î–∞–≤—è—â–∞—è"],
        "triage_pain_q3":"–ö–∞–∫ –¥–æ–ª–≥–æ –¥–ª–∏—Ç—Å—è?",
        "triage_pain_q3_opts":["<3—á","3‚Äì24—á",">1 –¥–Ω—è",">1 –Ω–µ–¥–µ–ª–∏"],
        "triage_pain_q4":"–û—Ü–µ–Ω–∏—Ç–µ –±–æ–ª—å (0‚Äì10):",
        "triage_pain_q5":"–ï—Å—Ç—å –ª–∏ —á—Ç–æ-—Ç–æ –∏–∑ —ç—Ç–æ–≥–æ —Å–µ–π—á–∞—Å?",
        "triage_pain_q5_opts":["–í—ã—Å–æ–∫–∞—è —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞","–†–≤–æ—Ç–∞","–°–ª–∞–±–æ—Å—Ç—å/–æ–Ω–µ–º–µ–Ω–∏–µ","–ù–∞—Ä—É—à–µ–Ω–∏–µ —Ä–µ—á–∏/–∑—Ä–µ–Ω–∏—è","–¢—Ä–∞–≤–º–∞","–ù–µ—Ç"],
        "plan_header":"–í–∞—à –ø–ª–∞–Ω –Ω–∞ 24‚Äì48 —á–∞—Å–æ–≤:",
        "plan_accept":"–ì–æ—Ç–æ–≤—ã –ø–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å —Å–µ–≥–æ–¥–Ω—è?",
        "accept_opts":["‚úÖ –î–∞","üîÅ –ü–æ–∑–∂–µ","‚úñÔ∏è –ù–µ—Ç"],
        "remind_when":"–ö–æ–≥–¥–∞ –Ω–∞–ø–æ–º–Ω–∏—Ç—å –∏ —Å–ø—Ä–æ—Å–∏—Ç—å —Å–∞–º–æ—á—É–≤—Å—Ç–≤–∏–µ?",
        "remind_opts":["—á–µ—Ä–µ–∑ 4 —á–∞—Å–∞","–≤–µ—á–µ—Ä–æ–º","–∑–∞–≤—Ç—Ä–∞ —É—Ç—Ä–æ–º","–Ω–µ –Ω–∞–¥–æ"],
        "thanks":"–ü—Ä–∏–Ω—è—Ç–æ üôå",
        "checkin_ping":"–ö–æ—Ä–æ—Ç–∫–æ: –∫–∞–∫ —Å–µ–π—á–∞—Å –ø–æ —à–∫–∞–ª–µ 0‚Äì10?",
        "checkin_better":"–û—Ç–ª–∏—á–Ω–æ! –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º üí™",
        "checkin_worse":"–ï—Å–ª–∏ –µ—Å—Ç—å ¬´–∫—Ä–∞—Å–Ω—ã–µ —Ñ–ª–∞–≥–∏¬ª –∏–ª–∏ –±–æ–ª—å ‚â•7/10 ‚Äî –ª—É—á—à–µ –æ–±—Ä–∞—Ç–∏—Ç—å—Å—è –∫ –≤—Ä–∞—á—É.",
        "act_rem_2h":"‚è∞ –ù–∞–ø–æ–º–Ω–∏—Ç—å —á–µ—Ä–µ–∑ 2 —á",
        "act_rem_4h":"‚è∞ –ù–∞–ø–æ–º–Ω–∏—Ç—å —á–µ—Ä–µ–∑ 4 —á",
        "act_rem_eve":"‚è∞ –°–µ–≥–æ–¥–Ω—è –≤–µ—á–µ—Ä–æ–º",
        "act_rem_morn":"‚è∞ –ó–∞–≤—Ç—Ä–∞ —É—Ç—Ä–æ–º",
        "act_save_episode":"üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å —ç–ø–∏–∑–æ–¥",
        "act_ex_neck":"üßò 5-–º–∏–Ω —É–ø—Ä–∞–∂–Ω–µ–Ω–∏—è –¥–ª—è —à–µ–∏",
        "act_find_lab":"üß™ –ù–∞–π—Ç–∏ –ª–∞–±–æ—Ä–∞—Ç–æ—Ä–∏—é",
        "act_er":"üöë –ö–æ–≥–¥–∞ —Å—Ä–æ—á–Ω–æ –≤ —Å–∫–æ—Ä—É—é",
        "act_city_prompt":"–ù–∞–ø–∏—à–∏—Ç–µ –≥–æ—Ä–æ–¥/—Ä–∞–π–æ–Ω (—Ç–µ–∫—Å—Ç–æ–º), –ø–æ–¥—Å–∫–∞–∂—É –ª–∞–±–æ—Ä–∞—Ç–æ—Ä–∏–∏.",
        "act_saved":"–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ.",
        "er_text":"–ï—Å–ª–∏ –Ω–∞—Ä–∞—Å—Ç–∞–µ—Ç, —Å–∏–ª—å–Ω–∞—è –æ–¥—ã—à–∫–∞, –±–æ–ª—å –≤ –≥—Ä—É–¥–∏, —Å–ø—É—Ç–∞–Ω–Ω–æ—Å—Ç—å, —Å—Ç–æ–π–∫–∞—è –≤—ã—Å–æ–∫–∞—è —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞ ‚Äî –∫–∞–∫ –º–æ–∂–Ω–æ —Å–∫–æ—Ä–µ–µ –∫ –Ω–µ–æ—Ç–ª–æ–∂–∫–µ/—Å–∫–æ—Ä–æ–π.",
        "px":"–° —É—á—ë—Ç–æ–º –ø—Ä–æ—Ñ–∏–ª—è: {sex}, {age} –ª–µ—Ç; —Ü–µ–ª—å ‚Äî {goal}.",
        "back":"‚óÄ –ù–∞–∑–∞–¥",
        "exit":"–í—ã–π—Ç–∏",
        "ask_fb":"–≠—Ç–æ –±—ã–ª–æ –ø–æ–ª–µ–∑–Ω–æ?",
        "fb_thanks":"–°–ø–∞—Å–∏–±–æ –∑–∞ –æ—Ç–∑—ã–≤! ‚úÖ",
        "fb_write":"–ù–∞–ø–∏—à–∏—Ç–µ –∫–æ—Ä–æ—Ç–∫–∏–π –æ—Ç–∑—ã–≤ –æ–¥–Ω–∏–º —Å–æ–æ–±—â–µ–Ω–∏–µ–º:",
        "fb_good":"üëç –ù—Ä–∞–≤–∏—Ç—Å—è",
        "fb_bad":"üëé –ù–µ –ø–æ–ª–µ–∑–Ω–æ",
        "fb_free":"üìù –û—Ç–∑—ã–≤",
        "h60_btn": "–ó–¥–æ—Ä–æ–≤—å–µ –∑–∞ 60 —Å–µ–∫—É–Ω–¥",
        "h60_intro": "–ö–æ—Ä–æ—Ç–∫–æ –Ω–∞–ø–∏—à–∏—Ç–µ, —á—Ç–æ –±–µ—Å–ø–æ–∫–æ–∏—Ç. –Ø –¥–∞–º 3 –∫–ª—é—á–µ–≤—ã—Ö —Å–æ–≤–µ—Ç–∞ –∑–∞ 60 —Å–µ–∫—É–Ω–¥.",
        "h60_t1": "–í–æ–∑–º–æ–∂–Ω—ã–µ –ø—Ä–∏—á–∏–Ω—ã",
        "h60_t2": "–ß—Ç–æ —Å–¥–µ–ª–∞—Ç—å —Å–µ–π—á–∞—Å (24‚Äì48 —á)",
        "h60_t3": "–ö–æ–≥–¥–∞ –æ–±—Ä–∞—Ç–∏—Ç—å—Å—è –∫ –≤—Ä–∞—á—É",
        "h60_serious": "–ß—Ç–æ —Å–µ—Ä—å—ë–∑–Ω–æ–µ –∏—Å–∫–ª—é—á–∏—Ç—å",
        "energy_title": "–≠–Ω–µ—Ä–≥–∏—è –Ω–∞ —Å–µ–≥–æ–¥–Ω—è:",
        "water_prompt": "–í—ã–ø–µ–π 300‚Äì500 –º–ª –≤–æ–¥—ã. –ù–∞–ø–æ–º–Ω–∏—Ç—å —á–µ—Ä–µ–∑ 2 —á–∞—Å–∞?",
        "skin_title": "–°–æ–≤–µ—Ç –¥–ª—è –∫–æ–∂–∏/—Ç–µ–ª–∞:",
        "m_menu_title": "–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é",
        "m_sym": "üß≠ –°–∏–º–ø—Ç–æ–º—ã",
        "m_h60": "ü©∫ –ó–¥–æ—Ä–æ–≤—å–µ –∑–∞ 60 —Å–µ–∫—É–Ω–¥",
        "m_mini": "üîÅ –ú–∏–Ω–∏-–ø–ª–∞–Ω—ã",
        "m_care": "üß™ –ö—É–¥–∞ –æ–±—Ä–∞—Ç–∏—Ç—å—Å—è",
        "m_hab": "üìä –ë—ã—Å—Ç—Ä—ã–π –ª–æ–≥ –ø—Ä–∏–≤—ã—á–µ–∫",
        "m_rem": "üóì –ù–∞–ø–æ–º–Ω–∏—Ç—å",
        "m_lang": "üåê –Ø–∑—ã–∫",
        "m_privacy": "üîí –ü—Ä–∏–≤–∞—Ç–Ω–æ—Å—Ç—å –∏ –∫–∞–∫ —ç—Ç–æ —Ä–∞–±–æ—Ç–∞–µ—Ç",
        "m_smart": "üß† –°–º–∞—Ä—Ç-—á–µ–∫-–∏–Ω",
        "m_soon": "üè† –î–æ–º–∞—à–Ω–∏–µ –∞–Ω–∞–ª–∏–∑—ã/–≠–ö–ì ‚Äî —Å–∫–æ—Ä–æ",
        "chips_hb": "–ò–∑–±–µ–≥–∞—Ç—å —Ç—Ä–∏–≥–≥–µ—Ä—ã ‚Ä¢ OTC-–≤–∞—Ä–∏–∞–Ω—Ç—ã ‚Ä¢ –ö–æ–≥–¥–∞ –∫ –≤—Ä–∞—á—É",
        "chips_neck": "–†—É—Ç–∏–Ω–∞ 5 –º–∏–Ω ‚Ä¢ –¢–µ–ø–ª–æ/–ª–µ–¥ ‚Ä¢ –ö—Ä–∞—Å–Ω—ã–µ —Ñ–ª–∞–≥–∏",
    }
}
T["uk"] = {**T["ru"], **{
    "help": "–ö–æ—Ä–æ—Ç–∫—ñ –ø–µ—Ä–µ–≤—ñ—Ä–∫–∏, –ø–ª–∞–Ω –Ω–∞ 24‚Äì48 –≥–æ–¥, –Ω–∞–≥–∞–¥—É–≤–∞–Ω–Ω—è, —â–æ–¥–µ–Ω–Ω—ñ —á–µ–∫-—ñ–Ω–∏.\n–ö–æ–º–∞–Ω–¥–∏: /help /privacy /pause /resume /delete_data /profile /checkin_on 08:30 /checkin_off /settz +2 /health60 /energy /mood /water /skin /ru /uk /en /es /menu",
    "daily_pm":"–í–µ—á—ñ—Ä–Ω—ñ–π —á–µ–∫-—ñ–Ω: —è–∫ –ø—Ä–æ–π—à–æ–≤ –¥–µ–Ω—å?",
    "act_rem_2h": "‚è∞ –ù–∞–≥–∞–¥–∞—Ç–∏ —á–µ—Ä–µ–∑ 2 –≥–æ–¥",
    "energy_title": "–ï–Ω–µ—Ä–≥—ñ—è –Ω–∞ —Å—å–æ–≥–æ–¥–Ω—ñ:",
    "water_prompt": "–í–∏–ø–∏–π 300‚Äì500 –º–ª –≤–æ–¥–∏. –ù–∞–≥–∞–¥–∞—Ç–∏ —á–µ—Ä–µ–∑ 2 –≥–æ–¥–∏–Ω–∏?",
    "skin_title": "–î–æ–≥–ª—è–¥ –∑–∞ —à–∫—ñ—Ä–æ—é/—Ç—ñ–ª–æ–º:",
    "m_menu_title": "–ì–æ–ª–æ–≤–Ω–µ –º–µ–Ω—é",
    "m_h60": "ü©∫ –ó–¥–æ—Ä–æ–≤ º—è –∑–∞ 60 —Å–µ–∫—É–Ω–¥",
}}
T["es"] = T["en"]

# ---------------- Helpers ----------------
def utcnow():
    return datetime.now(timezone.utc)

def iso(dt: Optional[datetime]) -> str:
    return "" if not dt else dt.astimezone(timezone.utc).strftime("%Y-%m-%d %H:%M:%S%z")

def detect_lang_from_text(text: str, fallback: str) -> str:
    s = (text or "").strip()
    if not s:
        return fallback
    low = s.lower()
    if re.search(r"[–∞-—è—ë—ñ—ó—î“ë]", low):
        return "uk" if re.search(r"[—ñ—ó—î“ë]", low) else "ru"
    try:
        return norm_lang(detect(s))
    except Exception:
        return fallback

def profile_is_incomplete(profile_row: dict) -> bool:
    keys = ["sex","age","goal"]
    return sum(1 for k in keys if str(profile_row.get(k) or "").strip()) < 2

# ===== ONBOARDING GATE =====
GATE_FLAG_KEY = "menu_unlocked"

def _is_menu_unlocked(update: Update, context: ContextTypes.DEFAULT_TYPE) -> bool:
    if context.user_data.get(GATE_FLAG_KEY):
        return True
    prof = profiles_get(update.effective_user.id) or {}
    return not profile_is_incomplete(prof)

async def gate_show(update: Update, context: ContextTypes.DEFAULT_TYPE):
    lang = context.user_data.get("lang", "en")
    kb = [
        [InlineKeyboardButton("üß© –ü—Ä–æ–π—Ç–∏ –æ–ø—Ä–æ—Å (40‚Äì60 —Å–µ–∫)" if lang!="en" else "üß© Take the 40‚Äì60s intake", callback_data="intake:start")],
        [InlineKeyboardButton("‚û°Ô∏è –ü–æ–∑–∂–µ ‚Äî –ø–æ–∫–∞–∑–∞—Ç—å –º–µ–Ω—é" if lang!="en" else "‚û°Ô∏è Later ‚Äî open menu", callback_data="gate:skip")],
    ]
    text = ("–ß—Ç–æ–±—ã —Å–æ–≤–µ—Ç—ã –±—ã–ª–∏ —Ç–æ—á–Ω–µ–µ, –ø—Ä–æ–π–¥–∏—Ç–µ –∫–æ—Ä–æ—Ç–∫–∏–π –æ–ø—Ä–æ—Å. –ú–æ–∂–Ω–æ –ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å –∏ —Å–¥–µ–ª–∞—Ç—å –ø–æ–∑–∂–µ."
            if lang!="en" else
            "To personalize answers, please take a short intake. You can skip and do it later.")
    await update.effective_chat.send_message(text, reply_markup=InlineKeyboardMarkup(kb))

async def gate_cb(update: Update, context: ContextTypes.DEFAULT_TYPE):
    q = update.callback_query
    await q.answer()
    if q.data == "gate:skip":
        context.user_data[GATE_FLAG_KEY] = True
        await q.edit_message_text("–û–∫, –æ—Ç–∫—Ä—ã–≤–∞—é –º–µ–Ω—é‚Ä¶" if context.user_data.get("lang","en")!="en" else "OK, opening the menu‚Ä¶")
        render_cb = context.application.bot_data.get("render_menu_cb")
        if callable(render_cb):
            await render_cb(update, context)
        else:
            await context.application.bot.send_message(q.message.chat_id, "/start")

async def _ipro_save_to_sheets_and_open_menu(update: Update, context: ContextTypes.DEFAULT_TYPE, profile: dict):
    uid = update.effective_user.id
    profiles_upsert(uid, {
        "sex": profile.get("sex") or "",
        "age": profile.get("age") or "",
        "goal": profile.get("goal") or "",
        "conditions": ", ".join(sorted(profile.get("chronic", []))) if isinstance(profile.get("chronic"), set) else (profile.get("chronic") or ""),
        "meds": profile.get("meds") or "",
        "activity": profile.get("hab_activity") or "",
        "sleep": profile.get("hab_sleep") or "",
        "notes": ", ".join(sorted(profile.get("complaints", []))) if isinstance(profile.get("complaints"), set) else (profile.get("complaints") or ""),
    })
    users_set(uid, "profile_banner_shown", "no")
    context.user_data[GATE_FLAG_KEY] = True
    render_cb = context.application.bot_data.get("render_menu_cb")
    if callable(render_cb):
        await render_cb(update, context)
    else:
        await context.application.bot.send_message(update.effective_chat.id, "/start")

# ---------- Anti-duplicate ----------
def _ratio(a: str, b: str) -> float:
    return SequenceMatcher(None, (a or "").lower(), (b or "").lower()).ratio()

def is_duplicate_question(uid: int, text: str, thresh: float = 0.93) -> bool:
    s = sessions.setdefault(uid, {})
    asked = s.setdefault("asked_prompts", [])
    for prev in asked[-4:]:
        if _ratio(prev, text) >= thresh:
            return True
    asked.append(text)
    if len(asked) > 16:
        s["asked_prompts"] = asked[-16:]
    return False

async def send_unique(msg_obj, uid: int, text: str, reply_markup=None, force: bool = False):
    if force or not is_duplicate_question(uid, text):
        await msg_obj.reply_text(text, reply_markup=reply_markup)

# -------- Sheets (with memory fallback) --------
SHEETS_ENABLED = True
ss = None
ws_feedback = ws_users = ws_profiles = ws_episodes = ws_reminders = ws_daily = ws_rules = ws_habits = None

USERS_HEADERS = [
    "user_id","username","lang","consent","tz_offset","checkin_hour","paused",
    "quiet_hours","last_sent_utc","sent_today","streak","challenge_id","challenge_day",
    "last_fb_asked","profile_banner_shown"
]
PROFILES_HEADERS = ["user_id","sex","age","goal","conditions","meds","allergies","sleep","activity","diet","notes","updated_at","goals","diet_focus","steps_target","cycle_enabled","cycle_last_date","cycle_avg_len","height_cm","weight_kg","supplements"]
EPISODES_HEADERS = ["episode_id","user_id","topic","started_at","baseline_severity","red_flags","plan_accepted","target","reminder_at","next_checkin_at","status","last_update","notes"]
REMINDERS_HEADERS = ["id","user_id","text","when_utc","created_at","status"]
DAILY_HEADERS = ["timestamp","user_id","mood","comment"]
FEEDBACK_HEADERS = ["timestamp","user_id","name","username","rating","comment"]
RULES_HEADERS = ["rule_id","domain","segment","lang","text","citations"]
HABITS_HEADERS = ["timestamp","user_id","type","value","unit","streak"]

def ws_records(ws, expected_headers):
    try:
        return ws.get_all_records(expected_headers=expected_headers, default_blank="")
    except Exception as e:
        logging.error(f"ws_records fallback ({getattr(ws,'title','?')}): {e}")
        vals = ws.get_all_values()
        if not vals: return []
        body = vals[1:]
        out = []
        for row in body:
            row = (row + [""] * len(expected_headers))[:len(expected_headers)]
            out.append({h: row[i] for i, h in enumerate(expected_headers)})
        return out

GSPREAD_CLIENT: Optional[gspread.client.Client] = None
SPREADSHEET_ID_FOR_INTAKE: str = ""

def _sheets_init():
    global SHEETS_ENABLED, ss, ws_feedback, ws_users, ws_profiles, ws_episodes, ws_reminders, ws_daily, ws_rules, ws_habits
    global GSPREAD_CLIENT, SPREADSHEET_ID_FOR_INTAKE
    try:
        scope = ["https://spreadsheets.google.com/feeds", "https://www.googleapis.com/auth/drive"]
        creds_json = os.getenv("GOOGLE_CREDENTIALS_JSON")
        if not creds_json:
            raise RuntimeError("GOOGLE_CREDENTIALS_JSON is not set")
        creds = json.loads(creds_json)
        credentials = ServiceAccountCredentials.from_json_keyfile_dict(creds, scope)
        gclient = gspread.authorize(credentials)
        GSPREAD_CLIENT = gclient

        try:
            ss = gclient.open_by_key(SHEET_ID) if SHEET_ID else gclient.open(SHEET_NAME)
        except SpreadsheetNotFound:
            if ALLOW_CREATE_SHEET:
                ss = gclient.create(SHEET_NAME)
            else:
                raise

        try:
            SPREADSHEET_ID_FOR_INTAKE = ss.id
        except Exception:
            SPREADSHEET_ID_FOR_INTAKE = SHEET_ID or ""

        def _ensure_ws(title: str, headers: List[str]):
            try:
                ws = ss.worksheet(title)
            except gspread.WorksheetNotFound:
                ws = ss.add_worksheet(title=title, rows=2000, cols=max(20, len(headers)))
                ws.append_row(headers)
            vals = ws.get_all_values()
            if not vals:
                ws.append_row(headers)
            else:
                head = vals[0]
                if len(head) < len(headers):
                    pad = headers[len(head):]
                    ws.update(range_name=f"{gsu.rowcol_to_a1(1,len(head)+1)}:{gsu.rowcol_to_a1(1,len(headers))}",
                              values=[pad])
            return ws

        ws_feedback = _ensure_ws("Feedback", FEEDBACK_HEADERS)
        ws_users    = _ensure_ws("Users", USERS_HEADERS)
        ws_profiles = _ensure_ws("Profiles", PROFILES_HEADERS)
        ws_episodes = _ensure_ws("Episodes", EPISODES_HEADERS)
        ws_reminders= _ensure_ws("Reminders", REMINDERS_HEADERS)
        ws_daily    = _ensure_ws("DailyCheckins", DAILY_HEADERS)
        ws_rules    = _ensure_ws("Rules", RULES_HEADERS)
        ws_habits   = _ensure_ws("HabitsLog", HABITS_HEADERS)
        logging.info("Google Sheets connected.")
    except Exception as e:
        SHEETS_ENABLED = False
        logging.error(f"SHEETS disabled (fallback to memory). Reason: {e}")

_sheets_init()

# --------- Memory fallback stores ----------
MEM_USERS: Dict[int, dict] = {}
MEM_PROFILES: Dict[int, dict] = {}
MEM_EPISODES: List[dict] = []
MEM_REMINDERS: List[dict] = []
MEM_FEEDBACK: List[dict] = []
MEM_DAILY: List[dict] = []
MEM_RULES: List[dict] = []
MEM_HABITS: List[dict] = []

# --------- Sessions ----------
sessions: Dict[int, dict] = {}

# -------- Sheets wrappers --------
def users_get(uid: int) -> dict:
    if SHEETS_ENABLED:
        for r in ws_records(ws_users, USERS_HEADERS):
            if str(r.get("user_id")) == str(uid):
                return r
        return {}
    return MEM_USERS.get(uid, {})

def users_upsert(uid: int, username: str, lang: str):
    base = {
        "user_id": str(uid),
        "username": username or "",
        "lang": lang,
        "consent": "no",
        "tz_offset": "0",
        "checkin_hour": DEFAULT_CHECKIN_LOCAL,
        "paused": "no",
        "quiet_hours": "22:00-08:00",
        "last_sent_utc": "",
        "sent_today": "0",
        "streak": "0",
        "challenge_id": "",
        "challenge_day": "",
        "last_fb_asked": "",
        "profile_banner_shown": "no"
    }
    if SHEETS_ENABLED:
        vals = ws_records(ws_users, USERS_HEADERS)
        for i, r in enumerate(vals, start=2):
            if str(r.get("user_id")) == str(uid):
                merged = {h: r.get(h, "") for h in USERS_HEADERS}
                merged["user_id"] = str(uid)
                if username: merged["username"] = username
                if lang:     merged["lang"] = lang
                end_col = gsu.rowcol_to_a1(1, len(USERS_HEADERS)).rstrip("1")
                ws_users.update(
                    range_name=f"A{i}:{end_col}{i}",
                    values=[[merged.get(h, "") for h in USERS_HEADERS]]
                )
                return
        ws_users.append_row([base.get(h,"") for h in USERS_HEADERS])
    else:
        prev = MEM_USERS.get(uid, {})
        merged = {**base, **prev}
        if username: merged["username"] = username
        if lang:     merged["lang"] = lang
        MEM_USERS[uid] = merged

def users_set(uid: int, field: str, value: str):
    if SHEETS_ENABLED:
        vals = ws_records(ws_users, USERS_HEADERS)
        for i, r in enumerate(vals, start=2):
            if str(r.get("user_id")) == str(uid):
                hdr = USERS_HEADERS
                if field in hdr:
                    ws_users.update_cell(i, hdr.index(field)+1, value)
                return
    else:
        u = MEM_USERS.setdefault(uid, {})
        u[field] = value

def profiles_get(uid: int) -> dict:
    if SHEETS_ENABLED:
        for r in ws_records(ws_profiles, PROFILES_HEADERS):
            if str(r.get("user_id")) == str(uid):
                return r
        return {}
    return MEM_PROFILES.get(uid, {})

def profiles_upsert(uid: int, data: dict):
    if SHEETS_ENABLED:
        hdr = PROFILES_HEADERS
        current, idx = None, None
        for i, r in enumerate(ws_records(ws_profiles, PROFILES_HEADERS), start=2):
            if str(r.get("user_id")) == str(uid):
                current, idx = r, i
                break
        if not current:
            current = {"user_id": str(uid)}
        for k,v in data.items():
            current[k] = "" if v is None else (", ".join(v) if isinstance(v,list) else str(v))
        current["updated_at"] = iso(utcnow())
        values = [current.get(h,"") for h in hdr]
        end_col = gsu.rowcol_to_a1(1, len(hdr)).rstrip("1")
        if idx:
            ws_profiles.update(range_name=f"A{idx}:{end_col}{idx}", values=[values])
        else:
            ws_profiles.append_row(values)
    else:
        row = MEM_PROFILES.setdefault(uid, {"user_id": str(uid)})
        for k,v in data.items():
            row[k] = "" if v is None else (", ".join(v) if isinstance(v,list) else str(v))
        row["updated_at"] = iso(utcnow())

def episode_create(uid: int, topic: str, severity: int, red: str) -> str:
    eid = f"{uid}-{uuid.uuid4().hex[:8]}"
    now = iso(utcnow())
    rec = {"episode_id":eid,"user_id":str(uid),"topic":topic,"started_at":now,
           "baseline_severity":str(severity),"red_flags":red,"plan_accepted":"0",
           "target":"<=3/10","reminder_at":"","next_checkin_at":"","status":"open",
           "last_update":now,"notes":""}
    if SHEETS_ENABLED:
        ws_episodes.append_row([rec.get(h,"") for h in EPISODES_HEADERS])
    else:
        MEM_EPISODES.append(rec)
    return eid

def episode_find_open(uid: int) -> Optional[dict]:
    if SHEETS_ENABLED:
        for r in ws_records(ws_episodes, EPISODES_HEADERS):
            if r.get("user_id")==str(uid) and r.get("status")=="open":
                return r
        return None
    for r in MEM_EPISODES:
        if r["user_id"]==str(uid) and r["status"]=="open":
            return r
    return None

def episode_set(eid: str, field: str, value: str):
    if SHEETS_ENABLED:
        vals = ws_episodes.get_all_values(); hdr = vals[0]
        if field not in hdr:
            return
        col = hdr.index(field)+1
        for i in range(2, len(vals)+1):
            if ws_episodes.cell(i,1).value == eid:
                ws_episodes.update_cell(i,col,value)
                ws_episodes.update_cell(i,hdr.index("last_update")+1, iso(utcnow()))
                return
    else:
        for r in MEM_EPISODES:
            if r["episode_id"]==eid:
                r[field]=value; r["last_update"]=iso(utcnow()); return

def feedback_add(ts, uid, name, username, rating, comment):
    if SHEETS_ENABLED:
        ws_feedback.append_row([ts,str(uid),name,username or "",rating,comment])
    else:
        MEM_FEEDBACK.append({"timestamp":ts,"user_id":str(uid),"name":name,"username":username or "","rating":rating,"comment":comment})

def reminder_add(uid: int, text: str, when_utc: datetime):
    rid = f"{uid}-{uuid.uuid4().hex[:6]}"
    rec = {"id":rid,"user_id":str(uid),"text":text,"when_utc":iso(when_utc),"created_at":iso(utcnow()),"status":"scheduled"}
    if SHEETS_ENABLED:
        ws_reminders.append_row([rec.get(h,"") for h in REMINDERS_HEADERS])
    else:
        MEM_REMINDERS.append(rec)
    return rid

def reminders_all_records():
    if SHEETS_ENABLED:
        return ws_records(ws_reminders, REMINDERS_HEADERS)
    return MEM_REMINDERS.copy()

def reminders_mark_sent(rid: str):
    if SHEETS_ENABLED:
        vals = ws_reminders.get_all_values()
        for i in range(2, len(vals)+1):
            if ws_reminders.cell(i,1).value == rid:
                ws_reminders.update_cell(i,6,"sent"); return
    else:
        for r in MEM_REMINDERS:
            if r["id"]==rid:
                r["status"]="sent"; return

def daily_add(ts, uid, mood, comment):
    if SHEETS_ENABLED:
        ws_daily.append_row([ts,str(uid),mood,comment or ""])
    else:
        MEM_DAILY.append({"timestamp":ts,"user_id":str(uid),"mood":mood,"comment":comment or ""})

# --- HABITS LOG (streak) ---
def habits_add(uid: int, typ: str, value: Optional[str], unit: Optional[str]) -> int:
    ts = iso(utcnow())
    rec = {"timestamp":ts,"user_id":str(uid),"type":typ,"value":value or "1","unit":unit or "", "streak":"0"}
    if SHEETS_ENABLED:
        ws_habits.append_row([rec.get(h,"") for h in HABITS_HEADERS])
        rows = ws_records(ws_habits, HABITS_HEADERS)
        rows = [r for r in rows if r.get("user_id")==str(uid) and r.get("type")==typ]
    else:
        MEM_HABITS.append(rec)
        rows = [r for r in MEM_HABITS if r.get("user_id")==str(uid) and r.get("type")==typ]
    def _to_date(r):
        try:
            dt = datetime.strptime(r["timestamp"], "%Y-%m-%d %H:%M:%S%z").astimezone(timezone.utc).date()
            return dt
        except Exception:
            return utcnow().date()
    rows_sorted = sorted(rows, key=lambda r: r["timestamp"], reverse=True)
    today = (utcnow()).date()
    streak = 0
    expected = today
    for r in rows_sorted:
        d = _to_date(r)
        if d == expected:
            streak = streak + 1 if streak else 1
            expected = expected - timedelta(days=1)
        elif d < expected:
            break
    if rows_sorted:
        rows_sorted[0]["streak"] = str(streak)
    return streak

# --------- JobQueue helper ----------
def _has_jq_app(app) -> bool:
    return getattr(app, "job_queue", None) is not None

def _has_jq_ctx(context: ContextTypes.DEFAULT_TYPE) -> bool:
    try:
        return getattr(context.application, "job_queue", None) is not None
    except Exception:
        return False

# --------- Scheduling (restore) ---------
def schedule_from_sheet_on_start(app):
    if not _has_jq_app(app):
        logging.warning("JobQueue not available ‚Äì skip scheduling on start.")
        return
    now = utcnow()
    src = ws_records(ws_episodes, EPISODES_HEADERS) if SHEETS_ENABLED else MEM_EPISODES
    for r in src:
        if r.get("status")!="open": continue
        eid = r.get("episode_id"); uid = int(r.get("user_id"))
        nca = r.get("next_checkin_at") or ""
        if not nca: continue
        try:
            dt_ = datetime.strptime(nca, "%Y-%m-%d %H:%M:%S%z")
        except:
            continue
        delay = max(60, (dt_-now).total_seconds())
        app.job_queue.run_once(job_checkin_episode, when=delay, data={"user_id":uid,"episode_id":eid})
    for r in reminders_all_records():
        if (r.get("status") or "")!="scheduled": continue
        uid = int(r.get("user_id")); rid=r.get("id")
        try:
            dt_ = datetime.strptime(r.get("when_utc"), "%Y-%m-%d %H:%M:%S%z")
        except:
            continue
        delay = max(60,(dt_-now).total_seconds())
        app.job_queue.run_once(job_oneoff_reminder, when=delay, data={"user_id":uid,"reminder_id":rid})
    src_u = ws_records(ws_users, USERS_HEADERS) if SHEETS_ENABLED else list(MEM_USERS.values())
    for u in src_u:
        if (u.get("paused") or "").lower()=="yes": continue
        uid = int(u.get("user_id"))
        tz_off = int(str(u.get("tz_offset") or "0"))
        hhmm = (u.get("checkin_hour") or DEFAULT_CHECKIN_LOCAL)
        schedule_daily_checkin(app, uid, tz_off, hhmm, norm_lang(u.get("lang") or "en"))
        schedule_morning_evening(app, uid, tz_off, norm_lang(u.get("lang") or "en"))

def hhmm_tuple(hhmm:str)->Tuple[int,int]:
    m = re.search(r'([01]?\d|2[0-3]):([0-5]\d)', hhmm.strip())
    return (int(m.group(1)), int(m.group(2))) if m else (8,30)

def local_to_utc_hour_min(tz_offset_hours:int, hhmm:str)->Tuple[int,int]:
    h,m = hhmm_tuple(hhmm); return ((h - tz_offset_hours) % 24, m)

def schedule_daily_checkin(app, uid:int, tz_off:int, hhmm_local:str, lang:str):
    if not _has_jq_app(app):
        logging.warning(f"JobQueue not available ‚Äì skip daily scheduling for uid={uid}.")
        return
    for j in app.job_queue.get_jobs_by_name(f"daily_{uid}"):
        j.schedule_removal()
    h_utc, m_utc = local_to_utc_hour_min(tz_off, hhmm_local)
    t = dtime(hour=h_utc, minute=m_utc, tzinfo=timezone.utc)
    app.job_queue.run_daily(job_daily_checkin, time=t, name=f"daily_{uid}", data={"user_id":uid,"lang":lang})

def schedule_morning_evening(app, uid:int, tz_off:int, lang:str, evening="20:30"):
    if not _has_jq_app(app): return
    for j in app.job_queue.get_jobs_by_name(f"daily_e_{uid}"):
        j.schedule_removal()
    h_e, m_e = hhmm_tuple(evening); h_e = (h_e - tz_off) % 24
    app.job_queue.run_daily(
        job_evening_checkin,
        dtime(hour=h_e, minute=m_e, tzinfo=timezone.utc),
        name=f"daily_e_{uid}",
        data={"user_id":uid,"lang":lang}
    )

# ------------- Quiet hours / limiter -------------
def _in_quiet(uid: int, now_utc: datetime) -> bool:
    u = users_get(uid)
    q = (u.get("quiet_hours") or "").strip()
    if not q: return False
    m = re.match(r'(\d{1,2}):(\d{2})-(\d{1,2}):(\d{2})', q)
    if not m: return False
    tz_off = int(str(u.get("tz_offset") or "0"))
    local = now_utc + timedelta(hours=tz_off)
    start = local.replace(hour=int(m.group(1)), minute=int(m.group(2)), second=0, microsecond=0)
    end   = local.replace(hour=int(m.group(3)), minute=int(m.group(4)), second=0, microsecond=0)
    if end <= start:
        return local >= start or local <= end
    return start <= local <= end

def can_send(uid: int) -> bool:
    u = users_get(uid)
    if (u.get("paused") or "").lower() == "yes": return False
    if _in_quiet(uid, utcnow()): return False
    sent_today = int(str(u.get("sent_today") or "0"))
    return sent_today < 2

def mark_sent(uid: int):
    u = users_get(uid)
    tz_off = int(str(u.get("tz_offset") or "0"))
    last = u.get("last_sent_utc") or ""
    today_local = (utcnow() + timedelta(hours=tz_off)).date()
    last_local  = None
    if last:
        try:
            last_local = (datetime.strptime(last, "%Y-%m-%d %H:%M:%S%z").astimezone(timezone.utc) + timedelta(hours=tz_off)).date()
        except:
            last_local = None
    sent = 0 if (not last_local or last_local != today_local) else int(str(u.get("sent_today") or "0"))
    users_set(uid, "sent_today", str(sent + 1))
    users_set(uid, "last_sent_utc", iso(utcnow()))

async def maybe_send(context: ContextTypes.DEFAULT_TYPE, uid: int, text: str, kb=None):
    if can_send(uid):
        try:
            await context.bot.send_message(uid, text, reply_markup=kb)
            mark_sent(uid)
        except Exception as e:
            logging.error(f"send fail: {e}")

# ------------- Jobs -------------
async def job_checkin_episode(context: ContextTypes.DEFAULT_TYPE):
    d = context.job.data or {}
    uid, eid = d.get("user_id"), d.get("episode_id")
    if not uid or not eid: return
    u = users_get(uid)
    if (u.get("paused") or "").lower()=="yes": return
    lang = norm_lang(u.get("lang") or "en")
    kb = inline_numbers_0_10()
    try:
        await context.bot.send_message(uid, T[lang]["checkin_ping"], reply_markup=kb)
        episode_set(eid, "next_checkin_at", "")
    except Exception as e:
        logging.error(f"job_checkin_episode send error: {e}")

async def job_oneoff_reminder(context: ContextTypes.DEFAULT_TYPE):
    d = context.job.data or {}
    uid, rid = d.get("user_id"), d.get("reminder_id")
    text = T[norm_lang(users_get(uid).get("lang") or "en")]["thanks"]
    for r in reminders_all_records():
        if r.get("id")==rid:
            text = r.get("text") or text; break
    try:
        await context.bot.send_message(uid, text)
    except Exception as e:
        logging.error(f"reminder send error: {e}")
    reminders_mark_sent(rid)

# ===== LLM Router =====
SYS_ROUTER = (
    "You are TendAI ‚Äî a concise, warm, professional health & longevity assistant (not a doctor). "
    "Always answer strictly in {lang}. Keep replies short. "
    "TRIAGE: ask 1‚Äì2 clarifiers first; advise ER only for clear red flags. "
    "Return JSON ONLY like: "
    "{\"intent\":\"symptom\"|\"nutrition\"|\"sleep\"|\"labs\"|\"habits\"|\"longevity\"|\"other\","
    "\"assistant_reply\":\"string\",\"followups\":[\"string\"],\"needs_more\":true,"
    "\"red_flags\":false,\"confidence\":0.0}"
)

def llm_router_answer(text: str, lang: str, profile: dict) -> dict:
    if not oai:
        return {"intent":"other","assistant_reply":T[lang]["unknown"],"followups":[],"needs_more":True,"red_flags":False,"confidence":0.3}
    sys = SYS_ROUTER.replace("{lang}", lang) + f"\nUserProfile: {json.dumps(profile, ensure_ascii=False)}"
    try:
        resp = oai.chat.completions.create(
            model=OPENAI_MODEL,
            temperature=0.25,
            max_tokens=420,
            response_format={"type":"json_object"},
            messages=[{"role":"system","content":sys},{"role":"user","content":text}]
        )
        out = resp.choices[0].message.content.strip()
        data = json.loads(out)
        if "followups" not in data or data["followups"] is None:
            data["followups"] = []
        return data
    except Exception as e:
        logging.error(f"router LLM error: {e}")
        return {"intent":"other","assistant_reply":T[lang]["unknown"],"followups":[],"needs_more":True,"red_flags":False,"confidence":0.3}

# ===== Rules & tips =====
def rules_match(seg: str, prof: dict) -> bool:
    if not seg:
        return True
    for part in seg.split("&"):
        m = re.match(r'(\w+)\s*(>=|<=|=|>|<)\s*([\w\-]+)', part.strip())
        if not m: return False
        k, op, v = m.groups()
        pv = (prof.get(k) or prof.get(k.lower()) or "")
        if k in ("age","steps_target","cycle_avg_len","height_cm","weight_kg"):
            try: pv = int(re.search(r'\d+', str(pv)).group()); v = int(v)
            except Exception: return False
        else:
            pv = str(pv).lower(); v = str(v).lower()
        if op == "="  and not (pv == v): return False
        if op == ">=" and not (pv >= v): return False
        if op == "<=" and not (pv <= v): return False
        if op == ">"  and not (pv >  v): return False
        if op == "<"  and not (pv <  v): return False
    return True

def _read_rules():
    if SHEETS_ENABLED:
        return ws_records(ws_rules, RULES_HEADERS)
    return MEM_RULES

def pick_nutrition_tips(lang: str, prof: dict, limit: int = 2) -> List[str]:
    tips = []
    for r in _read_rules():
        if (r.get("domain") or "").lower() != "nutrition": continue
        if (r.get("lang") or "en") != lang: continue
        if rules_match(r.get("segment") or "", prof):
            t = (r.get("text") or "").strip()
            if t: tips.append(t)
    random.shuffle(tips)
    return tips[:limit]

# ===== Cycle helpers =====
def cycle_phase_for(uid: int) -> Optional[str]:
    prof = profiles_get(uid)
    if str(prof.get("cycle_enabled") or "").lower() not in {"1","yes","true"}:
        return None
    try:
        last = datetime.strptime(str(prof.get("cycle_last_date")), "%Y-%m-%d").date()
        avg  = int(str(prof.get("cycle_avg_len") or "28"))
    except Exception:
        return None
    day = ((utcnow().date() - last).days % max(avg, 21)) + 1
    if 1 <= day <= 5:   return "menses"
    if 6 <= day <= 13:  return "follicular"
    if 14 <= day <= 15: return "ovulation"
    return "luteal"

def cycle_tip(lang: str, phase: str) -> str:
    base = {
        "menses":   {"ru":"–§–∞–∑–∞ –º–µ–Ω—Å—Ç—Ä—É–∞—Ü–∏–∏: –º—è–≥—á–µ –∫ —Å–µ–±–µ, –∂–µ–ª–µ–∑–æ/–±–µ–ª–æ–∫, —Å–æ–Ω –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç.","en":"Menses phase: go gentle, prioritize iron/protein and sleep."},
        "follicular":{"ru":"–§–æ–ª–ª–∏–∫—É–ª—è—Ä–Ω–∞—è —Ñ–∞–∑–∞: –ª—É—á—à–µ –∑–∞—Ö–æ–¥—è—Ç —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∏/–Ω–æ–≤—ã–µ –∑–∞–¥–∞—á–∏.","en":"Follicular phase: great for workouts and new tasks."},
        "ovulation": {"ru":"–û–≤—É–ª—è—Ü–∏—è: —Å–ª–µ–¥–∏ –∑–∞ —Å–Ω–æ–º –∏ –≥–∏–¥—Ä–∞—Ç–∞—Ü–∏–µ–π.","en":"Ovulation: watch sleep and hydration."},
        "luteal":    {"ru":"–õ—é—Ç–µ–∏–Ω–æ–≤–∞—è: –º–∞–≥–Ω–∏–π/–ø—Ä–æ–≥—É–ª–∫–∞, —Å—Ç–∞–±–∏–ª—å–Ω—ã–π —Å–æ–Ω, –º–µ–Ω—å—à–µ –∫–æ—Ñ–µ–∏–Ω–∞.","en":"Luteal: magnesium/walk, steady sleep, go easy on caffeine."}
    }
    return base.get(phase, {}).get(lang, "")

async def job_daily_checkin(context: ContextTypes.DEFAULT_TYPE):
    d = context.job.data or {}
    uid, lang = d.get("user_id"), d.get("lang","en")
    u = users_get(uid)
    if (u.get("paused") or "").lower()=="yes":
        return
    kb = InlineKeyboardMarkup([
        [InlineKeyboardButton(T[lang]["mood_good"], callback_data="mood|good"),
         InlineKeyboardButton(T[lang]["mood_ok"], callback_data="mood|ok"),
         InlineKeyboardButton(T[lang]["mood_bad"], callback_data="mood|bad")],
        [InlineKeyboardButton(T[lang]["mood_note"], callback_data="mood|note")]
    ])
    await maybe_send(context, uid, T[lang]["daily_gm"], kb)
    prof = profiles_get(uid)
    tips = pick_nutrition_tips(lang, prof, limit=2)
    if tips:
        await maybe_send(context, uid, "‚Ä¢ " + "\n‚Ä¢ ".join(tips))
    phase = cycle_phase_for(uid)
    if phase:
        tip = cycle_tip(lang, phase)
        if tip:
            await maybe_send(context, uid, tip)

async def job_evening_checkin(context: ContextTypes.DEFAULT_TYPE):
    d = context.job.data or {}
    uid, lang = d.get("user_id"), d.get("lang","en")
    u = users_get(uid)
    if (u.get("paused") or "").lower()=="yes":
        return
    kb = InlineKeyboardMarkup([
        [InlineKeyboardButton(T[lang]["mood_good"], callback_data="mood|good"),
         InlineKeyboardButton(T[lang]["mood_ok"],   callback_data="mood|ok"),
         InlineKeyboardButton(T[lang]["mood_bad"],  callback_data="mood|bad")],
        [InlineKeyboardButton(T[lang]["mood_note"], callback_data="mood|note")]
    ])
    await maybe_send(context, uid, T[lang]["daily_pm"], kb)

# ===== Menus / Chips UI =====
def inline_numbers_0_10() -> InlineKeyboardMarkup:
    row1 = [InlineKeyboardButton(str(n), callback_data=f"num|{n}") for n in range(0, 6)]
    row2 = [InlineKeyboardButton(str(n), callback_data=f"num|{n}") for n in range(6, 11)]
    rows = [row1, row2, [InlineKeyboardButton("‚óÄ", callback_data="pain|exit")]]
    return InlineKeyboardMarkup(rows)

def inline_list(options: List[str], prefix: str) -> InlineKeyboardMarkup:
    rows, row = [], []
    for opt in options:
        row.append(InlineKeyboardButton(opt, callback_data=f"{prefix}|{opt}"))
        if len(row) == 3: rows.append(row); row = []
    if row: rows.append(row)
    return InlineKeyboardMarkup(rows)

def inline_main_menu(lang: str) -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup([
        [InlineKeyboardButton(T[lang]["m_h60"], callback_data="menu|h60")],
        [InlineKeyboardButton(T[lang]["m_sym"], callback_data="menu|sym")],
        [InlineKeyboardButton(T[lang]["m_mini"], callback_data="menu|mini")],
        [InlineKeyboardButton(T[lang]["m_care"], callback_data="menu|care")],
        [InlineKeyboardButton(T[lang]["m_hab"], callback_data="menu|hab")],
        [InlineKeyboardButton(T[lang]["m_rem"], callback_data="menu|rem")],
        [InlineKeyboardButton(T[lang]["m_lang"], callback_data="menu|lang")],
        [InlineKeyboardButton(T[lang]["m_privacy"], callback_data="menu|privacy")],
        [InlineKeyboardButton(T[lang]["m_smart"], callback_data="menu|smart")],
        [InlineKeyboardButton(T[lang]["m_soon"], callback_data="menu|coming")]
    ])

def inline_symptoms_menu(lang: str) -> InlineKeyboardMarkup:
    labels = {"en":["Headache","Heartburn","Fatigue","Other"],
              "ru":["–ì–æ–ª–æ–≤–Ω–∞—è –±–æ–ª—å","–ò–∑–∂–æ–≥–∞","–£—Å—Ç–∞–ª–æ—Å—Ç—å","–î—Ä—É–≥–æ–µ"],
              "uk":["–ì–æ–ª–æ–≤–Ω–∏–π –±—ñ–ª—å","–ü–µ—á—ñ—è","–í—Ç–æ–º–∞","–Ü–Ω—à–µ"],
              "es":["Dolor de cabeza","Acidez","Fatiga","Otro"]}[lang]
    return InlineKeyboardMarkup([
        [InlineKeyboardButton(labels[0], callback_data="sym|headache"),
         InlineKeyboardButton(labels[1], callback_data="sym|heartburn")],
        [InlineKeyboardButton(labels[2], callback_data="sym|fatigue"),
         InlineKeyboardButton(labels[3], callback_data="sym|other")],
        [InlineKeyboardButton(T[lang]["back"], callback_data="menu|root")]
    ])

def inline_miniplans_menu(lang: str) -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup([
        [InlineKeyboardButton("Neck pain 5-min" if lang=="en" else "–®–µ—è 5 –º–∏–Ω", callback_data="mini|neck")],
        [InlineKeyboardButton("Sleep reset (3 nights)" if lang=="en" else "–°–æ–Ω-—Ä–µ—Å–µ—Ç (3 –Ω–æ—á–∏)", callback_data="mini|sleepreset")],
        [InlineKeyboardButton("Heartburn: 3 steps" if lang=="en" else "–ò–∑–∂–æ–≥–∞: 3 —à–∞–≥–∞", callback_data="mini|heartburn")],
        [InlineKeyboardButton("Hydration on hot days" if lang=="en" else "–ì–∏–¥—Ä–∞—Ç–∞—Ü–∏—è –≤ –∂–∞—Ä—É", callback_data="mini|hydration")],
        [InlineKeyboardButton(T[lang]["back"], callback_data="menu|root")]
    ])

def inline_findcare_menu(lang: str) -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup([
        [InlineKeyboardButton("Labs near me" if lang=="en" else "–õ–∞–±—ã —Ä—è–¥–æ–º", callback_data="care|labsnear")],
        [InlineKeyboardButton("Urgent care" if lang=="en" else "–ù–µ–æ—Ç–ª–æ–∂–∫–∞", callback_data="care|urgent")],
        [InlineKeyboardButton("Free clinics (NJ)" if lang=="en" else "–ë–µ—Å–ø–ª–∞—Ç–Ω—ã–µ –∫–ª–∏–Ω–∏–∫–∏ (NJ)", callback_data="care|free_nj")],
        [InlineKeyboardButton(T[lang]["back"], callback_data="menu|root")]
    ])

def inline_habits_menu(lang: str) -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup([
        [InlineKeyboardButton("üíß Water",   callback_data="hab|water"),
         InlineKeyboardButton("üö∂ Steps",   callback_data="hab|steps")],
        [InlineKeyboardButton("üò¥ Sleep",   callback_data="hab|sleep"),
         InlineKeyboardButton("üß† Stress",  callback_data="hab|stress")],
        [InlineKeyboardButton("‚öñÔ∏è Weight",  callback_data="hab|weight")],
        [InlineKeyboardButton(T[lang]["back"], callback_data="menu|root")]
    ])

def inline_lang_menu(lang: str) -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup([
        [InlineKeyboardButton("EN", callback_data="lang|en"),
         InlineKeyboardButton("RU", callback_data="lang|ru"),
         InlineKeyboardButton("UK", callback_data="lang|uk"),
         InlineKeyboardButton("ES", callback_data="lang|es")],
        [InlineKeyboardButton(T[lang]["back"], callback_data="menu|root")]
    ])

def inline_feedback_kb(lang: str) -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup([
        [InlineKeyboardButton(T[lang]["fb_good"], callback_data="fb|up"),
         InlineKeyboardButton(T[lang]["fb_bad"],  callback_data="fb|down")],
        [InlineKeyboardButton(T[lang]["fb_free"], callback_data="fb|text")]
    ])

def inline_actions(lang: str) -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup([
        [InlineKeyboardButton("‚è∞ +4h" if lang=="en" else T[lang]["act_rem_4h"],  callback_data="act|rem|4h"),
         InlineKeyboardButton("‚è∞ This evening" if lang=="en" else T[lang]["act_rem_eve"],  callback_data="act|rem|evening"),
         InlineKeyboardButton("‚è∞ Tomorrow morning" if lang=="en" else T[lang]["act_rem_morn"], callback_data="act|rem|morning")],
        [InlineKeyboardButton(T[lang]["h60_btn"], callback_data="act|h60")],
        [InlineKeyboardButton(T[lang]["act_ex_neck"], callback_data="act|ex|neck")],
        [InlineKeyboardButton(T[lang]["act_find_lab"], callback_data="act|lab")],
        [InlineKeyboardButton(T[lang]["act_er"], callback_data="act|er")]
    ])

# ===== Chips text =====
def microplan_text(key: str, lang: str) -> str:
    if key=="neck":
        return {"ru":"–®–µ—è 5 –º–∏–Ω:\n1) –ú–µ–¥–ª–µ–Ω–Ω—ã–µ –Ω–∞–∫–ª–æ–Ω—ã √ó5\n2) –ü–æ–≤–æ—Ä–æ—Ç—ã √ó5\n3) –ü–æ–ª—É–∫—Ä—É–≥–∏ –ø–æ–¥–±–æ—Ä–æ–¥–∫–æ–º √ó5\n4) –†–∞—Å—Ç—è–∂–∫–∞ —Ç—Ä–∞–ø–µ—Ü–∏–π 2√ó20—Å.",
                "en":"Neck 5-min:\n1) Slow flex/extend √ó5\n2) Rotations L/R √ó5\n3) Chin semicircles √ó5\n4) Upper-trap stretch 2√ó20s."}[lang]
    if key=="sleepreset":
        return {"ru":"–°–æ–Ω-—Ä–µ—Å–µ—Ç (3 –Ω–æ—á–∏):\n–ù1: 60–º –±–µ–∑ —ç–∫—Ä–∞–Ω–∞ + —Ñ–∏–∫—Å. –æ—Ç–±–æ–π.\n–ù2: 15–º –≤–Ω–µ –∫—Ä–æ–≤–∞—Ç–∏ –ø—Ä–∏ –ø—Ä–æ–±—É–∂–¥–µ–Ω–∏—è—Ö.\n–ù3: –£—Ç—Ä–µ–Ω–Ω–∏–π —Å–≤–µ—Ç 10‚Äì15–º; –∫–æ—Ñ–µ –¥–æ 14:00.",
                "en":"Sleep reset (3 nights):\nN1: 60-min screen detox + fixed bedtime.\nN2: 15-min out of bed if awake.\nN3: AM light 10‚Äì15m; caffeine by 2pm."}[lang]
    if key=="heartburn":
        return {"ru":"–ò–∑–∂–æ–≥–∞ ‚Äî 3 —à–∞–≥–∞:\n1) –ú–µ–Ω—å—à–µ –ø–æ—Ä—Ü–∏–∏; –Ω–µ –ª–æ–∂–∏—Ç—å—Å—è 3—á.\n2) –£–±—Ä–∞—Ç—å —Ç—Ä–∏–≥–≥–µ—Ä—ã: –∂–∏—Ä–Ω–æ–µ/–∞–ª–∫./–º—è—Ç–∞/—à–æ–∫–æ–ª–∞–¥/–∫–æ—Ñ–µ.\n3) –ê–Ω—Ç–∞—Ü–∏–¥ 2‚Äì3 –¥–Ω—è –ø–æ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏.",
                "en":"Heartburn ‚Äî 3 steps:\n1) Smaller meals; no lying 3h.\n2) Remove triggers: fatty foods, alcohol, mint, chocolate, coffee.\n3) OTC antacid 2‚Äì3 days as directed."}[lang]
    if key=="hydration":
        return {"ru":"–ì–∏–¥—Ä–∞—Ç–∞—Ü–∏—è –≤ –∂–∞—Ä—É: 200‚Äì300 –º–ª –≤–æ–¥—ã –∫–∞–∂–¥—ã–π –∞–∫—Ç–∏–≤–Ω—ã–π —á–∞—Å; —ç–ª–µ–∫—Ç—Ä–æ–ª–∏—Ç—ã –ø—Ä–∏ –¥–ª–∏—Ç–µ–ª—å–Ω–æ–π –∂–∞—Ä–µ; —Å–≤–µ—Ç–ª–∞—è –æ–¥–µ–∂–¥–∞ –∏ —Ç–µ–Ω—å.",
                "en":"Hot-day hydration: 200‚Äì300 ml water each active hour; add electrolytes for prolonged heat; light clothing & shade."}[lang]
    return ""

def chip_text(domain: str, kind: str, lang: str) -> str:
    if domain=="hb":
        if kind=="triggers":
            return {"ru":"–¢—Ä–∏–≥–≥–µ—Ä—ã –∏–∑–∂–æ–≥–∏: –∂–∏—Ä–Ω–æ–µ, –æ—Å—Ç—Ä–æ–µ, —à–æ–∫–æ–ª–∞–¥, –∫–æ—Ñ–µ, —Ü–∏—Ç—Ä—É—Å—ã, –º—è—Ç–∞, –∞–ª–∫–æ–≥–æ–ª—å. –ü–æ—Å–ª–µ–¥–Ω–∏–π –ø—Ä–∏—ë–º –ø–∏—â–∏ ‚â•3—á –¥–æ —Å–Ω–∞.",
                    "en":"Heartburn triggers: fatty/spicy foods, chocolate, coffee, citrus, mint, alcohol. Last meal ‚â•3h before bed."}[lang]
        if kind=="otc":
            return {"ru":"OTC: –∞–Ω—Ç–∞—Ü–∏–¥ (–∞–ª–≥–∏–Ω–∞—Ç—ã/–∫–∞—Ä–±–æ–Ω–∞—Ç—ã) 2‚Äì3 –¥–Ω—è. –ï—Å–ª–∏ —á–∞—Å—Ç–æ ‚Äî –æ–±—Å—É–¥–∏—Ç—å —Å –≤—Ä–∞—á–æ–º.",
                    "en":"OTC: antacid (alginates/carbonates) for 2‚Äì3 days. If frequent ‚Äî discuss with a clinician."}[lang]
        if kind=="red":
            return {"ru":"–ö–æ–≥–¥–∞ –∫ –≤—Ä–∞—á—É –ø—Ä–∏ –∏–∑–∂–æ–≥–µ: –¥–∏—Å—Ñ–∞–≥–∏—è, –∫—Ä–æ–≤—å –≤ —Ä–≤–æ—Ç–µ, —á—ë—Ä–Ω—ã–π —Å—Ç—É–ª, –ø–æ—Ç–µ—Ä—è –≤–µ—Å–∞, –Ω–æ—á–Ω—ã–µ –±–æ–ª–∏, >2‚Äì3 –Ω–µ–¥ –Ω–µ—Å–º–æ—Ç—Ä—è –Ω–∞ –º–µ—Ä—ã.",
                    "en":"See a doctor if: trouble swallowing, vomiting blood, black stools, weight loss, nocturnal pain, >2‚Äì3 weeks despite measures."}[lang]
    if domain=="neck":
        if kind=="routine": return microplan_text("neck", lang)
        if kind=="heat":
            return {"ru":"–®–µ—è: –ø–µ—Ä–≤—ã–µ 48 —á –ª—ë–¥ 10‚Äì15 –º–∏–Ω √ó2‚Äì3/–¥; –∑–∞—Ç–µ–º —Ç–µ–ø–ª–æ; –º—è–≥–∫–∞—è —Ä–∞—Å—Ç—è–∂–∫–∞ –±–µ–∑ –±–æ–ª–∏.",
                    "en":"Neck: first 48h prefer ice 10‚Äì15 min √ó2‚Äì3/day, then heat; gentle stretch without pain."}[lang]
        if kind=="red":
            return {"ru":"–ö—Ä–∞—Å–Ω—ã–µ —Ñ–ª–∞–≥–∏: —Å–ª–∞–±–æ—Å—Ç—å/–æ–Ω–µ–º–µ–Ω–∏–µ —Ä—É–∫, —Ç—Ä–∞–≤–º–∞, –ª–∏—Ö–æ—Ä–∞–¥–∫–∞, –±–æ–ª—å >7/10, –±—ã—Å—Ç—Ä–∞—è –ø—Ä–æ–≥—Ä–µ—Å—Å–∏—è ‚Äî –æ–±—Ä–∞—Ç–∏—Ç—å—Å—è –∫ –≤—Ä–∞—á—É.",
                    "en":"Red flags: arm weakness/numbness, trauma, fever, pain >7/10, rapid progression ‚Äî seek care."}[lang]
    return ""

# ===== CONTINUE IN PART 2 =====
# ======== PART 2 / CONT ========

# --- –≤—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ –º–∏–Ω–∏-—É—Ç–∏–ª–∏—Ç—ã, –Ω–µ –¥—É–±–ª–∏—Ä—É—é—Ç —á–∞—Å—Ç—å 1 ---
def _mk_reminder_utc(uid: int, kind: str) -> Optional[datetime]:
    """Return UTC datetime for +4h / evening / morning using user's tz."""
    u = users_get(uid)
    tz_off = int(str(u.get("tz_offset") or "0"))
    now_utc = utcnow()
    local = now_utc + timedelta(hours=tz_off)
    if kind == "4h":
        target_local = local + timedelta(hours=4)
    elif kind == "evening":
        target_local = local.replace(hour=20, minute=30, second=0, microsecond=0)
        if target_local <= local:
            target_local += timedelta(days=1)
    elif kind == "morning":
        target_local = local.replace(hour=8, minute=30, second=0, microsecond=0)
        if target_local <= local:
            target_local += timedelta(days=1)
    else:
        return None
    return target_local - timedelta(hours=tz_off)

async def _schedule_oneoff(context: ContextTypes.DEFAULT_TYPE, uid: int, when_utc: datetime, text: str):
    rid = reminder_add(uid, text, when_utc)
    if _has_jq_ctx(context):
        delay = max(60, (when_utc - utcnow()).total_seconds())
        context.application.job_queue.run_once(job_oneoff_reminder, when=delay, data={"user_id":uid,"reminder_id":rid})

# ---------- –æ—Å–Ω–æ–≤–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ callback‚Äô–æ–≤ ----------
async def on_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    q = update.callback_query
    data = q.data or ""
    uid  = q.from_user.id
    lang = norm_lang(users_get(uid).get("lang") or "en")
    await q.answer()

    # ===== GATE =====
    if data.startswith("gate:"):
        await gate_cb(update, context)
        return

    # ===== Intake (PRO) –∫–Ω–æ–ø–∫–∞-—Å—Ç–∞—Ä—Ç–µ—Ä =====
    if data == "intake:start":
        # —Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ—Ç—Å—è –ø–ª–∞–≥–∏–Ω–æ–º register_intake_pro(); –ø—Ä–æ—Å—Ç–æ –ø–µ—Ä–µ–¥–∞—ë–º —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
        # –µ—Å–ª–∏ –ø–ª–∞–≥–∏–Ω–∞ –Ω–µ—Ç ‚Äî –≤ fallback –∏–∑ —á–∞—Å—Ç–∏ 1 —É–∂–µ –¥–æ–±–∞–≤–ª–µ–Ω —Ö–µ–Ω–¥–ª–µ—Ä –Ω–∞ ^intake:
        # –∑–¥–µ—Å—å —Å–æ–æ–±—â–∞—Ç—å –Ω–∏—á–µ–≥–æ –Ω–µ –Ω—É–∂–Ω–æ
        return

    # ===== –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é =====
    if data == "menu|root":
        try: await q.edit_message_text(T[lang]["m_menu_title"], reply_markup=inline_main_menu(lang))
        except: await q.message.reply_text(T[lang]["m_menu_title"], reply_markup=inline_main_menu(lang))
        return

    if data == "menu|h60":
        await cmd_health60(update, context); return

    if data == "menu|sym":
        try: await q.edit_message_text("Symptoms:", reply_markup=inline_symptoms_menu(lang))
        except: await q.message.reply_text("Symptoms:", reply_markup=inline_symptoms_menu(lang))
        return

    if data == "menu|mini":
        try: await q.edit_message_text("Mini-plans:", reply_markup=inline_miniplans_menu(lang))
        except: await q.message.reply_text("Mini-plans:", reply_markup=inline_miniplans_menu(lang))
        return

    if data == "menu|care":
        try: await q.edit_message_text("Find care:", reply_markup=inline_findcare_menu(lang))
        except: await q.message.reply_text("Find care:", reply_markup=inline_findcare_menu(lang))
        return

    if data == "menu|hab":
        try: await q.edit_message_text("Habits Quick-log:", reply_markup=inline_habits_menu(lang))
        except: await q.message.reply_text("Habits Quick-log:", reply_markup=inline_habits_menu(lang))
        return

    if data == "menu|rem":
        try: await q.edit_message_text(T[lang]["remind_when"], reply_markup=inline_remind(lang))
        except: await q.message.reply_text(T[lang]["remind_when"], reply_markup=inline_remind(lang))
        return

    if data == "menu|lang":
        try: await q.edit_message_text("Language:", reply_markup=inline_lang_menu(lang))
        except: await q.message.reply_text("Language:", reply_markup=inline_lang_menu(lang))
        return

    if data == "menu|privacy":
        await q.message.reply_text(T[lang]["privacy"]); return

    if data == "menu|smart":
        try: await q.edit_message_text("Smart check-in:", reply_markup=inline_smart_checkin(lang))
        except: await q.message.reply_text("Smart check-in:", reply_markup=inline_smart_checkin(lang))
        return

    if data == "menu|coming":
        await q.message.reply_text({"ru":"–°–∫–æ—Ä–æ!","uk":"–°–∫–æ—Ä–æ!","en":"Coming soon!","es":"¬°Pronto!"}[lang]); return

    # ===== –°–∏–º–ø—Ç–æ–º—ã =====
    if data.startswith("sym|"):
        key = data.split("|",1)[1]
        if key == "headache":
            sessions.setdefault(uid,{})["topic"]="pain"; sessions[uid]["step"]=1
            await q.message.reply_text(T[lang]["triage_pain_q1"], reply_markup=inline_list(T[lang]["triage_pain_q1_opts"], "painloc")); return
        if key == "heartburn":
            await q.message.reply_text(microplan_text("heartburn", lang), reply_markup=chips_hb_kb(lang)); return
        if key == "fatigue":
            await cmd_energy(update, context); return
        if key == "other":
            await q.message.reply_text(T[lang]["unknown"]); return

    # ===== –ú–∏–Ω–∏-–ø–ª–∞–Ω—ã –ø—Ä—è–º—ã–µ =====
    if data.startswith("mini|"):
        key = data.split("|",1)[1]
        await q.message.reply_text(microplan_text(key, lang) or "‚Ä¶", reply_markup=inline_actions(lang))
        return

    # ===== Find care =====
    if data.startswith("care|"):
        kind = data.split("|",1)[1]
        await q.message.reply_text(care_links(kind, lang))
        if kind == "labsnear":
            sessions.setdefault(uid,{})["awaiting_city"] = True
            await q.message.reply_text(T[lang]["act_city_prompt"])
        return

    # ===== Habits Quick-log =====
    if data == "hab|water":
        habits_log_add(uid, "water", "250")
        await q.message.reply_text("üíß +250 ml"); return
    if data == "hab|steps":
        habits_log_add(uid, "steps", "1000")
        await q.message.reply_text("üö∂ +1000"); return
    if data == "hab|sleep":
        habits_log_add(uid, "sleep", "1")
        await q.message.reply_text("üò¥ logged"); return
    if data == "hab|stress":
        habits_log_add(uid, "stress_down", "1")
        await q.message.reply_text("üß† calm logged"); return
    if data == "hab|weight":
        sessions.setdefault(uid,{})["awaiting_weight"] = True
        await q.message.reply_text("–í–≤–µ–¥–∏—Ç–µ –≤–µ—Å (–∫–≥), –Ω–∞–ø—Ä–∏–º–µ—Ä 72.5" if lang!="en" else "Send weight in kg, e.g., 72.5")
        return

    # ===== –ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è =====
    if data.startswith("rem|"):
        kind = data.split("|",1)[1]
        when_utc = _mk_reminder_utc(uid, kind)
        if when_utc:
            await _schedule_oneoff(context, uid, when_utc, T[lang]["thanks"])
            await q.message.reply_text(T[lang]["thanks"])
        return

    # ===== –ë—ã—Å—Ç—Ä—ã–µ –¥–µ–π—Å—Ç–≤–∏—è (–ø–∞–Ω–µ–ª—å –¥–µ–π—Å—Ç–≤–∏–π) =====
    if data.startswith("act|"):
        parts = data.split("|")
        if len(parts) >= 3 and parts[1] == "rem":
            kind = parts[2]
            when_utc = _mk_reminder_utc(uid, kind)
            if when_utc:
                await _schedule_oneoff(context, uid, when_utc, T[lang]["thanks"])
                await q.message.reply_text(T[lang]["thanks"])
            return
        if parts[1] == "h60":
            await cmd_health60(update, context); return
        if parts[1] == "ex" and parts[2] == "neck":
            await q.message.reply_text(microplan_text("neck", lang)); return
        if parts[1] == "lab":
            await q.message.reply_text(care_links("labsnear", lang))
            sessions.setdefault(uid,{})["awaiting_city"] = True
            await q.message.reply_text(T[lang]["act_city_prompt"])
            return
        if parts[1] == "er":
            await q.message.reply_text(T[lang]["er_text"]); return

    # ===== –ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ —è–∑—ã–∫–∞ =====
    if data.startswith("lang|"):
        new_lang = data.split("|",1)[1]
        if new_lang in SUPPORTED:
            users_set(uid, "lang", new_lang)
            lang = new_lang
            await q.message.reply_text({"ru":"–ì–æ—Ç–æ–≤–æ.","uk":"–ì–æ—Ç–æ–≤–æ.","en":"Done.","es":"Listo."}[lang])
            await q.message.reply_text(T[lang]["m_menu_title"], reply_markup=inline_main_menu(lang))
        return

    # ===== –°–æ–≥–ª–∞—Å–∏–µ –Ω–∞ follow-ups =====
    if data.startswith("consent|"):
        users_set(uid, "consent", "yes" if data.endswith("yes") else "no")
        await q.message.reply_text(T[lang]["thanks"]); return

    # ===== –¢—Ä–∏–∞–∂ –±–æ–ª–∏: –ø–æ—à–∞–≥–æ–≤—ã–µ –∫–Ω–æ–ø–∫–∏ =====
    if data.startswith(("painloc|","painkind|","paindur|","num|","painrf|","pain|")):
        s = sessions.setdefault(uid, {"topic":"pain","step":1,"answers":{}})
        if data.startswith("pain|exit"):
            sessions.pop(uid, None)
            await q.message.reply_text(T[lang]["m_menu_title"], reply_markup=inline_main_menu(lang)); return
        if data.startswith("painloc|"):
            s["answers"]["loc"] = data.split("|",1)[1]; s["step"]=2
            await q.message.reply_text(T[lang]["triage_pain_q2"], reply_markup=inline_list(T[lang]["triage_pain_q2_opts"], "painkind")); return
        if data.startswith("painkind|"):
            s["answers"]["kind"] = data.split("|",1)[1]; s["step"]=3
            await q.message.reply_text(T[lang]["triage_pain_q3"], reply_markup=inline_list(T[lang]["triage_pain_q3_opts"], "paindur")); return
        if data.startswith("paindur|"):
            s["answers"]["dur"] = data.split("|",1)[1]; s["step"]=4
            await q.message.reply_text(T[lang]["triage_pain_q4"], reply_markup=inline_numbers_0_10()); return
        if data.startswith("num|"):
            try: s["answers"]["severity"] = int(data.split("|",1)[1])
            except: s["answers"]["severity"] = 5
            s["step"]=5
            await q.message.reply_text(T[lang]["triage_pain_q5"], reply_markup=inline_list(T[lang]["triage_pain_q5_opts"], "painrf")); return
        if data.startswith("painrf|"):
            rf = data.split("|",1)[1]
            s["answers"]["rf"] = rf
            # —Å—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞—Ç—å –ø–ª–∞–Ω
            prof = profiles_get(uid)
            plan_lines = pain_plan(lang, [rf], prof)
            await q.message.reply_text("\n".join(plan_lines), reply_markup=inline_accept(lang))
            return

    # ===== –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –ø–ª–∞–Ω–∞ (accept) =====
    if data.startswith("acc|"):
        kind = data.split("|",1)[1]
        if kind == "yes":
            # –Ω–∞–ø–æ–º–Ω–∏—Ç—å –≤–µ—á–µ—Ä–æ–º –∫–∞–∫ –¥–µ—Ñ–æ–ª—Ç
            when_utc = _mk_reminder_utc(uid, "evening")
            if when_utc:
                await _schedule_oneoff(context, uid, when_utc, T[lang]["checkin_ping"])
        await q.message.reply_text(T[lang]["remind_when"], reply_markup=inline_remind(lang))
        return

    # ===== –ß–∏–ø—ã (–∫–æ–Ω—Ç–µ–∫—Å—Ç–Ω—ã–µ) =====
    if data.startswith("chip|"):
        _, domain, kind = data.split("|",2)
        await q.message.reply_text(chip_text(domain, kind, lang) or "‚Ä¶")
        return

    # fallback ‚Äî –ø–æ–∫–∞–∑–∞—Ç—å –º–µ–Ω—é
    await q.message.reply_text(T[lang]["m_menu_title"], reply_markup=inline_main_menu(lang))

# ====== –í–ê–ñ–ù–û: –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞—Ç—å –æ–±—â–∏–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ callback-–∫–Ω–æ–ø–æ–∫ ======
# (–ï—Å–ª–∏ —ç—Ç–∞ —Å—Ç—Ä–æ–∫–∞ –ø–æ–ø–∞–¥—ë—Ç –Ω–∏–∂–µ run_polling, –æ–Ω–∞ –Ω–µ –≤—ã–ø–æ–ª–Ω–∏—Ç—Å—è.
#  –ü–æ—ç—Ç–æ–º—É —É–±–µ–¥–∏—Å—å, —á—Ç–æ –ß–∞—Å—Ç—å 2 –≤—Å—Ç–∞–≤–ª–µ–Ω–∞ –í–´–®–ï –±–ª–æ–∫–∞ `if __name__ == "__main__": ... run_polling()`.)
try:
    # –µ—Å–ª–∏ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ —É–∂–µ —Å–æ–∑–¥–∞–Ω–æ –∏ –¥–æ—Å—Ç—É–ø–Ω–æ –∫–∞–∫ `application` ‚Äî –¥–æ–±–∞–≤–∏–º —Ö–µ–Ω–¥–ª–µ—Ä –∑–¥–µ—Å—å
    if "application" in globals() and getattr(globals()["application"], "add_handler", None):
        globals()["application"].add_handler(CallbackQueryHandler(on_callback), group=1)
        # —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å —Å—Å—ã–ª–∫—É –Ω–∞ –∞–∫—Ç—É–∞–ª—å–Ω—ã–π —Ä–µ–Ω–¥–µ—Ä –º–µ–Ω—é (–µ—Å–ª–∏ —Ç—Ä–µ–±—É–µ—Ç—Å—è –∏–∑ –¥—Ä—É–≥–∏—Ö –º–µ—Å—Ç)
        globals()["application"].bot_data["render_menu_cb"] = render_main_menu
except Exception as _e:
    logging.warning(f"Deferred callback registration skipped: {_e}")
