# -*- coding: utf-8 -*-
import os, re, json, uuid, logging, math, random
from datetime import datetime, timedelta, timezone, time as dtime, date
from typing import List, Tuple, Dict, Optional, Set
from difflib import SequenceMatcher

from dotenv import load_dotenv
from langdetect import detect, DetectorFactory

from telegram import (
    Update, InlineKeyboardButton, InlineKeyboardMarkup,
    ReplyKeyboardRemove
)
from telegram.ext import (
    ApplicationBuilder, CommandHandler, MessageHandler,
    CallbackQueryHandler, ContextTypes, filters
)

from openai import OpenAI

# ---------- Google Sheets (robust + memory fallback) ----------
import gspread
from gspread.exceptions import SpreadsheetNotFound, WorksheetNotFound
import gspread.utils as gsu
from oauth2client.service_account import ServiceAccountCredentials


# ---------------- Boot & Config ----------------
load_dotenv()
logging.basicConfig(level=logging.INFO, format="%(asctime)s | %(levelname)s | %(message)s")
DetectorFactory.seed = 0

TELEGRAM_TOKEN = os.getenv("TELEGRAM_TOKEN")
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY", "")
OPENAI_MODEL = os.getenv("OPENAI_MODEL", "gpt-4o")

SHEET_NAME = os.getenv("SHEET_NAME", "TendAI Sheets")
SHEET_ID = os.getenv("SHEET_ID", "")
ALLOW_CREATE_SHEET = os.getenv("ALLOW_CREATE_SHEET", "0") == "1"
DEFAULT_CHECKIN_LOCAL = "08:30"
DEFAULT_EVENING_LOCAL = "20:00"
DEFAULT_QUIET_HOURS = "22:00-08:00"
AUTO_MAX_PER_DAY = 2

oai: Optional[OpenAI] = None
try:
    if OPENAI_API_KEY:
        os.environ["OPENAI_API_KEY"] = OPENAI_API_KEY
    oai = OpenAI()
except Exception as e:
    logging.error(f"OpenAI init error: {e}")
    oai = None


# ---------------- i18n ----------------
SUPPORTED = {"ru", "en", "uk", "es"}

def norm_lang(code: Optional[str]) -> str:
    if not code:
        return "en"
    c = code.split("-")[0].lower()
    return c if c in SUPPORTED else "en"

T = {
    "en": {
        "welcome": "Hi! I‚Äôm TendAI ‚Äî your health & longevity assistant.\nDescribe what‚Äôs bothering you; I‚Äôll guide you. Let‚Äôs do a quick 40s intake to tailor advice.",
        "help": "Short checkups, 24‚Äì48h plans, reminders, daily check-ins.\nCommands: /help /privacy /pause /resume /delete_data /profile /checkin_on 08:30 /checkin_off /evening_on 20:00 /evening_off /settz +2 /health60 /mood /energy /hydrate /skintip /cycle /youth /ru /uk /en /es",
        "privacy": "TendAI is not a medical service and can‚Äôt replace a doctor. We store minimal data for reminders. /delete_data to erase.",
        "paused_on": "Notifications paused. Use /resume to enable.",
        "paused_off": "Notifications resumed.",
        "deleted": "All your data was deleted. Use /start to begin again.",
        "ask_consent": "May I send you a follow-up to check how you feel later?",
        "yes":"Yes","no":"No",
        "unknown":"I need a bit more info: where exactly and for how long?",
        "profile_intro":"Quick intake (~40s). Use buttons or type your answer.",
        "p_step_1":"Step 1/8. Sex:",
        "p_step_2":"Step 2/8. Age:",
        "p_step_3":"Step 3/8. Main goal:",
        "p_step_4":"Step 4/8. Chronic conditions:",
        "p_step_5":"Step 5/8. Meds/supplements/allergies:",
        "p_step_6":"Step 6/8. Sleep (bed/wake, e.g., 23:30/07:00):",
        "p_step_7":"Step 7/8. Activity:",
        "p_step_8":"Step 8/8. Diet most of the time:",
        "write":"‚úçÔ∏è Write",
        "skip":"‚è≠Ô∏è Skip",
        "saved_profile":"Saved: ",
        "start_where":"Where do you want to start now? (symptom/sleep/nutrition/labs/habits/longevity)",
        "daily_gm":"Good morning! Quick daily check-in:",
        "mood_good":"üòÉ Good","mood_ok":"üòê Okay","mood_bad":"üò£ Poor","mood_note":"‚úçÔ∏è Comment",
        "mood_thanks":"Thanks! Have a smooth day üëã",
        "mood_cmd":"How do you feel right now?",
        "triage_pain_q1":"Where does it hurt?",
        "triage_pain_q1_opts":["Head","Throat","Back","Belly","Other"],
        "triage_pain_q2":"What kind of pain?",
        "triage_pain_q2_opts":["Dull","Sharp","Pulsating","Pressing"],
        "triage_pain_q3":"How long has it lasted?",
        "triage_pain_q3_opts":["<3h","3‚Äì24h",">1 day",">1 week"],
        "triage_pain_q4":"Rate the pain (0‚Äì10):",
        "triage_pain_q5":"Any of these now?",
        "triage_pain_q5_opts":["High fever","Vomiting","Weakness/numbness","Speech/vision problems","Trauma","None"],
        "plan_header":"Your 24‚Äì48h plan:",
        "plan_accept":"Will you try this today?",
        "accept_opts":["‚úÖ Yes","üîÅ Later","‚úñÔ∏è No"],
        "remind_when":"When shall I check on you?",
        "remind_opts":["in 4h","this evening","tomorrow morning","no need"],
        "thanks":"Got it üôå",
        "checkin_ping":"Quick check-in: how is it now (0‚Äì10)?",
        "checkin_better":"Nice! Keep it up üí™",
        "checkin_worse":"Sorry to hear. If any red flags or pain ‚â•7/10 ‚Äî consider medical help.",
        "act_rem_4h":"‚è∞ Remind in 4h",
        "act_rem_eve":"‚è∞ This evening",
        "act_rem_morn":"‚è∞ Tomorrow morning",
        "act_save_episode":"üíæ Save as episode",
        "act_ex_neck":"üßò 5-min neck routine",
        "act_find_lab":"üß™ Find a lab",
        "act_er":"üöë Emergency info",
        "act_city_prompt":"Type your city/area so I can suggest a lab (text only).",
        "act_saved":"Saved.",
        "er_text":"If symptoms worsen, severe shortness of breath, chest pain, confusion, or persistent high fever ‚Äî seek urgent care/emergency.",
        "px":"Considering your profile: {sex}, {age}y; goal ‚Äî {goal}.",
        "back":"‚óÄ Back",
        "exit":"Exit",
        # feedback
        "ask_fb":"Was this helpful?",
        "fb_thanks":"Thanks for your feedback! ‚úÖ",
        "fb_write":"Write a short feedback message:",
        "fb_good":"üëç Like",
        "fb_bad":"üëé Dislike",
        "fb_free":"üìù Feedback",
        # Health60
        "h60_btn": "Health in 60 seconds",
        "h60_intro": "Write briefly what bothers you (e.g., ‚Äúheadache‚Äù, ‚Äúfatigue‚Äù, ‚Äústomach pain‚Äù). I‚Äôll give you 3 key tips in 60 seconds.",
        "h60_t1": "Possible causes",
        "h60_t2": "Do now (next 24‚Äì48h)",
        "h60_t3": "When to see a doctor",
        "h60_serious": "Serious to rule out",
        # Youth Pack
        "youth_pack": "Youth Pack",
        "gm_energy": "‚ö° Energy",
        "gm_energy_q": "How‚Äôs your energy (1‚Äì5)?",
        "gm_energy_done": "Logged energy ‚Äî thanks!",
        "gm_evening_btn": "‚è∞ Remind this evening",
        "hydrate_btn": "üíß Hydration",
        "hydrate_nudge": "üíß Time for a glass of water",
        "skintip_btn": "üß¥ Skin/Body tip",
        "skintip_sent": "Tip sent.",
        "daily_tip_prefix": "üçé Daily tip:",
        "streak_day": "Day of care",
        "challenge_btn": "üéØ 7-day hydration challenge",
        "challenge_started": "Challenge started! I‚Äôll track your daily check-ins.",
        "challenge_progress": "Challenge progress: {d}/{len} days.",
        "cycle_btn": "ü©∏ Cycle",
        "cycle_consent": "Would you like to track your cycle for gentle timing tips?",
        "cycle_ask_last": "Enter the date of your last period (YYYY-MM-DD):",
        "cycle_ask_len": "Average cycle length in days (e.g., 28):",
        "cycle_saved": "Cycle tracking saved.",
        "quiet_saved": "Quiet hours saved: {qh}",
        "set_quiet_btn": "üåô Set quiet hours",
        "ask_quiet": "Type quiet hours as HH:MM-HH:MM (local), e.g. 22:00-08:00",
        "evening_intro": "Evening check-in:",
        "evening_tip_btn": "ü™Ñ Tip of the day",
        "evening_set": "Evening check-in set to {t} (local).",
        "evening_off": "Evening check-in disabled.",
        # Quickbar
        "quick_title":"Quick actions",
        "quick_rem":"‚è∞ Reminder",
    },
    "ru": {
        "welcome":"–ü—Ä–∏–≤–µ—Ç! –Ø TendAI ‚Äî –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç –∑–¥–æ—Ä–æ–≤—å—è –∏ –¥–æ–ª–≥–æ–ª–µ—Ç–∏—è.\n–†–∞—Å—Å–∫–∞–∂–∏, —á—Ç–æ –±–µ—Å–ø–æ–∫–æ–∏—Ç; —è –ø–æ–¥—Å–∫–∞–∂—É. –°–Ω–∞—á–∞–ª–∞ –∫–æ—Ä–æ—Ç–∫–∏–π –æ–ø—Ä–æ—Å (~40—Å), —á—Ç–æ–±—ã —Å–æ–≤–µ—Ç—ã –±—ã–ª–∏ —Ç–æ—á–Ω–µ–µ.",
        "help":"–ö–æ—Ä–æ—Ç–∫–∏–µ –ø—Ä–æ–≤–µ—Ä–∫–∏, –ø–ª–∞–Ω –Ω–∞ 24‚Äì48 —á, –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è, –µ–∂–µ–¥–Ω–µ–≤–Ω—ã–µ —á–µ–∫-–∏–Ω—ã.\n–ö–æ–º–∞–Ω–¥—ã: /help /privacy /pause /resume /delete_data /profile /checkin_on 08:30 /checkin_off /evening_on 20:00 /evening_off /settz +3 /health60 /mood /energy /hydrate /skintip /cycle /youth /ru /uk /en /es",
        "privacy":"TendAI –Ω–µ –∑–∞–º–µ–Ω—è–µ—Ç –≤—Ä–∞—á–∞. –•—Ä–∞–Ω–∏–º –º–∏–Ω–∏–º—É–º –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π. /delete_data ‚Äî —É–¥–∞–ª–∏—Ç—å.",
        "paused_on":"–ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è –ø–æ—Å—Ç–∞–≤–ª–µ–Ω—ã –Ω–∞ –ø–∞—É–∑—É. /resume ‚Äî –≤–∫–ª—é—á–∏—Ç—å.",
        "paused_off":"–ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è —Å–Ω–æ–≤–∞ –≤–∫–ª—é—á–µ–Ω—ã.",
        "deleted":"–í—Å–µ –¥–∞–Ω–Ω—ã–µ —É–¥–∞–ª–µ–Ω—ã. /start ‚Äî –Ω–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ.",
        "ask_consent":"–ú–æ–∂–Ω–æ –ø—Ä–∏—Å–ª–∞—Ç—å –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ –ø–æ–∑–∂–µ, —á—Ç–æ–±—ã —É–∑–Ω–∞—Ç—å, –∫–∞–∫ –≤—ã?",
        "yes":"–î–∞","no":"–ù–µ—Ç",
        "unknown":"–ù—É–∂–Ω–æ —á—É—Ç—å –±–æ–ª—å—à–µ –¥–µ—Ç–∞–ª–µ–π: –≥–¥–µ –∏–º–µ–Ω–Ω–æ –∏ —Å–∫–æ–ª—å–∫–æ –¥–ª–∏—Ç—Å—è?",
        "profile_intro":"–ë—ã—Å—Ç—Ä—ã–π –æ–ø—Ä–æ—Å (~40—Å). –ú–æ–∂–Ω–æ –Ω–∞–∂–∏–º–∞—Ç—å –∫–Ω–æ–ø–∫–∏ –∏–ª–∏ –ø–∏—Å–∞—Ç—å —Å–≤–æ–π –æ—Ç–≤–µ—Ç.",
        "p_step_1":"–®–∞–≥ 1/8. –ü–æ–ª:",
        "p_step_2":"–®–∞–≥ 2/8. –í–æ–∑—Ä–∞—Å—Ç:",
        "p_step_3":"–®–∞–≥ 3/8. –ì–ª–∞–≤–Ω–∞—è —Ü–µ–ª—å:",
        "p_step_4":"–®–∞–≥ 4/8. –•—Ä–æ–Ω–∏—á–µ—Å–∫–∏–µ –±–æ–ª–µ–∑–Ω–∏:",
        "p_step_5":"–®–∞–≥ 5/8. –õ–µ–∫–∞—Ä—Å—Ç–≤–∞/–¥–æ–±–∞–≤–∫–∏/–∞–ª–ª–µ—Ä–≥–∏–∏:",
        "p_step_6":"–®–∞–≥ 6/8. –°–æ–Ω (–æ—Ç–±–æ–π/–ø–æ–¥—ä—ë–º, –Ω–∞–ø—Ä. 23:30/07:00):",
        "p_step_7":"–®–∞–≥ 7/8. –ê–∫—Ç–∏–≤–Ω–æ—Å—Ç—å:",
        "p_step_8":"–®–∞–≥ 8/8. –ü–∏—Ç–∞–Ω–∏–µ —á–∞—â–µ –≤—Å–µ–≥–æ:",
        "write":"‚úçÔ∏è –ù–∞–ø–∏—Å–∞—Ç—å",
        "skip":"‚è≠Ô∏è –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å",
        "saved_profile":"–°–æ—Ö—Ä–∞–Ω–∏–ª: ",
        "start_where":"–° —á–µ–≥–æ –Ω–∞—á–Ω—ë–º? (—Å–∏–º–ø—Ç–æ–º/—Å–æ–Ω/–ø–∏—Ç–∞–Ω–∏–µ/–∞–Ω–∞–ª–∏–∑—ã/–ø—Ä–∏–≤—ã—á–∫–∏/–¥–æ–ª–≥–æ–ª–µ—Ç–∏–µ)",
        "daily_gm":"–î–æ–±—Ä–æ–µ —É—Ç—Ä–æ! –ë—ã—Å—Ç—Ä—ã–π —á–µ–∫-–∏–Ω:",
        "mood_good":"üòÉ –•–æ—Ä–æ—à–æ","mood_ok":"üòê –ù–æ—Ä–º–∞–ª—å–Ω–æ","mood_bad":"üò£ –ü–ª–æ—Ö–æ","mood_note":"‚úçÔ∏è –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π",
        "mood_thanks":"–°–ø–∞—Å–∏–±–æ! –•–æ—Ä–æ—à–µ–≥–æ –¥–Ω—è üëã",
        "mood_cmd":"–ö–∞–∫ —Å–µ–π—á–∞—Å —Å–∞–º–æ—á—É–≤—Å—Ç–≤–∏–µ?",
        "triage_pain_q1":"–ì–¥–µ –±–æ–ª–∏—Ç?",
        "triage_pain_q1_opts":["–ì–æ–ª–æ–≤–∞","–ì–æ—Ä–ª–æ","–°–ø–∏–Ω–∞","–ñ–∏–≤–æ—Ç","–î—Ä—É–≥–æ–µ"],
        "triage_pain_q2":"–ö–∞–∫–æ–π —Ö–∞—Ä–∞–∫—Ç–µ—Ä –±–æ–ª–∏?",
        "triage_pain_q2_opts":["–¢—É–ø–∞—è","–û—Å—Ç—Ä–∞—è","–ü—É–ª—å—Å–∏—Ä—É—é—â–∞—è","–î–∞–≤—è—â–∞—è"],
        "triage_pain_q3":"–ö–∞–∫ –¥–æ–ª–≥–æ –¥–ª–∏—Ç—Å—è?",
        "triage_pain_q3_opts":["<3—á","3‚Äì24—á",">1 –¥–Ω—è",">1 –Ω–µ–¥–µ–ª–∏"],
        "triage_pain_q4":"–û—Ü–µ–Ω–∏—Ç–µ –±–æ–ª—å (0‚Äì10):",
        "triage_pain_q5":"–ï—Å—Ç—å –ª–∏ —á—Ç–æ-—Ç–æ –∏–∑ —ç—Ç–æ–≥–æ —Å–µ–π—á–∞—Å?",
        "triage_pain_q5_opts":["–í—ã—Å–æ–∫–∞—è —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞","–†–≤–æ—Ç–∞","–°–ª–∞–±–æ—Å—Ç—å/–æ–Ω–µ–º–µ–Ω–∏–µ","–ù–∞—Ä—É—à–µ–Ω–∏–µ —Ä–µ—á–∏/–∑—Ä–µ–Ω–∏—è","–¢—Ä–∞–≤–º–∞","–ù–µ—Ç"],
        "plan_header":"–í–∞—à –ø–ª–∞–Ω –Ω–∞ 24‚Äì48 —á–∞—Å–æ–≤:",
        "plan_accept":"–ì–æ—Ç–æ–≤—ã –ø–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å —Å–µ–≥–æ–¥–Ω—è?",
        "accept_opts":["‚úÖ –î–∞","üîÅ –ü–æ–∑–∂–µ","‚úñÔ∏è –ù–µ—Ç"],
        "remind_when":"–ö–æ–≥–¥–∞ –Ω–∞–ø–æ–º–Ω–∏—Ç—å –∏ —Å–ø—Ä–æ—Å–∏—Ç—å —Å–∞–º–æ—á—É–≤—Å—Ç–≤–∏–µ?",
        "remind_opts":["—á–µ—Ä–µ–∑ 4 —á–∞—Å–∞","–≤–µ—á–µ—Ä–æ–º","–∑–∞–≤—Ç—Ä–∞ —É—Ç—Ä–æ–º","–Ω–µ –Ω–∞–¥–æ"],
        "thanks":"–ü—Ä–∏–Ω—è—Ç–æ üôå",
        "checkin_ping":"–ö–æ—Ä–æ—Ç–∫–æ: –∫–∞–∫ —Å–µ–π—á–∞—Å –ø–æ —à–∫–∞–ª–µ 0‚Äì10?",
        "checkin_better":"–û—Ç–ª–∏—á–Ω–æ! –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º üí™",
        "checkin_worse":"–ï—Å–ª–∏ –µ—Å—Ç—å ¬´–∫—Ä–∞—Å–Ω—ã–µ —Ñ–ª–∞–≥–∏¬ª –∏–ª–∏ –±–æ–ª—å ‚â•7/10 ‚Äî –ª—É—á—à–µ –æ–±—Ä–∞—Ç–∏—Ç—å—Å—è –∫ –≤—Ä–∞—á—É.",
        "act_rem_4h":"‚è∞ –ù–∞–ø–æ–º–Ω–∏—Ç—å —á–µ—Ä–µ–∑ 4 —á",
        "act_rem_eve":"‚è∞ –°–µ–≥–æ–¥–Ω—è –≤–µ—á–µ—Ä–æ–º",
        "act_rem_morn":"‚è∞ –ó–∞–≤—Ç—Ä–∞ —É—Ç—Ä–æ–º",
        "act_save_episode":"üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å —ç–ø–∏–∑–æ–¥",
        "act_ex_neck":"üßò 5-–º–∏–Ω —É–ø—Ä–∞–∂–Ω–µ–Ω–∏—è –¥–ª—è —à–µ–∏",
        "act_find_lab":"üß™ –ù–∞–π—Ç–∏ –ª–∞–±–æ—Ä–∞—Ç–æ—Ä–∏—é",
        "act_er":"üöë –ö–æ–≥–¥–∞ —Å—Ä–æ—á–Ω–æ –≤ —Å–∫–æ—Ä—É—é",
        "act_city_prompt":"–ù–∞–ø–∏—à–∏—Ç–µ –≥–æ—Ä–æ–¥/—Ä–∞–π–æ–Ω, —á—Ç–æ–±—ã –ø–æ–¥—Å–∫–∞–∑–∞—Ç—å –ª–∞–±–æ—Ä–∞—Ç–æ—Ä–∏—é (—Ç–µ–∫—Å—Ç–æ–º).",
        "act_saved":"–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ.",
        "er_text":"–ï—Å–ª–∏ –Ω–∞—Ä–∞—Å—Ç–∞–µ—Ç, —Å–∏–ª—å–Ω–∞—è –æ–¥—ã—à–∫–∞, –±–æ–ª—å –≤ –≥—Ä—É–¥–∏, —Å–ø—É—Ç–∞–Ω–Ω–æ—Å—Ç—å, —Å—Ç–æ–π–∫–∞—è –≤—ã—Å–æ–∫–∞—è —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞ ‚Äî –∫–∞–∫ –º–æ–∂–Ω–æ —Å–∫–æ—Ä–µ–µ –∫ –Ω–µ–æ—Ç–ª–æ–∂–∫–µ/—Å–∫–æ—Ä–æ–π.",
        "px":"–° —É—á—ë—Ç–æ–º –ø—Ä–æ—Ñ–∏–ª—è: {sex}, {age} –ª–µ—Ç; —Ü–µ–ª—å ‚Äî {goal}.",
        "back":"‚óÄ –ù–∞–∑–∞–¥",
        "exit":"–í—ã–π—Ç–∏",
        # feedback
        "ask_fb":"–≠—Ç–æ –±—ã–ª–æ –ø–æ–ª–µ–∑–Ω–æ?",
        "fb_thanks":"–°–ø–∞—Å–∏–±–æ –∑–∞ –æ—Ç–∑—ã–≤! ‚úÖ",
        "fb_write":"–ù–∞–ø–∏—à–∏—Ç–µ –∫–æ—Ä–æ—Ç–∫–∏–π –æ—Ç–∑—ã–≤ –æ–¥–Ω–∏–º —Å–æ–æ–±—â–µ–Ω–∏–µ–º:",
        "fb_good":"üëç –ù—Ä–∞–≤–∏—Ç—Å—è",
        "fb_bad":"üëé –ù–µ –ø–æ–ª–µ–∑–Ω–æ",
        "fb_free":"üìù –û—Ç–∑—ã–≤",
        # Health60
        "h60_btn": "–ó–¥–æ—Ä–æ–≤—å–µ –∑–∞ 60 —Å–µ–∫—É–Ω–¥",
        "h60_intro": "–ö–æ—Ä–æ—Ç–∫–æ –Ω–∞–ø–∏—à–∏—Ç–µ, —á—Ç–æ –±–µ—Å–ø–æ–∫–æ–∏—Ç (–Ω–∞–ø—Ä–∏–º–µ—Ä: ¬´–±–æ–ª–∏—Ç –≥–æ–ª–æ–≤–∞¬ª, ¬´—É—Å—Ç–∞–ª–æ—Å—Ç—å¬ª, ¬´–±–æ–ª—å –≤ –∂–∏–≤–æ—Ç–µ¬ª). –Ø –¥–∞–º 3 –∫–ª—é—á–µ–≤—ã—Ö —Å–æ–≤–µ—Ç–∞ –∑–∞ 60 —Å–µ–∫—É–Ω–¥.",
        "h60_t1": "–í–æ–∑–º–æ–∂–Ω—ã–µ –ø—Ä–∏—á–∏–Ω—ã",
        "h60_t2": "–ß—Ç–æ —Å–¥–µ–ª–∞—Ç—å —Å–µ–π—á–∞—Å (24‚Äì48 —á)",
        "h60_t3": "–ö–æ–≥–¥–∞ –æ–±—Ä–∞—Ç–∏—Ç—å—Å—è –∫ –≤—Ä–∞—á—É",
        "h60_serious": "–ß—Ç–æ —Å–µ—Ä—å—ë–∑–Ω–æ–µ –∏—Å–∫–ª—é—á–∏—Ç—å",
        # Youth Pack
        "youth_pack": "–ú–æ–ª–æ–¥—ë–∂–Ω—ã–π –ø–∞–∫–µ—Ç",
        "gm_energy": "‚ö° –≠–Ω–µ—Ä–≥–∏—è",
        "gm_energy_q": "–ö–∞–∫ —ç–Ω–µ—Ä–≥–∏—è (1‚Äì5)?",
        "gm_energy_done": "–ó–∞–ø–∏—Å–∞–ª —ç–Ω–µ—Ä–≥–∏—é ‚Äî —Å–ø–∞—Å–∏–±–æ!",
        "gm_evening_btn": "‚è∞ –ù–∞–ø–æ–º–Ω–∏—Ç—å –≤–µ—á–µ—Ä–æ–º",
        "hydrate_btn": "üíß –ì–∏–¥—Ä–∞—Ç–∞—Ü–∏—è",
        "hydrate_nudge": "üíß –í—Ä–µ–º—è –¥–ª—è —Å—Ç–∞–∫–∞–Ω–∞ –≤–æ–¥—ã",
        "skintip_btn": "üß¥ –°–æ–≤–µ—Ç—ã –¥–ª—è –∫–æ–∂–∏/—Ç–µ–ª–∞",
        "skintip_sent": "–°–æ–≤–µ—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω.",
        "daily_tip_prefix": "üçé –ü–æ–¥—Å–∫–∞–∑–∫–∞ –¥–Ω—è:",
        "streak_day": "–î–µ–Ω—å –∑–∞–±–æ—Ç—ã",
        "challenge_btn": "üéØ –ß–µ–ª–ª–µ–Ω–¥–∂ 7 –¥–Ω–µ–π (–≤–æ–¥–∞)",
        "challenge_started": "–ß–µ–ª–ª–µ–Ω–¥–∂ –Ω–∞—á–∞—Ç! –ë—É–¥—É —É—á–∏—Ç—ã–≤–∞—Ç—å –≤–∞—à–∏ –µ–∂–µ–¥–Ω–µ–≤–Ω—ã–µ —á–µ–∫-–∏–Ω—ã.",
        "challenge_progress": "–ü—Ä–æ–≥—Ä–µ—Å—Å —á–µ–ª–ª–µ–Ω–¥–∂–∞: {d}/{len} –¥–Ω–µ–π.",
        "cycle_btn": "ü©∏ –¶–∏–∫–ª",
        "cycle_consent": "–•–æ—Ç–∏—Ç–µ –æ—Ç—Å–ª–µ–∂–∏–≤–∞—Ç—å —Ü–∏–∫–ª –∏ –ø–æ–ª—É—á–∞—Ç—å –º—è–≥–∫–∏–µ –ø–æ–¥—Å–∫–∞–∑–∫–∏ –≤–æ–≤—Ä–µ–º—è?",
        "cycle_ask_last": "–í–≤–µ–¥–∏—Ç–µ –¥–∞—Ç—É –ø–æ—Å–ª–µ–¥–Ω–∏—Ö –º–µ—Å—è—á–Ω—ã—Ö (–ì–ì–ì–ì-–ú–ú-–î–î):",
        "cycle_ask_len": "–°—Ä–µ–¥–Ω—è—è –¥–ª–∏–Ω–∞ —Ü–∏–∫–ª–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä, 28):",
        "cycle_saved": "–û—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ —Ü–∏–∫–ª–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ.",
        "quiet_saved": "–¢–∏—Ö–∏–µ —á–∞—Å—ã —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã: {qh}",
        "set_quiet_btn": "üåô –¢–∏—Ö–∏–µ —á–∞—Å—ã",
        "ask_quiet": "–í–≤–µ–¥–∏—Ç–µ —Ç–∏—Ö–∏–µ —á–∞—Å—ã –∫–∞–∫ –ß–ß:–ú–ú-–ß–ß:–ú–ú (–ª–æ–∫–∞–ª—å–Ω–æ), –Ω–∞–ø—Ä. 22:00-08:00",
        "evening_intro": "–í–µ—á–µ—Ä–Ω–∏–π —á–µ–∫-–∏–Ω:",
        "evening_tip_btn": "ü™Ñ –°–æ–≤–µ—Ç –¥–Ω—è",
        "evening_set": "–í–µ—á–µ—Ä–Ω–∏–π —á–µ–∫-–∏–Ω —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –Ω–∞ {t} (–ª–æ–∫–∞–ª—å–Ω–æ).",
        "evening_off": "–í–µ—á–µ—Ä–Ω–∏–π —á–µ–∫-–∏–Ω –æ—Ç–∫–ª—é—á—ë–Ω.",
        # Quickbar
        "quick_title":"–ë—ã—Å—Ç—Ä—ã–µ –¥–µ–π—Å—Ç–≤–∏—è",
        "quick_rem":"‚è∞ –ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ",
    },
    "uk": {
        "welcome":"–ü—Ä–∏–≤—ñ—Ç! –Ø TendAI ‚Äî –∞—Å–∏—Å—Ç–µ–Ω—Ç –∑–¥–æ—Ä–æ–≤‚Äô—è —Ç–∞ –¥–æ–≤–≥–æ–ª—ñ—Ç—Ç—è.\n–†–æ–∑–∫–∞–∂–∏, —â–æ —Ç—É—Ä–±—É—î; —è –ø—ñ–¥–∫–∞–∂—É. –°–ø–µ—Ä—à—É —à–≤–∏–¥–∫–∏–π –æ–ø–∏—Ç–Ω–∏–∫ (~40—Å) –¥–ª—è —Ç–æ—á–Ω—ñ—à–∏—Ö –ø–æ—Ä–∞–¥.",
        "help":"–ö–æ—Ä–æ—Ç–∫—ñ –ø–µ—Ä–µ–≤—ñ—Ä–∫–∏, –ø–ª–∞–Ω –Ω–∞ 24‚Äì48 –≥–æ–¥, –Ω–∞–≥–∞–¥—É–≤–∞–Ω–Ω—è, —â–æ–¥–µ–Ω–Ω—ñ —á–µ–∫-—ñ–Ω–∏.\n–ö–æ–º–∞–Ω–¥–∏: /help /privacy /pause /resume /delete_data /profile /checkin_on 08:30 /checkin_off /evening_on 20:00 /evening_off /settz +2 /health60 /mood /energy /hydrate /skintip /cycle /youth /ru /uk /en /es",
        "privacy":"TendAI –Ω–µ –∑–∞–º—ñ–Ω—é—î –ª—ñ–∫–∞—Ä—è. –ó–±–µ—Ä—ñ–≥–∞—î–º–æ –º—ñ–Ω—ñ–º—É–º –¥–∞–Ω–∏—Ö –¥–ª—è –Ω–∞–≥–∞–¥—É–≤–∞–Ω—å. /delete_data ‚Äî –≤–∏–¥–∞–ª–∏—Ç–∏.",
        "paused_on":"–ù–∞–≥–∞–¥—É–≤–∞–Ω–Ω—è –ø—Ä–∏–∑—É–ø–∏–Ω–µ–Ω—ñ. /resume ‚Äî —É–≤—ñ–º–∫–Ω—É—Ç–∏.",
        "paused_off":"–ù–∞–≥–∞–¥—É–≤–∞–Ω–Ω—è –∑–Ω–æ–≤—É —É–≤—ñ–º–∫–Ω–µ–Ω—ñ.",
        "deleted":"–£—Å—ñ –¥–∞–Ω—ñ –≤–∏–¥–∞–ª–µ–Ω–æ. /start ‚Äî –ø–æ—á–∞—Ç–∏ –∑–Ω–æ–≤—É.",
        "ask_consent":"–ú–æ–∂—É –Ω–∞–¥—ñ—Å–ª–∞—Ç–∏ –Ω–∞–≥–∞–¥—É–≤–∞–Ω–Ω—è –ø—ñ–∑–Ω—ñ—à–µ, —â–æ–± –¥—ñ–∑–Ω–∞—Ç–∏—Å—è, —è–∫ –≤–∏?",
        "yes":"–¢–∞–∫","no":"–ù—ñ",
        "unknown":"–ü–æ—Ç—Ä—ñ–±–Ω–æ —Ç—Ä–æ—Ö–∏ –±—ñ–ª—å—à–µ: –¥–µ —Å–∞–º–µ —ñ —Å–∫—ñ–ª—å–∫–∏ —Ç—Ä–∏–≤–∞—î?",
        "profile_intro":"–®–≤–∏–¥–∫–∏–π –æ–ø–∏—Ç–Ω–∏–∫ (~40—Å). –ú–æ–∂–Ω–∞ –Ω–∞—Ç–∏—Å–∫–∞—Ç–∏ –∫–Ω–æ–ø–∫–∏ –∞–±–æ –ø–∏—Å–∞—Ç–∏ —Å–≤—ñ–π –≤–∞—Ä—ñ–∞–Ω—Ç.",
        "p_step_1":"–ö—Ä–æ–∫ 1/8. –°—Ç–∞—Ç—å:",
        "p_step_2":"–ö—Ä–æ–∫ 2/8. –í—ñ–∫:",
        "p_step_3":"–ö—Ä–æ–∫ 3/8. –ì–æ–ª–æ–≤–Ω–∞ –º–µ—Ç–∞:",
        "p_step_4":"–ö—Ä–æ–∫ 4/8. –•—Ä–æ–Ω—ñ—á–Ω—ñ —Ö–≤–æ—Ä–æ–±–∏:",
        "p_step_5":"–ö—Ä–æ–∫ 5/8. –õ—ñ–∫–∏/–¥–æ–±–∞–≤–∫–∏/–∞–ª–µ—Ä–≥—ñ—ó:",
        "p_step_6":"–ö—Ä–æ–∫ 6/8. –°–æ–Ω (–≤—ñ–¥–±—ñ–π/–ø—ñ–¥–π–æ–º, –Ω–∞–ø—Ä. 23:30/07:00):",
        "p_step_7":"–ö—Ä–æ–∫ 7/8. –ê–∫—Ç–∏–≤–Ω—ñ—Å—Ç—å:",
        "p_step_8":"–ö—Ä–æ–∫ 8/8. –•–∞—Ä—á—É–≤–∞–Ω–Ω—è –ø–µ—Ä–µ–≤–∞–∂–Ω–æ:",
        "write":"‚úçÔ∏è –ù–∞–ø–∏—Å–∞—Ç–∏",
        "skip":"‚è≠Ô∏è –ü—Ä–æ–ø—É—Å—Ç–∏—Ç–∏",
        "saved_profile":"–ó–±–µ—Ä—ñ–≥: ",
        "start_where":"–ó —á–æ–≥–æ –ø–æ—á–Ω–µ–º–æ? (—Å–∏–º–ø—Ç–æ–º/—Å–æ–Ω/—Ö–∞—Ä—á—É–≤–∞–Ω–Ω—è/–∞–Ω–∞–ª—ñ–∑–∏/–∑–≤–∏—á–∫–∏/–¥–æ–≤–≥–æ–ª—ñ—Ç—Ç—è)",
        "daily_gm":"–î–æ–±—Ä–æ–≥–æ —Ä–∞–Ω–∫—É! –®–≤–∏–¥–∫–∏–π —á–µ–∫-—ñ–Ω:",
        "mood_good":"üòÉ –î–æ–±—Ä–µ","mood_ok":"üòê –ù–æ—Ä–º–∞–ª—å–Ω–æ","mood_bad":"üò£ –ü–æ–≥–∞–Ω–æ","mood_note":"‚úçÔ∏è –ö–æ–º–µ–Ω—Ç–∞—Ä",
        "mood_thanks":"–î—è–∫—É—é! –ì–∞—Ä–Ω–æ–≥–æ –¥–Ω—è üëã",
        "mood_cmd":"–Ø–∫ –ø–æ—á—É–≤–∞—î—Ç–µ—Å—å –∑–∞—Ä–∞–∑?",
        "triage_pain_q1":"–î–µ –±–æ–ª–∏—Ç—å?",
        "triage_pain_q1_opts":["–ì–æ–ª–æ–≤–∞","–ì–æ—Ä–ª–æ","–°–ø–∏–Ω–∞","–ñ–∏–≤—ñ—Ç","–Ü–Ω—à–µ"],
        "triage_pain_q2":"–Ø–∫–∏–π —Ö–∞—Ä–∞–∫—Ç–µ—Ä –±–æ–ª—é?",
        "triage_pain_q2_opts":["–¢—É–ø–∏–π","–ì–æ—Å—Ç—Ä–∏–π","–ü—É–ª—å—Å—É—é—á–∏–π","–¢–∏—Å–Ω—É—á–∏–π"],
        "triage_pain_q3":"–Ø–∫ –¥–æ–≤–≥–æ —Ç—Ä–∏–≤–∞—î?",
        "triage_pain_q3_opts":["<3–≥–æ–¥","3‚Äì24–≥–æ–¥",">1 –¥–Ω—è",">1 —Ç–∏–∂–Ω—è"],
        "triage_pain_q4":"–û—Ü—ñ–Ω—ñ—Ç—å –±—ñ–ª—å (0‚Äì10):",
        "triage_pain_q5":"–Ñ —â–æ—Å—å —ñ–∑ —Ü—å–æ–≥–æ –∑–∞—Ä–∞–∑?",
        "triage_pain_q5_opts":["–í–∏—Å–æ–∫–∞ —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞","–ë–ª—é–≤–∞–Ω–Ω—è","–°–ª–∞–±–∫—ñ—Å—Ç—å/–æ–Ω—ñ–º—ñ–Ω–Ω—è","–ü—Ä–æ–±–ª–µ–º–∏ –∑ –º–æ–≤–æ—é/–∑–æ—Ä–æ–º","–¢—Ä–∞–≤–º–∞","–ù–µ–º–∞—î"],
        "plan_header":"–í–∞—à –ø–ª–∞–Ω –Ω–∞ 24‚Äì48 –≥–æ–¥:",
        "plan_accept":"–ì–æ—Ç–æ–≤—ñ —Å–ø—Ä–æ–±—É–≤–∞—Ç–∏ —Å—å–æ–≥–æ–¥–Ω—ñ?",
        "remind_when":"–ö–æ–ª–∏ –Ω–∞–≥–∞–¥–∞—Ç–∏ —Ç–∞ —Å–ø–∏—Ç–∞—Ç–∏ —Å–∞–º–æ–ø–æ—á—É—Ç—Ç—è?",
        "accept_opts":["‚úÖ –¢–∞–∫","üîÅ –ü—ñ–∑–Ω—ñ—à–µ","‚úñÔ∏è –ù—ñ"],
        "remind_opts":["—á–µ—Ä–µ–∑ 4 –≥–æ–¥","—É–≤–µ—á–µ—Ä—ñ","–∑–∞–≤—Ç—Ä–∞ –≤—Ä–∞–Ω—Ü—ñ","–Ω–µ —Ç—Ä–µ–±–∞"],
        "thanks":"–ü—Ä–∏–π–Ω—è—Ç–æ üôå",
        "checkin_ping":"–ö–æ—Ä–æ—Ç–∫–æ: —è–∫ –∑–∞—Ä–∞–∑ –∑–∞ —à–∫–∞–ª–æ—é 0‚Äì10?",
        "checkin_better":"–ß—É–¥–æ–≤–æ! –ü—Ä–æ–¥–æ–≤–∂—É—î–º–æ üí™",
        "checkin_worse":"–Ø–∫—â–æ —î ¬´—á–µ—Ä–≤–æ–Ω—ñ –ø—Ä–∞–ø–æ—Ä—Ü—ñ¬ª –∞–±–æ –±—ñ–ª—å ‚â•7/10 ‚Äî –∫—Ä–∞—â–µ –∑–≤–µ—Ä–Ω—É—Ç–∏—Å—è –¥–æ –ª—ñ–∫–∞—Ä—è.",
        "act_rem_4h":"‚è∞ –ù–∞–≥–∞–¥–∞—Ç–∏ —á–µ—Ä–µ–∑ 4 –≥–æ–¥",
        "act_rem_eve":"‚è∞ –°—å–æ–≥–æ–¥–Ω—ñ –≤–≤–µ—á–µ—Ä—ñ",
        "act_rem_morn":"‚è∞ –ó–∞–≤—Ç—Ä–∞ –∑—Ä–∞–Ω–∫—É",
        "act_save_episode":"üíæ –ó–±–µ—Ä–µ–≥—Ç–∏ –µ–ø—ñ–∑–æ–¥",
        "act_ex_neck":"üßò 5-—Ö–≤ –≤–ø—Ä–∞–≤–∏ –¥–ª—è —à–∏—ó",
        "act_find_lab":"üß™ –ó–Ω–∞–π—Ç–∏ –ª–∞–±–æ—Ä–∞—Ç–æ—Ä—ñ—é",
        "act_er":"üöë –ö–æ–ª–∏ —Ç–µ—Ä–º—ñ–Ω–æ–≤–æ –≤ —à–≤–∏–¥–∫—É",
        "act_city_prompt":"–ù–∞–ø–∏—à—ñ—Ç—å –º—ñ—Å—Ç–æ/—Ä–∞–π–æ–Ω, —â–æ–± –ø–æ—Ä–∞–¥–∏—Ç–∏ –ª–∞–±–æ—Ä–∞—Ç–æ—Ä—ñ—é (—Ç–µ–∫—Å—Ç–æ–º).",
        "act_saved":"–ó–±–µ—Ä–µ–∂–µ–Ω–æ.",
        "er_text":"–Ø–∫—â–æ –ø–æ—Å–∏–ª—é—î—Ç—å—Å—è, —Å–∏–ª—å–Ω–∞ –∑–∞–¥–∏—à–∫–∞, –±—ñ–ª—å —É –≥—Ä—É–¥—è—Ö, —Å–ø–ª—É—Ç–∞–Ω—ñ—Å—Ç—å, —Ç—Ä–∏–≤–∞–ª–∞ –≤–∏—Å–æ–∫–∞ —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞ ‚Äî —è–∫–Ω–∞–π—à–≤–∏–¥—à–µ –¥–æ –Ω–µ–≤—ñ–¥–∫–ª–∞–¥–Ω–æ—ó/—à–≤–∏–¥–∫–æ—ó.",
        "px":"–ó —É—Ä–∞—Ö—É–≤–∞–Ω–Ω—è–º –ø—Ä–æ—Ñ—ñ–ª—é: {sex}, {age} —Ä.; –º–µ—Ç–∞ ‚Äî {goal}.",
        "back":"‚óÄ –ù–∞–∑–∞–¥",
        "exit":"–í–∏–π—Ç–∏",
        # feedback
        "ask_fb":"–ß–∏ –±—É–ª–æ —Ü–µ –∫–æ—Ä–∏—Å–Ω–æ?",
        "fb_thanks":"–î—è–∫—É—é –∑–∞ –≤—ñ–¥–≥—É–∫! ‚úÖ",
        "fb_write":"–ù–∞–ø–∏—à—ñ—Ç—å –∫–æ—Ä–æ—Ç–∫–∏–π –≤—ñ–¥–≥—É–∫ –æ–¥–Ω–∏–º –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è–º:",
        "fb_good":"üëç –ü–æ–¥–æ–±–∞—î—Ç—å—Å—è",
        "fb_bad":"üëé –ù–µ –∫–æ—Ä–∏—Å–Ω–æ",
        "fb_free":"üìù –í—ñ–¥–≥—É–∫",
        # Health60
        "h60_btn": "–ó–¥–æ—Ä–æ–≤‚Äô—è –∑–∞ 60 —Å–µ–∫—É–Ω–¥",
        "h60_intro": "–ö–æ—Ä–æ—Ç–∫–æ –Ω–∞–ø–∏—à—ñ—Ç—å, —â–æ —Ç—É—Ä–±—É—î (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥: ¬´–±–æ–ª–∏—Ç—å –≥–æ–ª–æ–≤–∞¬ª, ¬´–≤—Ç–æ–º–∞¬ª, ¬´–±—ñ–ª—å —É –∂–∏–≤–æ—Ç—ñ¬ª). –î–∞–º 3 –∫–ª—é—á–æ–≤—ñ –ø–æ—Ä–∞–¥–∏ –∑–∞ 60 —Å–µ–∫—É–Ω–¥.",
        "h60_t1": "–ú–æ–∂–ª–∏–≤—ñ –ø—Ä–∏—á–∏–Ω–∏",
        "h60_t2": "–©–æ –∑—Ä–æ–±–∏—Ç–∏ –∑–∞—Ä–∞–∑ (24‚Äì48 –≥–æ–¥)",
        "h60_t3": "–ö–æ–ª–∏ –∑–≤–µ—Ä–Ω—É—Ç–∏—Å—è –¥–æ –ª—ñ–∫–∞—Ä—è",
        "h60_serious": "–©–æ —Å–µ—Ä–π–æ–∑–Ω–µ –≤–∏–∫–ª—é—á–∏—Ç–∏",
        # Youth Pack
        "youth_pack": "–ú–æ–ª–æ–¥—ñ–∂–Ω–∏–π –ø–∞–∫–µ—Ç",
        "gm_energy": "‚ö° –ï–Ω–µ—Ä–≥—ñ—è",
        "gm_energy_q": "–Ø–∫ –µ–Ω–µ—Ä–≥—ñ—è (1‚Äì5)?",
        "gm_energy_done": "–ï–Ω–µ—Ä–≥—ñ—é –∑–∞–ø–∏—Å–∞–Ω–æ ‚Äî –¥—è–∫—É—é!",
        "gm_evening_btn": "‚è∞ –ù–∞–≥–∞–¥–∞—Ç–∏ –≤–≤–µ—á–µ—Ä—ñ",
        "hydrate_btn": "üíß –ì—ñ–¥—Ä–∞—Ç–∞—Ü—ñ—è",
        "hydrate_nudge": "üíß –ß–∞—Å –¥–ª—è —Å–∫–ª—è–Ω–∫–∏ –≤–æ–¥–∏",
        "skintip_btn": "üß¥ –ü–æ—Ä–∞–¥–∞ –¥–ª—è —à–∫—ñ—Ä–∏/—Ç—ñ–ª–∞",
        "skintip_sent": "–ü–æ—Ä–∞–¥—É –Ω–∞–¥—ñ—Å–ª–∞–Ω–æ.",
        "daily_tip_prefix": "üçé –ü—ñ–¥–∫–∞–∑–∫–∞ –¥–Ω—è:",
        "streak_day": "–î–µ–Ω—å —Ç—É—Ä–±–æ—Ç–∏",
        "challenge_btn": "üéØ –ß–µ–ª–µ–Ω–¥–∂ 7 –¥–Ω—ñ–≤ (–≤–æ–¥–∞)",
        "challenge_started": "–ß–µ–ª–µ–Ω–¥–∂ –∑–∞–ø—É—â–µ–Ω–æ! –Ø –≤—Ä–∞—Ö–æ–≤—É–≤–∞—Ç–∏–º—É –≤–∞—à—ñ —â–æ–¥–µ–Ω–Ω—ñ —á–µ–∫-—ñ–Ω–∏.",
        "challenge_progress": "–ü—Ä–æ–≥—Ä–µ—Å —á–µ–ª–µ–Ω–¥–∂—É: {d}/{len} –¥–Ω—ñ–≤.",
        "cycle_btn": "ü©∏ –¶–∏–∫–ª",
        "cycle_consent": "–ë–∞–∂–∞—î—Ç–µ –≤—ñ–¥—Å—Ç–µ–∂—É–≤–∞—Ç–∏ —Ü–∏–∫–ª –¥–ª—è –º‚Äô—è–∫–∏—Ö –ø–æ—Ä–∞–¥ —É –ø–æ—Ç—Ä—ñ–±–Ω—ñ –¥–Ω—ñ?",
        "cycle_ask_last": "–í–∫–∞–∂—ñ—Ç—å –¥–∞—Ç—É –æ—Å—Ç–∞–Ω–Ω—ñ—Ö –º–µ–Ω—Å—Ç—Ä—É–∞—Ü—ñ–π (–†–†–†–†-–ú–ú-–î–î):",
        "cycle_ask_len": "–°–µ—Ä–µ–¥–Ω—è —Ç—Ä–∏–≤–∞–ª—ñ—Å—Ç—å —Ü–∏–∫–ª—É (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥, 28):",
        "cycle_saved": "–í—ñ–¥—Å—Ç–µ–∂–µ–Ω–Ω—è —Ü–∏–∫–ª—É –∑–±–µ—Ä–µ–∂–µ–Ω–æ.",
        "quiet_saved": "–¢–∏—Ö—ñ –≥–æ–¥–∏–Ω–∏ –∑–±–µ—Ä–µ–∂–µ–Ω–æ: {qh}",
        "set_quiet_btn": "üåô –¢–∏—Ö—ñ –≥–æ–¥–∏–Ω–∏",
        "ask_quiet": "–í–≤–µ–¥—ñ—Ç—å —Ç–∏—Ö—ñ –≥–æ–¥–∏–Ω–∏ —è–∫ –ì–ì:–•–•-–ì–ì:–•–• (–ª–æ–∫–∞–ª—å–Ω–æ), –Ω–∞–ø—Ä. 22:00-08:00",
        "evening_intro": "–í–µ—á—ñ—Ä–Ω—ñ–π —á–µ–∫-—ñ–Ω:",
        "evening_tip_btn": "ü™Ñ –ü–æ—Ä–∞–¥–∞ –¥–Ω—è",
        "evening_set": "–í–µ—á—ñ—Ä–Ω—ñ–π —á–µ–∫-—ñ–Ω –≤—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ –Ω–∞ {t} (–ª–æ–∫–∞–ª—å–Ω–æ).",
        "evening_off": "–í–µ—á—ñ—Ä–Ω—ñ–π —á–µ–∫-—ñ–Ω –≤–∏–º–∫–Ω–µ–Ω–æ.",
        # Quickbar
        "quick_title":"–®–≤–∏–¥–∫—ñ –¥—ñ—ó",
        "quick_rem":"‚è∞ –ù–∞–≥–∞–¥—É–≤–∞–Ω–Ω—è",
    },
}
T["es"] = T["en"]  # –∑–∞–≥–ª—É—à–∫–∞


# --- Personalized prefix shown before LLM reply ---
def personalized_prefix(lang: str, profile: dict) -> str:
    sex = (profile.get("sex") or "").strip()
    goal = (profile.get("goal") or "").strip()
    age_raw = str(profile.get("age") or "")
    m = re.search(r"\d+", age_raw)
    age = m.group(0) if m else ""
    if sum(bool(x) for x in (sex, age, goal)) >= 2:
        tpl = (T.get(lang) or T["en"]).get("px", T["en"]["px"])
        return tpl.format(sex=sex or "‚Äî", age=age or "‚Äî", goal=goal or "‚Äî")
    return ""


# ---------------- Helpers ----------------
def utcnow():
    return datetime.now(timezone.utc)

def iso(dt: Optional[datetime]) -> str:
    return "" if not dt else dt.astimezone(timezone.utc).strftime("%Y-%m-%d %H:%M:%S%z")

def detect_lang_from_text(text: str, fallback: str) -> str:
    s = (text or "").strip()
    if not s:
        return fallback
    low = s.lower()
    if re.search(r"[–∞-—è—ë—ñ—ó—î“ë]", low):
        return "uk" if re.search(r"[—ñ—ó—î“ë]", low) else "ru"
    try:
        return norm_lang(detect(s))
    except Exception:
        return fallback

def profile_is_incomplete(profile_row: dict) -> bool:
    keys = ["sex","age","goal"]
    return sum(1 for k in keys if str(profile_row.get(k) or "").strip()) < 2

def age_to_band(age: int) -> str:
    if age <= 0: return "unknown"
    if age <= 25: return "18‚Äì25"
    if age <= 35: return "26‚Äì35"
    if age <= 45: return "36‚Äì45"
    if age <= 60: return "46‚Äì60"
    return "60+"


# ===== ONBOARDING GATE (–®—Ç–æ—Ä–∫–∞) =====
GATE_FLAG_KEY = "menu_unlocked"

def _is_menu_unlocked(update: Update, context: ContextTypes.DEFAULT_TYPE) -> bool:
    if context.user_data.get(GATE_FLAG_KEY):
        return True
    prof = profiles_get(update.effective_user.id) or {}
    return not profile_is_incomplete(prof)

async def gate_show(update: Update, context: ContextTypes.DEFAULT_TYPE):
    lang = context.user_data.get("lang", "en")
    kb = [
        [InlineKeyboardButton("üß© –ü—Ä–æ–π—Ç–∏ –æ–ø—Ä–æ—Å (40‚Äì60 —Å–µ–∫)" if lang!="en" else "üß© Take the 40‚Äì60s intake", callback_data="intake:start")],
        [InlineKeyboardButton("‚û°Ô∏è –ü–æ–∑–∂–µ ‚Äî –ø–æ–∫–∞–∑–∞—Ç—å –º–µ–Ω—é" if lang!="en" else "‚û°Ô∏è Later ‚Äî open menu", callback_data="gate:skip")],
    ]
    text = ("–ß—Ç–æ–±—ã —Å–æ–≤–µ—Ç—ã –±—ã–ª–∏ —Ç–æ—á–Ω–µ–µ, –ø—Ä–æ–π–¥–∏—Ç–µ –∫–æ—Ä–æ—Ç–∫–∏–π –æ–ø—Ä–æ—Å. –ú–æ–∂–Ω–æ –ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å –∏ —Å–¥–µ–ª–∞—Ç—å –ø–æ–∑–∂–µ."
            if lang!="en" else
            "To personalize answers, please take a short intake. You can skip and do it later.")
    await update.effective_chat.send_message(text, reply_markup=InlineKeyboardMarkup(kb))

async def gate_cb(update: Update, context: ContextTypes.DEFAULT_TYPE):
    q = update.callback_query
    await q.answer()
    if q.data == "gate:skip":
        context.user_data[GATE_FLAG_KEY] = True
        await q.edit_message_text("–û–∫, –æ—Ç–∫—Ä—ã–≤–∞—é –º–µ–Ω—é‚Ä¶" if context.user_data.get("lang","en")!="en" else "OK, opening the menu‚Ä¶")
        # –ø—Ä–æ—Å—Ç–æ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –º–µ–Ω—é
        lang = _user_lang(q.from_user.id)
        await context.bot.send_message(update.effective_chat.id, T[lang]["start_where"], reply_markup=inline_topic_kb(lang))


# === MINI-INTAKE (—Å –ø–µ—Ä–≤–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è) ===
MINI_KEYS = ["sex","age","goal","diet_focus","steps_target","conditions","meds_allergies","habits"]
MINI_FREE_KEYS: Set[str] = {"meds_allergies"}
MINI_STEPS = {
    "sex": {
        "ru":[("–ú—É–∂—Å–∫–æ–π","male"),("–ñ–µ–Ω—Å–∫–∏–π","female"),("–î—Ä—É–≥–æ–µ","other")],
        "en":[("Male","male"),("Female","female"),("Other","other")],
        "uk":[("–ß–æ–ª–æ–≤—ñ—á–∞","male"),("–ñ—ñ–Ω–æ—á–∞","female"),("–Ü–Ω—à–∞","other")],
        "es":[("Hombre","male"),("Mujer","female"),("Otro","other")],
        "label":{"ru":"–ü–æ–ª:","en":"Sex:","uk":"–°—Ç–∞—Ç—å:","es":"Sexo:"}
    },
    "age": {
        "ru":[("18‚Äì25","22"),("26‚Äì35","30"),("36‚Äì45","40"),("46‚Äì60","50"),("60+","65")],
        "en":[("18‚Äì25","22"),("26‚Äì35","30"),("36‚Äì45","40"),("46‚Äì60","50"),("60+","65")],
        "uk":[("18‚Äì25","22"),("26‚Äì35","30"),("36‚Äì45","40"),("46‚Äì60","50"),("60+","65")],
        "es":[("18‚Äì25","22"),("26‚Äì35","30"),("36‚Äì45","40"),("46‚Äì60","50"),("60+","65")],
        "label":{"ru":"–í–æ–∑—Ä–∞—Å—Ç:","en":"Age:","uk":"–í—ñ–∫:","es":"Edad:"}
    },
    "goal": {
        "ru":[("–≠–Ω–µ—Ä–≥–∏—è","energy"),("–°–æ–Ω","sleep"),("–ü–æ—Ö—É–¥–µ–Ω–∏–µ","weight"),("–°–∏–ª–∞","strength"),("–î–æ–ª–≥–æ–ª–µ—Ç–∏–µ","longevity")],
        "en":[("Energy","energy"),("Sleep","sleep"),("Weight","weight"),("Strength","strength"),("Longevity","longevity")],
        "uk":[("–ï–Ω–µ—Ä–≥—ñ—è","energy"),("–°–æ–Ω","sleep"),("–í–∞–≥–∞","weight"),("–°–∏–ª–∞","strength"),("–î–æ–≤–≥–æ–ª—ñ—Ç—Ç—è","longevity")],
        "es":[("Energ√≠a","energy"),("Sue√±o","sleep"),("Peso","weight"),("Fuerza","strength"),("Longevidad","longevity")],
        "label":{"ru":"–¶–µ–ª—å:","en":"Main goal:","uk":"–ú–µ—Ç–∞:","es":"Objetivo:"}
    },
    "diet_focus": {
        "ru":[("–°–±–∞–ª–∞–Ω—Å.","balanced"),("–ù–∏–∑–∫–æ—É–≥–ª","lowcarb"),("–†–∞—Å—Ç–∏—Ç.","plant"),("–ù–µ—Ä–µ–≥—É–ª.","irregular")],
        "en":[("Balanced","balanced"),("Low-carb","lowcarb"),("Plant-based","plant"),("Irregular","irregular")],
        "uk":[("–ó–±–∞–ª–∞–Ω—Å.","balanced"),("–ú–∞–ª–æ–≤—É–≥–ª.","lowcarb"),("–†–æ—Å–ª–∏–Ω–Ω–µ","plant"),("–ù–µ—Ä–µ–≥—É–ª.","irregular")],
        "es":[("Equilibrada","balanced"),("Baja carb.","lowcarb"),("Vegetal","plant"),("Irregular","irregular")],
        "label":{"ru":"–ü–∏—Ç–∞–Ω–∏–µ:","en":"Diet mostly:","uk":"–•–∞—Ä—á—É–≤–∞–Ω–Ω—è:","es":"Dieta:"}
    },
    "steps_target": {
        "ru":[("<5–∫","5000"),("5‚Äì8–∫","8000"),("8‚Äì12–∫","12000"),("–°–ø–æ—Ä—Ç","15000")],
        "en":[("<5k","5000"),("5‚Äì8k","8000"),("8‚Äì12k","12000"),("Sport","15000")],
        "uk":[("<5–∫","5000"),("5‚Äì8–∫","8000"),("8‚Äì12–∫","12000"),("–°–ø–æ—Ä—Ç","15000")],
        "es":[("<5k","5000"),("5‚Äì8k","8000"),("8‚Äì12k","12000"),("Deporte","15000")],
        "label":{"ru":"–®–∞–≥–∏/–∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å:","en":"Steps/activity:","uk":"–ö—Ä–æ–∫–∏/–∞–∫—Ç–∏–≤–Ω—ñ—Å—Ç—å:","es":"Pasos/actividad:"}
    },
    "conditions": {
        "ru":[("–ù–µ—Ç","none"),("–°–µ—Ä–¥–µ—á–Ω–æ-—Å–æ—Å—É–¥.","cvd"),("–©–ñ/—ç–Ω–¥–æ–∫—Ä.","endocrine"),("–ñ–ö–¢","gi"),("–ê–ª–ª–µ—Ä–≥–∏—è","allergy"),("–î—Ä—É–≥–æ–µ","other")],
        "en":[("None","none"),("Cardio/vascular","cvd"),("Thyroid/endocrine","endocrine"),("GI","gi"),("Allergy","allergy"),("Other","other")],
        "uk":[("–ù–µ–º–∞—î","none"),("–°–µ—Ä—Ü–µ–≤–æ-—Å—É–¥.","cvd"),("–©–ó/–µ–Ω–¥–æ–∫—Ä.","endocrine"),("–®–ö–¢","gi"),("–ê–ª–µ—Ä–≥—ñ—è","allergy"),("–Ü–Ω—à–µ","other")],
        "es":[("Ninguno","none"),("Cardio/vascular","cvd"),("Tiroides/end√≥cr.","endocrine"),("GI","gi"),("Alergia","allergy"),("Otro","other")],
        "label":{"ru":"–•—Ä–æ–Ω–∏—á–µ—Å–∫–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è:","en":"Chronic conditions:","uk":"–•—Ä–æ–Ω—ñ—á–Ω—ñ —Å—Ç–∞–Ω–∏:","es":"Condiciones cr√≥nicas:"}
    },
    "meds_allergies": {
        "ru":[], "en":[], "uk":[], "es":[],
        "label":{"ru":"–õ–µ–∫–∞—Ä—Å—Ç–≤–∞/–¥–æ–±–∞–≤–∫–∏/–∞–ª–ª–µ—Ä–≥–∏–∏ (–∫–æ—Ä–æ—Ç–∫–æ):","en":"Meds/supplements/allergies (short):","uk":"–õ—ñ–∫–∏/–¥–æ–±–∞–≤–∫–∏/–∞–ª–µ—Ä–≥—ñ—ó (–∫–æ—Ä–æ—Ç–∫–æ):","es":"Medicamentos/suplementos/alergias (corto):"}
    },
    "habits": {
        "ru":[("–ù–µ –∫—É—Ä—é","no_smoke"),("–ö—É—Ä—é","smoke"),("–ê–ª–∫–æ–≥–æ–ª—å —Ä–µ–¥–∫–æ","alc_low"),("–ê–ª–∫–æ–≥–æ–ª—å —á–∞—Å—Ç–æ","alc_high"),("–ö–æ—Ñ–µ–∏–Ω 0‚Äì1","caf_low"),("–ö–æ—Ñ–µ–∏–Ω 2‚Äì3","caf_mid"),("–ö–æ—Ñ–µ–∏–Ω 4+","caf_high")],
        "en":[("No smoking","no_smoke"),("Smoking","smoke"),("Alcohol rare","alc_low"),("Alcohol often","alc_high"),("Caffeine 0‚Äì1","caf_low"),("Caffeine 2‚Äì3","caf_mid"),("Caffeine 4+","caf_high")],
        "uk":[("–ù–µ –∫—É—Ä—é","no_smoke"),("–ö—É—Ä—é","smoke"),("–ê–ª–∫–æ–≥–æ–ª—å —Ä—ñ–¥–∫–æ","alc_low"),("–ê–ª–∫–æ–≥–æ–ª—å —á–∞—Å—Ç–æ","alc_high"),("–ö–æ—Ñ–µ—ó–Ω 0‚Äì1","caf_low"),("–ö–æ—Ñ–µ—ó–Ω 2‚Äì3","caf_mid"),("–ö–æ—Ñ–µ—ó–Ω 4+","caf_high")],
        "es":[("No fuma","no_smoke"),("Fuma","smoke"),("Alcohol raro","alc_low"),("Alcohol a menudo","alc_high"),("Cafe√≠na 0‚Äì1","caf_low"),("Cafe√≠na 2‚Äì3","caf_mid"),("Cafe√≠na 4+","caf_high")],
        "label":{"ru":"–ü—Ä–∏–≤—ã—á–∫–∏ (–≤—ã–±–µ—Ä–∏—Ç–µ –±–ª–∏–∂–µ –≤—Å–µ–≥–æ):","en":"Habits (pick closest):","uk":"–ó–≤–∏—á–∫–∏ (–æ–±–µ—Ä—ñ—Ç—å –±–ª–∏–∂—á–µ):","es":"H√°bitos (elige):"}
    },
}

async def start_mini_intake(context: ContextTypes.DEFAULT_TYPE, chat_id: int, lang: str, uid: int):
    sessions[uid] = {"mini_active": True, "mini_step": 0, "mini_answers": {}}
    await context.bot.send_message(chat_id, {
        "ru":"üîé –ú–∏–Ω–∏-–æ–ø—Ä–æ—Å –¥–ª—è –ø–µ—Ä—Å–æ–Ω–∞–ª–∏–∑–∞—Ü–∏–∏ (4‚Äì6 –∫–ª–∏–∫–æ–≤).",
        "uk":"üîé –ú—ñ–Ω—ñ-–æ–ø–∏—Ç—É–≤–∞–Ω–Ω—è –¥–ª—è –ø–µ—Ä—Å–æ–Ω–∞–ª—ñ–∑–∞—Ü—ñ—ó (4‚Äì6 –∫–ª—ñ–∫—ñ–≤).",
        "en":"üîé Mini-intake for personalization (4‚Äì6 taps).",
        "es":"üîé Mini-intake para personalizaci√≥n (4‚Äì6 toques).",
    }[lang], reply_markup=ReplyKeyboardRemove())
    await ask_next_mini(context, chat_id, lang, uid)

def build_mini_kb(lang: str, key: str) -> InlineKeyboardMarkup:
    opts = MINI_STEPS[key].get(lang, [])
    rows, row = [], []
    for label, val in opts:
        row.append(InlineKeyboardButton(label, callback_data=f"mini|choose|{key}|{val}"))
        if len(row) == 3:
            rows.append(row); row=[]
    if row: rows.append(row)
    if key in MINI_FREE_KEYS or (not opts):
        rows.append([InlineKeyboardButton(T[lang]["write"], callback_data=f"mini|write|{key}")])
    rows.append([InlineKeyboardButton(T[lang]["skip"], callback_data=f"mini|skip|{key}")])
    return InlineKeyboardMarkup(rows)

async def ask_next_mini(context: ContextTypes.DEFAULT_TYPE, chat_id: int, lang: str, uid: int):
    s = sessions.get(uid, {})
    step_idx = s.get("mini_step", 0)
    if step_idx >= len(MINI_KEYS):
        answers = s.get("mini_answers", {})
        if answers.get("meds_allergies"):
            profiles_upsert(uid, {"meds":answers["meds_allergies"], "allergies":answers["meds_allergies"]})
        profiles_upsert(uid, answers)
        sessions[uid]["mini_active"] = False
        await context.bot.send_message(chat_id, T[lang]["start_where"], reply_markup=inline_topic_kb(lang))
        # –ø–æ–∫–∞–∑–∞—Ç—å –ø–æ—Å—Ç–æ—è–Ω–Ω—ã–µ –±—ã—Å—Ç—Ä—ã–µ –∫–Ω–æ–ø–∫–∏
        await show_quickbar(context, chat_id, lang)
        return
    key = MINI_KEYS[step_idx]
    label = MINI_STEPS[key]["label"][lang]
    await context.bot.send_message(chat_id, label, reply_markup=build_mini_kb(lang, key))

def mini_handle_choice(uid: int, key: str, value: str):
    s = sessions.setdefault(uid, {"mini_active": True, "mini_step": 0, "mini_answers": {}})
    s["mini_answers"][key] = value
    s["mini_step"] = int(s.get("mini_step", 0)) + 1


# ---------- Anti-duplicate questions ----------
def _ratio(a: str, b: str) -> float:
    return SequenceMatcher(None, (a or "").lower(), (b or "").lower()).ratio()

def is_duplicate_question(uid: int, text: str, thresh: float = 0.93) -> bool:
    s = sessions.setdefault(uid, {})
    asked = s.setdefault("asked_prompts", [])
    for prev in asked[-4:]:
        if _ratio(prev, text) >= thresh:
            return True
    asked.append(text)
    if len(asked) > 16:
        s["asked_prompts"] = asked[-16:]
    return False

async def send_unique(msg_obj, uid: int, text: str, reply_markup=None, force: bool = False):
    if force or not is_duplicate_question(uid, text):
        await msg_obj.reply_text(text, reply_markup=reply_markup)


# -------- Sheets (with memory fallback) --------
SHEETS_ENABLED = True
ss = None
ws_feedback = ws_users = ws_profiles = ws_episodes = ws_reminders = ws_daily = None
ws_rules = ws_challenges = None

GSPREAD_CLIENT: Optional[gspread.client.Client] = None
SPREADSHEET_ID_FOR_INTAKE: str = ""

def _ws_headers(ws):
    return ws.row_values(1) if ws and ws.row_values(1) else []

def _ws_ensure_columns(ws, desired_headers: List[str]):
    """
    –ù–∞–¥—ë–∂–Ω–æ–µ –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ –Ω–µ–¥–æ—Å—Ç–∞—é—â–∏—Ö –∑–∞–≥–æ–ª–æ–≤–∫–æ–≤ + –∞–≤—Ç–æ—Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ –ª–∏—Å—Ç–∞.
    """
    try:
        current = _ws_headers(ws)
        # –µ—Å–ª–∏ –ª–∏—Å—Ç –ø—É—Å—Ç ‚Äî —Å–Ω–∞—á–∞–ª–∞ –æ–±–µ—Å–ø–µ—á–∏–º –Ω—É–∂–Ω–æ–µ —á–∏—Å–ª–æ –∫–æ–ª–æ–Ω–æ–∫
        if not current:
            if ws.col_count < len(desired_headers):
                ws.add_cols(len(desired_headers) - ws.col_count)
            ws.append_row(desired_headers)
            return
        # –µ—Å–ª–∏ –Ω–µ —Ö–≤–∞—Ç–∞–µ—Ç –∫–æ–ª–æ–Ω–æ–∫ ‚Äî —Ä–∞—Å—à–∏—Ä—è–µ–º —Å–µ—Ç–∫—É
        if ws.col_count < len(desired_headers):
            ws.add_cols(len(desired_headers) - ws.col_count)
        # –¥–æ–ø–∏—Å—ã–≤–∞–µ–º –Ω–µ–¥–æ—Å—Ç–∞—é—â–∏–µ –∑–∞–≥–æ–ª–æ–≤–∫–∏ —Å–ø—Ä–∞–≤–∞
        missing = [h for h in desired_headers if h not in current]
        if missing:
            for h in missing:
                ws.update_cell(1, len(current)+1, h)
                current.append(h)
    except Exception as e:
        logging.warning(f"ensure columns failed for {getattr(ws,'title','?')}: {e}")

def _sheets_init():
    global SHEETS_ENABLED, ss, ws_feedback, ws_users, ws_profiles, ws_episodes, ws_reminders, ws_daily, ws_rules, ws_challenges
    global GSPREAD_CLIENT, SPREADSHEET_ID_FOR_INTAKE
    try:
        scope = ["https://spreadsheets.google.com/feeds", "https://www.googleapis.com/auth/drive"]
        creds_json = os.getenv("GOOGLE_CREDENTIALS_JSON")
        if not creds_json:
            raise RuntimeError("GOOGLE_CREDENTIALS_JSON is not set")
        creds = json.loads(creds_json)
        credentials = ServiceAccountCredentials.from_json_keyfile_dict(creds, scope)
        gclient = gspread.authorize(credentials)
        GSPREAD_CLIENT = gclient

        try:
            ss = gclient.open_by_key(SHEET_ID) if SHEET_ID else gclient.open(SHEET_NAME)
        except SpreadsheetNotFound:
            if ALLOW_CREATE_SHEET:
                ss = gclient.create(SHEET_NAME)
            else:
                raise

        try:
            SPREADSHEET_ID_FOR_INTAKE = ss.id
        except Exception:
            SPREADSHEET_ID_FOR_INTAKE = SHEET_ID or ""

        def _ensure_ws(title: str, headers: List[str]):
            try:
                ws = ss.worksheet(title)
            except gspread.WorksheetNotFound:
                # —Å–æ–∑–¥–∞—ë–º —Å –±–æ–ª—å—à–∏–º –∑–∞–ø–∞—Å–æ–º –∫–æ–ª–æ–Ω–æ–∫
                ws = ss.add_worksheet(title=title, rows=4000, cols=max(50, len(headers)))
                ws.append_row(headers)
            if not ws.get_all_values():
                ws.append_row(headers)
            _ws_ensure_columns(ws, headers)
            return ws

        ws_feedback   = _ensure_ws("Feedback",   ["timestamp","user_id","name","username","rating","comment"])
        ws_users      = _ensure_ws("Users",      ["user_id","username","lang","consent","tz_offset","checkin_hour","evening_hour","paused","last_seen","last_auto_date","last_auto_count"])
        ws_profiles   = _ensure_ws("Profiles",   [
            "user_id","sex","age","goal","goals","conditions","meds","allergies",
            "sleep","activity","diet","diet_focus","steps_target","habits",
            "cycle_enabled","cycle_last_date","cycle_avg_len","last_cycle_tip_date",
            "quiet_hours","consent_flags","notes","updated_at","city"
        ])
        ws_episodes   = _ensure_ws("Episodes",   ["episode_id","user_id","topic","started_at","baseline_severity","red_flags","plan_accepted","target","reminder_at","next_checkin_at","status","last_update","notes"])
        ws_daily      = _ensure_ws("DailyCheckins",["timestamp","user_id","mood","energy","comment"])
        ws_rules      = _ensure_ws("Rules",      ["rule_id","topic","segment","trigger","advice_text","citation","last_updated","enabled"])
        ws_challenges = _ensure_ws("Challenges", ["user_id","challenge_id","name","start_date","length_days","days_done","status"])
        ws_reminders  = _ensure_ws("Reminders",  ["id","user_id","text","when_utc","created_at","status"])

        logging.info("Google Sheets connected.")
    except Exception as e:
        SHEETS_ENABLED = False
        logging.error(f"SHEETS disabled (fallback to memory). Reason: {e}")

_sheets_init()

# --------- Memory fallback stores ----------
MEM_USERS: Dict[int, dict] = {}
MEM_PROFILES: Dict[int, dict] = {}
MEM_EPISODES: List[dict] = []
MEM_REMINDERS: List[dict] = []
MEM_FEEDBACK: List[dict] = []
MEM_DAILY: List[dict] = []
MEM_CHALLENGES: List[dict] = []
MEM_RULES: List[dict] = []

# --------- Sessions ----------
sessions: Dict[int, dict] = {}

# -------- Sheets wrappers --------
def _headers(ws):
    return ws.row_values(1)

def users_get(uid: int) -> dict:
    if SHEETS_ENABLED:
        for r in ws_users.get_all_records():
            if str(r.get("user_id")) == str(uid):
                return r
        return {}
    return MEM_USERS.get(uid, {})

def users_upsert(uid: int, username: str, lang: str):
    base = {
        "user_id": str(uid),
        "username": username or "",
        "lang": lang,
        "consent": "no",
        "tz_offset": "0",
        "checkin_hour": DEFAULT_CHECKIN_LOCAL,
        "evening_hour": "",
        "paused": "no",
        "last_seen": iso(utcnow()),
        "last_auto_date": "",
        "last_auto_count": "0",
    }

    if SHEETS_ENABLED:
        vals = ws_users.get_all_records()
        hdr = _headers(ws_users)
        end_col = gsu.rowcol_to_a1(1, len(hdr)).rstrip("1")
        for i, r in enumerate(vals, start=2):
            if str(r.get("user_id")) == str(uid):
                merged = {**r, **{k: base[k] for k in base if not str(r.get(k) or "").strip()}}
                ws_users.update(f"A{i}:{end_col}{i}", [[merged.get(h, "") for h in hdr]])
                return
        ws_users.append_row([base.get(h, "") for h in hdr])
    else:
        MEM_USERS[uid] = {**MEM_USERS.get(uid, {}), **base}

def users_set(uid: int, field: str, value: str):
    if SHEETS_ENABLED:
        vals = ws_users.get_all_records()
        for i, r in enumerate(vals, start=2):
            if str(r.get("user_id")) == str(uid):
                hdr = _headers(ws_users)
                if field not in hdr:
                    _ws_ensure_columns(ws_users, hdr + [field])
                    hdr = _headers(ws_users)
                ws_users.update_cell(i, hdr.index(field)+1, value)
                return
    else:
        u = MEM_USERS.setdefault(uid, {})
        u[field] = value

def profiles_get(uid: int) -> dict:
    if SHEETS_ENABLED:
        for r in ws_profiles.get_all_records():
            if str(r.get("user_id")) == str(uid):
                return r
        return {}
    return MEM_PROFILES.get(uid, {}
# ------------- LLM Router (with personalization) -------------
SYS_ROUTER = (
    "You are TendAI ‚Äî a concise, warm, professional health & longevity assistant (not a doctor). "
    "Always answer strictly in {lang}. Keep replies short (<=6 lines + up to 4 bullets). "
    "Personalize recommendations using the provided profile (sex/age/goal/conditions, diet_focus, steps_target). "
    "TRIAGE: ask 1‚Äì2 clarifiers first; advise ER only for clear red flags with high confidence. "
    "Return JSON ONLY like: "
    "{\"intent\":\"symptom\"|\"nutrition\"|\"sleep\"|\"labs\"|\"habits\"|\"longevity\"|\"other\","
    "\"assistant_reply\": \"string\", \"followups\": [\"string\"], \"needs_more\": true, "
    "\"red_flags\": false, \"confidence\": 0.0}"
)

def llm_router_answer(text: str, lang: str, profile: dict) -> dict:
    if not oai:
        return {"intent":"other","assistant_reply":T[lang]["unknown"],"followups":[],"needs_more":True,"red_flags":False,"confidence":0.3}

    sys = SYS_ROUTER.replace("{lang}", lang) + f"\nUserProfile: {json.dumps(profile, ensure_ascii=False)}"
    try:
        resp = oai.chat.completions.create(
            model=OPENAI_MODEL,
            temperature=0.25,
            max_tokens=420,
            response_format={"type":"json_object"},
            messages=[
                {"role":"system","content":sys},
                {"role":"user","content":text}
            ]
        )
        out = resp.choices[0].message.content.strip()
        data = json.loads(out)
        if "followups" not in data or data["followups"] is None:
            data["followups"] = []
        return data
    except Exception as e:
        logging.error(f"router LLM error: {e}")
        return {"intent":"other","assistant_reply":T[lang]["unknown"],"followups":[],"needs_more":True,"red_flags":False,"confidence":0.3}


# ===== Health60 =====
def _fmt_bullets(items: list) -> str:
    return "\n".join([f"‚Ä¢ {x}" for x in items if isinstance(x, str) and x.strip()])

SYS_H60 = (
    "You are TendAI ‚Äî a concise, warm, professional health & longevity assistant (not a doctor). "
    "Always answer strictly in {lang}. Keep it short and practical. "
    "Given a symptom text and a brief user profile, produce a compact JSON ONLY with keys: "
    "{\"causes\": [\"...\"], \"serious\": \"...\", \"do_now\": [\"...\"], \"see_doctor\": [\"...\"]}. "
    "Rules: 2‚Äì4 simple causes, exactly 1 serious item to rule out, "
    "3‚Äì5 do_now concrete steps for the next 24‚Äì48h, 2‚Äì3 see_doctor cues. "
    "No extra keys, no prose outside JSON."
)

def health60_make_plan(lang: str, symptom_text: str, profile: dict) -> str:
    fallback_map = {
        "ru": (
            f"{T['ru']['h60_t1']}:\n‚Ä¢ –ù–∞–∏–±–æ–ª–µ–µ –≤–µ—Ä–æ—è—Ç–Ω—ã–µ –±—ã—Ç–æ–≤—ã–µ –ø—Ä–∏—á–∏–Ω—ã\n"
            f"{T['ru']['h60_serious']}: ‚Ä¢ –ò—Å–∫–ª—é—á–∏—Ç—å —Ä–µ–¥–∫–∏–µ, –Ω–æ —Å–µ—Ä—å—ë–∑–Ω—ã–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è –ø—Ä–∏ —É—Ö—É–¥—à–µ–Ω–∏–∏\n\n"
            f"{T['ru']['h60_t2']}:\n‚Ä¢ –í–æ–¥–∞ 300‚Äì500 –º–ª\n‚Ä¢ –ö–æ—Ä–æ—Ç–∫–∏–π –æ—Ç–¥—ã—Ö 15‚Äì20 –º–∏–Ω\n‚Ä¢ –ü—Ä–æ–≤–µ—Ç—Ä–∏–≤–∞–Ω–∏–µ, –º–µ–Ω—å—à–µ —ç–∫—Ä–∞–Ω–æ–≤\n\n"
            f"{T['ru']['h60_t3']}:\n‚Ä¢ –£—Å–∏–ª–µ–Ω–∏–µ —Å–∏–º–ø—Ç–æ–º–æ–≤\n‚Ä¢ –í—ã—Å–æ–∫–∞—è —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞/¬´–∫—Ä–∞—Å–Ω—ã–µ —Ñ–ª–∞–≥–∏¬ª\n‚Ä¢ –ë–æ–ª—å ‚â•7/10"
        ),
        "uk": (
            f"{T['uk']['h60_t1']}:\n‚Ä¢ –ù–∞–π—ñ–º–æ–≤—ñ—Ä–Ω—ñ –ø–æ–±—É—Ç–æ–≤—ñ –ø—Ä–∏—á–∏–Ω–∏\n"
            f"{T['uk']['h60_serious']}: ‚Ä¢ –í–∏–∫–ª—é—á–∏—Ç–∏ —Ä—ñ–¥–∫—ñ—Å–Ω—ñ, –∞–ª–µ —Å–µ—Ä–π–æ–∑–Ω—ñ —Å—Ç–∞–Ω–∏ –ø—Ä–∏ –ø–æ–≥—ñ—Ä—à–µ–Ω–Ω—ñ\n\n"
            f"{T['uk']['h60_t2']}:\n‚Ä¢ –í–æ–¥–∞ 300‚Äì500 –º–ª\n‚Ä¢ –í—ñ–¥–ø–æ—á–∏–Ω–æ–∫ 15‚Äì20 —Ö–≤\n‚Ä¢ –ü—Ä–æ–≤—ñ—Ç—Ä—é–≤–∞–Ω–Ω—è, –º–µ–Ω—à–µ –µ–∫—Ä–∞–Ω—ñ–≤\n\n"
            f"{T['uk']['h60_t3']}:\n‚Ä¢ –ü–æ—Å–∏–ª–µ–Ω–Ω—è —Å–∏–º–ø—Ç–æ–º—ñ–≤\n‚Ä¢ –í–∏—Å–æ–∫–∞ —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞/¬´—á–µ—Ä–≤–æ–Ω—ñ –ø—Ä–∞–ø–æ—Ä—Ü—ñ¬ª\n‚Ä¢ –ë—ñ–ª—å ‚â•7/10"
        ),
        "en": (
            f"{T['en']['h60_t1']}:\n‚Ä¢ Most likely everyday causes\n"
            f"{T['en']['h60_serious']}: ‚Ä¢ Rule out rare but serious issues if worsening\n\n"
            f"{T['en']['h60_t2']}:\n‚Ä¢ Drink 300‚Äì500 ml water\n‚Ä¢ 15‚Äì20 min rest\n‚Ä¢ Ventilate, reduce screens\n\n"
            f"{T['en']['h60_t3']}:\n‚Ä¢ Worsening symptoms\n‚Ä¢ High fever/red flags\n‚Ä¢ Pain ‚â•7/10"
        ),
    }
    fallback = fallback_map.get(lang, fallback_map["en"])

    if not oai:
        return fallback

    sys = SYS_H60.replace("{lang}", lang)
    user = {
        "symptom": (symptom_text or "").strip()[:500],
        "profile": {k: profile.get(k, "") for k in ["sex","age","goal","conditions","meds","sleep","activity","diet","diet_focus","steps_target"]}
    }
    try:
        resp = oai.chat.completions.create(
            model=OPENAI_MODEL,
            temperature=0.2,
            max_tokens=420,
            response_format={"type": "json_object"},
            messages=[
                {"role":"system","content": sys},
                {"role":"user","content": json.dumps(user, ensure_ascii=False)}
            ]
        )
        data = json.loads(resp.choices[0].message.content.strip())
        causes = _fmt_bullets(data.get("causes") or [])
        serious = (data.get("serious") or "").strip()
        do_now = _fmt_bullets(data.get("do_now") or [])
        see_doc = _fmt_bullets(data.get("see_doctor") or [])

        parts = []
        if causes:
            parts.append(f"{T[lang]['h60_t1']}:\n{causes}")
        if serious:
            parts.append(f"{T[lang]['h60_serious']}: {serious}")
        if do_now:
            parts.append(f"\n{T[lang]['h60_t2']}:\n{do_now}")
        if see_doc:
            parts.append(f"\n{T[lang]['h60_t3']}:\n{see_doc}")
        return "\n".join(parts).strip()
    except Exception as e:
        logging.error(f"health60 LLM error: {e}")
        return fallback


# ------------- Commands -------------
async def post_init(app):
    me = await app.bot.get_me()
    logging.info(f"BOT READY: @{me.username} (id={me.id})")
    try:
        schedule_from_sheet_on_start(app)
    except Exception as e:
        logging.warning(f"schedule_from_sheet_on_start failed: {e}")

async def cmd_start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    lang = norm_lang(getattr(user, "language_code", None))
    users_upsert(user.id, user.username or "", lang)
    context.user_data["lang"] = lang
    sessions.setdefault(user.id, {})["last_user_text"] = "/start"
    update_last_seen(user.id)

    await update.message.reply_text(T[lang]["welcome"], reply_markup=ReplyKeyboardRemove())

    prof = profiles_get(user.id)
    if profile_is_incomplete(prof):
        await start_mini_intake(context, update.effective_chat.id, lang, user.id)
    else:
        await update.message.reply_text(T[lang]["start_where"], reply_markup=inline_topic_kb(lang))

    u = users_get(user.id)
    if (u.get("consent") or "").lower() not in {"yes","no"}:
        kb = InlineKeyboardMarkup([[InlineKeyboardButton(T[lang]["yes"], callback_data="consent|yes"),
                                    InlineKeyboardButton(T[lang]["no"], callback_data="consent|no")]])
        await update.message.reply_text(T[lang]["ask_consent"], reply_markup=kb)

    tz_off = int(str(u.get("tz_offset") or "0"))
    hhmm = (u.get("checkin_hour") or DEFAULT_CHECKIN_LOCAL)
    if _has_jq_ctx(context):
        schedule_daily_checkin(context.application, user.id, tz_off, hhmm, lang)
        eh = (u.get("evening_hour") or "").strip()
        if eh:
            schedule_evening_checkin(context.application, user.id, tz_off, eh, lang)
    else:
        logging.warning("JobQueue not available on /start ‚Äì daily/evening check-in not scheduled.")

async def cmd_help(update: Update, context: ContextTypes.DEFAULT_TYPE):
    lang = norm_lang(users_get(update.effective_user.id).get("lang") or "en")
    update_last_seen(update.effective_user.id)
    await update.message.reply_text(T[lang]["help"])

async def cmd_privacy(update: Update, context: ContextTypes.DEFAULT_TYPE):
    lang = norm_lang(users_get(update.effective_user.id).get("lang") or "en")
    update_last_seen(update.effective_user.id)
    await update.message.reply_text(T[lang]["privacy"])

async def cmd_pause(update: Update, context: ContextTypes.DEFAULT_TYPE):
    uid = update.effective_user.id; users_set(uid, "paused", "yes")
    lang = norm_lang(users_get(uid).get("lang") or "en")
    update_last_seen(uid)
    await update.message.reply_text(T[lang]["paused_on"])

async def cmd_resume(update: Update, context: ContextTypes.DEFAULT_TYPE):
    uid = update.effective_user.id; users_set(uid, "paused", "no")
    lang = norm_lang(users_get(uid).get("lang") or "en")
    update_last_seen(uid)
    await update.message.reply_text(T[lang]["paused_off"])

async def cmd_delete_data(update: Update, context: ContextTypes.DEFAULT_TYPE):
    uid = update.effective_user.id
    update_last_seen(uid)
    if SHEETS_ENABLED:
        vals = ws_users.get_all_values()
        for i in range(2, len(vals)+1):
            if ws_users.cell(i,1).value == str(uid):
                ws_users.delete_rows(i); break
        try:
            vals = ws_profiles.get_all_values()
            idxs = []
            for i in range(2, len(vals)+1):
                if ws_profiles.cell(i,1).value == str(uid):
                    idxs.append(i)
            for shift, i in enumerate(idxs):
                ws_profiles.delete_rows(i - shift)
        except Exception:
            pass
    else:
        MEM_USERS.pop(uid, None); MEM_PROFILES.pop(uid, None)
        global MEM_EPISODES, MEM_REMINDERS, MEM_DAILY
        MEM_EPISODES = [r for r in MEM_EPISODES if r["user_id"]!=str(uid)]
        MEM_REMINDERS = [r for r in MEM_REMINDERS if r["user_id"]!=str(uid)]
        MEM_DAILY = [r for r in MEM_DAILY if r["user_id"]!=str(uid)]
    lang = norm_lang(getattr(update.effective_user,"language_code",None))
    await update.message.reply_text(T[lang]["deleted"], reply_markup=ReplyKeyboardRemove())


# ---------- Helpers for daily/evening ----------
def _schedule_oneoff_with_sheet(context: ContextTypes.DEFAULT_TYPE, uid: int, when_local: datetime, text: str):
    qh = _user_quiet_hours(uid)
    adjusted_local = adjust_out_of_quiet(when_local, qh)
    when_utc = local_to_utc_dt(uid, adjusted_local)
    rid = reminder_add(uid, text, when_utc)
    if _has_jq_ctx(context):
        delay = max(60, (when_utc - utcnow()).total_seconds())
        try:
            context.application.job_queue.run_once(job_oneoff_reminder, when=delay, data={"user_id":uid,"reminder_id":rid})
        except Exception as e:
            logging.error(f"run_once failed: {e}")
    return adjusted_local

def _format_hhmm(dt: datetime) -> str:
    return dt.strftime("%H:%M")


# ---------- Daily Check-in job ----------
async def job_daily_checkin(context: ContextTypes.DEFAULT_TYPE):
    d = context.job.data or {}
    uid = d.get("user_id"); lang = norm_lang((d.get("lang") or "en"))
    if not uid:
        return
    u = users_get(uid)
    if (u.get("paused") or "").lower() == "yes":
        return

    kb = InlineKeyboardMarkup([
        [InlineKeyboardButton(T[lang]["mood_good"], callback_data="gm|mood|good"),
         InlineKeyboardButton(T[lang]["mood_ok"],   callback_data="gm|mood|ok"),
         InlineKeyboardButton(T[lang]["mood_bad"],  callback_data="gm|mood|bad")],
        [InlineKeyboardButton(T[lang]["mood_note"], callback_data="gm|note")],
        [InlineKeyboardButton(T[lang]["gm_evening_btn"], callback_data="youth:gm_evening")]
    ])
    try:
        await context.bot.send_message(uid, T[lang]["daily_gm"], reply_markup=kb)
    except Exception as e:
        logging.error(f"job_daily_checkin send error: {e}")


# ---------- /profile ----------
async def cmd_profile(update: Update, context: ContextTypes.DEFAULT_TYPE):
    uid = update.effective_user.id
    lang = _user_lang(uid)
    kb = InlineKeyboardMarkup([[InlineKeyboardButton("üß© Start intake" if lang=="en" else "üß© –ù–∞—á–∞—Ç—å –æ–ø—Ä–æ—Å",
                                                      callback_data="intake:start")]])
    await update.message.reply_text(T[lang]["profile_intro"], reply_markup=kb)


# ---------- /settz ----------
async def cmd_settz(update: Update, context: ContextTypes.DEFAULT_TYPE):
    uid = update.effective_user.id
    lang = _user_lang(uid)
    txt = (update.message.text or "").strip()
    m = re.search(r"(-?\+?\d{1,2})", txt)
    if not m:
        await update.message.reply_text("Usage: /settz +2  |  –ü—Ä–∏–º–µ—Ä: /settz +3")
        return
    try:
        off = int(m.group(1))
        off = max(-12, min(14, off))
        users_set(uid, "tz_offset", str(off))
        await update.message.reply_text(f"UTC offset set: {off:+d}")
        u = users_get(uid)
        hhmm = (u.get("checkin_hour") or DEFAULT_CHECKIN_LOCAL)
        if _has_jq_ctx(context):
            schedule_daily_checkin(context.application, uid, off, hhmm, lang)
    except Exception as e:
        logging.error(f"/settz error: {e}")
        await update.message.reply_text("Failed to set timezone offset.")

# ---------- /checkin_on /checkin_off ----------
async def cmd_checkin_on(update: Update, context: ContextTypes.DEFAULT_TYPE):
    uid = update.effective_user.id
    lang = _user_lang(uid)
    txt = (update.message.text or "").strip()
    m = re.search(r"([01]?\d|2[0-3]):([0-5]\d)", txt)
    hhmm = m.group(0) if m else DEFAULT_CHECKIN_LOCAL
    users_set(uid, "checkin_hour", hhmm)
    users_set(uid, "paused", "no")
    if _has_jq_ctx(context):
        schedule_daily_checkin(context.application, uid, _user_tz_off(uid), hhmm, lang)
    await update.message.reply_text(f"Daily check-in set to {hhmm} (local).")

async def cmd_checkin_off(update: Update, context: ContextTypes.DEFAULT_TYPE):
    uid = update.effective_user.id
    if _has_jq_ctx(context):
        for j in context.application.job_queue.get_jobs_by_name(f"daily_{uid}"):
            j.schedule_removal()
    users_set(uid, "paused", "yes")
    await update.message.reply_text("Daily check-in disabled.")

# ---------- Lang switches ----------
async def cmd_lang_ru(update: Update, context: ContextTypes.DEFAULT_TYPE):
    users_set(update.effective_user.id, "lang", "ru")
    context.user_data["lang"] = "ru"
    await update.message.reply_text("–Ø–∑—ã–∫: —Ä—É—Å—Å–∫–∏–π.")

async def cmd_lang_en(update: Update, context: ContextTypes.DEFAULT_TYPE):
    users_set(update.effective_user.id, "lang", "en")
    context.user_data["lang"] = "en"
    await update.message.reply_text("Language set: English.")

async def cmd_lang_uk(update: Update, context: ContextTypes.DEFAULT_TYPE):
    users_set(update.effective_user.id, "lang", "uk")
    context.user_data["lang"] = "uk"
    await update.message.reply_text("–ú–æ–≤–∞: —É–∫—Ä–∞—ó–Ω—Å—å–∫–∞.")

async def cmd_lang_es(update: Update, context: ContextTypes.DEFAULT_TYPE):
    users_set(update.effective_user.id, "lang", "es")
    context.user_data["lang"] = "es"
    await update.message.reply_text("Idioma: espa√±ol (beta).")


# ---------- Health60 ----------
async def cmd_health60(update: Update, context: ContextTypes.DEFAULT_TYPE):
    uid = update.effective_user.id
    lang = _user_lang(uid)
    sessions.setdefault(uid, {})["awaiting_h60_text"] = True
    await update.message.reply_text(T[lang]["h60_intro"])

async def _process_health60(uid: int, lang: str, text: str, msg_obj):
    prof = profiles_get(uid) or {}
    prefix = personalized_prefix(lang, prof)
    plan = health60_make_plan(lang, text, prof)
    final = (prefix + "\n" if prefix else "") + plan

    kb = InlineKeyboardMarkup([
        [InlineKeyboardButton(T[lang]["accept_opts"][0], callback_data="h60|accept|yes"),
         InlineKeyboardButton(T[lang]["accept_opts"][1], callback_data="h60|accept|later"),
         InlineKeyboardButton(T[lang]["accept_opts"][2], callback_data="h60|accept|no")],
        [InlineKeyboardButton(T[lang]["act_rem_4h"],  callback_data="h60|rem|4h"),
         InlineKeyboardButton(T[lang]["act_rem_eve"], callback_data="h60|rem|eve"),
         InlineKeyboardButton(T[lang]["act_rem_morn"],callback_data="h60|rem|morn")],
        [InlineKeyboardButton(T[lang]["act_save_episode"], callback_data="h60|episode|save"),
         InlineKeyboardButton(T[lang]["act_ex_neck"],      callback_data="h60|neck"),
         InlineKeyboardButton(T[lang]["act_er"],           callback_data="h60|er")]
    ])
    await msg_obj.reply_text(final, reply_markup=kb)


# ---------- Youth pack ----------
async def cmd_energy(update: Update, context: ContextTypes.DEFAULT_TYPE):
    uid = update.effective_user.id
    lang = _user_lang(uid)
    row = [InlineKeyboardButton(str(i), callback_data=f"energy|rate|{i}") for i in range(1,6)]
    kb = InlineKeyboardMarkup([row])
    await update.message.reply_text(T[lang]["gm_energy_q"], reply_markup=kb)

async def cmd_hydrate(update: Update, context: ContextTypes.DEFAULT_TYPE):
    uid = update.effective_user.id
    lang = _user_lang(uid)
    tip = T[lang]["hydrate_nudge"]
    daily_add(iso(utcnow()), uid, mood="", comment=tip, energy=None)
    await update.message.reply_text(tip)

async def cmd_skintip(update: Update, context: ContextTypes.DEFAULT_TYPE):
    uid = update.effective_user.id
    lang = _user_lang(uid)
    prof = profiles_get(uid) or {}
    age = int(re.search(r"\d+", str(prof.get("age") or "0")).group(0)) if re.search(r"\d+", str(prof.get("age") or "")) else 0
    sex = (prof.get("sex") or "").lower()
    tip = _get_skin_tip(lang, sex, age)
    await update.message.reply_text(f"{T[lang]['daily_tip_prefix']} {tip}")

async def cmd_cycle(update: Update, context: ContextTypes.DEFAULT_TYPE):
    uid = update.effective_user.id
    lang = _user_lang(uid)
    kb = InlineKeyboardMarkup([[InlineKeyboardButton(T[lang]["yes"], callback_data="cycle|consent|yes"),
                                InlineKeyboardButton(T[lang]["no"],  callback_data="cycle|consent|no")]])
    await update.message.reply_text(T[lang]["cycle_consent"], reply_markup=kb)

async def cmd_youth(update: Update, context: ContextTypes.DEFAULT_TYPE):
    uid = update.effective_user.id
    lang = _user_lang(uid)
    kb = InlineKeyboardMarkup([
        [InlineKeyboardButton(T[lang]["gm_energy"], callback_data="menu|energy"),
         InlineKeyboardButton(T[lang]["hydrate_btn"], callback_data="menu|hydrate")],
        [InlineKeyboardButton(T[lang]["skintip_btn"], callback_data="menu|skintip"),
         InlineKeyboardButton(T[lang]["gm_evening_btn"], callback_data="youth:gm_evening")],
        [InlineKeyboardButton(T[lang]["set_quiet_btn"], callback_data="youth:set_quiet"),
         InlineKeyboardButton(T[lang]["challenge_btn"], callback_data="youth:challenge")]
    ])
    await update.message.reply_text(T[lang]["youth_pack"], reply_markup=kb)


# ---------- Callback Query Handler ----------
async def cb_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    q = update.callback_query
    await q.answer()
    uid = q.from_user.id
    lang = _user_lang(uid)
    data = (q.data or "")

    # Gate skip
    if data == "gate:skip":
        await gate_cb(update, context)
        return

    # Consent
    if data.startswith("consent|"):
        val = data.split("|",1)[1]
        users_set(uid, "consent", "yes" if val=="yes" else "no")
        await q.edit_message_text(T[lang]["thanks"])
        return

    # Mini-intake
    if data.startswith("mini|"):
        _, action, key, *rest = data.split("|")
        if action == "choose":
            value = rest[0] if rest else ""
            mini_handle_choice(uid, key, value)
        elif action == "skip":
            s = sessions.setdefault(uid, {"mini_active": True, "mini_step": 0, "mini_answers": {}})
            s["mini_step"] = int(s.get("mini_step", 0)) + 1
        await ask_next_mini(context, update.effective_chat.id, lang, uid)
        return

    # Menu quick actions
    if data.startswith("menu|"):
        act = data.split("|",1)[1]
        if act == "h60":
            sessions.setdefault(uid, {})["awaiting_h60_text"] = True
            await context.bot.send_message(uid, T[lang]["h60_intro"])
        elif act == "energy":
            row = [InlineKeyboardButton(str(i), callback_data=f"energy|rate|{i}") for i in range(1,6)]
            kb = InlineKeyboardMarkup([row])
            await context.bot.send_message(uid, T[lang]["gm_energy_q"], reply_markup=kb)
        elif act == "hydrate":
            tip = T[lang]["hydrate_nudge"]
            daily_add(iso(utcnow()), uid, mood="", comment=tip, energy=None)
            await context.bot.send_message(uid, tip)
        elif act == "skintip":
            prof = profiles_get(uid) or {}
            age = int(re.search(r"\d+", str(prof.get("age") or "0")).group(0)) if re.search(r"\d+", str(prof.get("age") or "")) else 0
            sex = (prof.get("sex") or "").lower()
            tip = _get_skin_tip(lang, sex, age)
            await context.bot.send_message(uid, f"{T[lang]['daily_tip_prefix']} {tip}")
        elif act == "cycle":
            kb = InlineKeyboardMarkup([[InlineKeyboardButton(T[lang]["yes"], callback_data="cycle|consent|yes"),
                                        InlineKeyboardButton(T[lang]["no"],  callback_data="cycle|consent|no")]])
            await context.bot.send_message(uid, T[lang]["cycle_consent"], reply_markup=kb)
        elif act == "youth":
            kb = InlineKeyboardMarkup([
                [InlineKeyboardButton(T[lang]["gm_energy"], callback_data="menu|energy"),
                 InlineKeyboardButton(T[lang]["hydrate_btn"], callback_data="menu|hydrate")],
                [InlineKeyboardButton(T[lang]["skintip_btn"], callback_data="menu|skintip"),
                 InlineKeyboardButton(T[lang]["gm_evening_btn"], callback_data="youth:gm_evening")],
                [InlineKeyboardButton(T[lang]["set_quiet_btn"], callback_data="youth:set_quiet"),
                 InlineKeyboardButton(T[lang]["challenge_btn"], callback_data="youth:challenge")]
            ])
            await context.bot.send_message(uid, T[lang]["youth_pack"], reply_markup=kb)
        return

    # Health60 actions
    if data.startswith("h60|"):
        parts = data.split("|")
        sub = parts[1] if len(parts)>1 else ""
        if sub == "accept":
            await q.edit_message_reply_markup(None)
            await context.bot.send_message(uid, T[lang]["thanks"])
        elif sub == "rem":
            opt = parts[2] if len(parts)>2 else ""
            now_local = user_local_now(uid)
            if opt == "4h":
                when_local = now_local + timedelta(hours=4)
                adj = _schedule_oneoff_with_sheet(context, uid, when_local, T[lang]["thanks"])
                await context.bot.send_message(uid, _fmt_reminder_set(lang, adj, kind="4h"))
            elif opt == "eve":
                eh = users_get(uid).get("evening_hour") or DEFAULT_EVENING_LOCAL
                (hh, mm) = hhmm_tuple(eh)
                target = now_local.replace(hour=hh, minute=mm, second=0, microsecond=0)
                if target <= now_local:
                    target = target + timedelta(days=1)
                adj = _schedule_oneoff_with_sheet(context, uid, target, T[lang]["thanks"])
                await context.bot.send_message(uid, _fmt_reminder_set(lang, adj, kind="evening"))
            elif opt == "morn":
                mh = users_get(uid).get("checkin_hour") or DEFAULT_CHECKIN_LOCAL
                (hh, mm) = hhmm_tuple(mh)
                target = now_local.replace(hour=hh, minute=mm, second=0, microsecond=0)
                if target <= now_local:
                    target = target + timedelta(days=1)
                adj = _schedule_oneoff_with_sheet(context, uid, target, T[lang]["thanks"])
                await context.bot.send_message(uid, _fmt_reminder_set(lang, adj, kind="morning"))
        elif sub == "episode":
            act = parts[2] if len(parts)>2 else ""
            if act == "save":
                eid = episode_create(uid, topic="h60", severity=5, red="")
                sessions.setdefault(uid, {})["last_eid"] = eid
                await context.bot.send_message(uid, T[lang]["act_saved"])
        elif sub == "neck":
            text_map = {
                "ru": "üßò 5 –º–∏–Ω—É—Ç –¥–ª—è —à–µ–∏:\n‚Ä¢ –ú–µ–¥–ª–µ–Ω–Ω—ã–µ –Ω–∞–∫–ª–æ–Ω—ã: –≤–ø–µ—Ä—ë–¥/–Ω–∞–∑–∞–¥/–≤ —Å—Ç–æ—Ä–æ–Ω—ã √ó6\n‚Ä¢ –ü–æ–≤–æ—Ä–æ—Ç—ã –≥–æ–ª–æ–≤—ã √ó6\n‚Ä¢ –ü–ª–µ—á–∏: –ø–æ–¥—ä—ë–º/–∫—Ä—É–≥–∏ √ó10\n‚Ä¢ –ú—è–≥–∫–æ–µ –≤—ã—Ç—è–∂–µ–Ω–∏–µ, –±–µ–∑ –±–æ–ª–∏\n‚Ä¢ –î—ã—Ö–∞–Ω–∏–µ 4‚Äì6 —Ü–∏–∫–ª–æ–≤",
                "uk": "üßò 5 —Ö–≤ –¥–ª—è —à–∏—ó:\n‚Ä¢ –ü–æ—Ö–∏–ª–∏: –≤–ø–µ—Ä–µ–¥/–Ω–∞–∑–∞–¥/–≤ —Å—Ç–æ—Ä–æ–Ω–∏ √ó6\n‚Ä¢ –ü–æ–≤–æ—Ä–æ—Ç–∏ –≥–æ–ª–æ–≤–∏ √ó6\n‚Ä¢ –ü–ª–µ—á—ñ: –ø—ñ–¥–π–æ–º/–∫–æ–ª–∞ √ó10\n‚Ä¢ –ú‚Äô—è–∫–µ —Ä–æ–∑—Ç—è–≥–Ω–µ–Ω–Ω—è –±–µ–∑ –±–æ–ª—é\n‚Ä¢ –î–∏—Ö–∞–Ω–Ω—è 4‚Äì6 —Ü–∏–∫–ª—ñ–≤",
                "es": "üßò 5 min para el cuello:\n‚Ä¢ Inclinaciones: adelante/atr√°s/lados √ó6\n‚Ä¢ Giros de cabeza √ó6\n‚Ä¢ Hombros: elevaci√≥n/c√≠rculos √ó10\n‚Ä¢ Estiramiento suave, sin dolor\n‚Ä¢ Respiraci√≥n 4‚Äì6 ciclos",
                "en": "üßò 5-min neck reset:\n‚Ä¢ Slow tilts: forward/back/side √ó6\n‚Ä¢ Head turns √ó6\n‚Ä¢ Shoulders: shrug/circles √ó10\n‚Ä¢ Gentle stretch, no pain\n‚Ä¢ Breathe 4‚Äì6 cycles",
            }
            await context.bot.send_message(uid, text_map[lang])
        elif sub == "er":
            await context.bot.send_message(uid, T[lang]["er_text"])
        return

    # Daily GM actions
    if data.startswith("gm|"):
        _, kind, *rest = data.split("|")
        if kind == "mood":
            mood = rest[0] if rest else "ok"
            daily_add(iso(utcnow()), uid, mood=mood, comment="")
            await q.edit_message_reply_markup(None)
            await context.bot.send_message(uid, T[lang]["mood_thanks"])
        elif kind == "note":
            sessions.setdefault(uid, {})["await_gm_note"] = True
            await q.edit_message_text(T[lang]["fb_write"])
        return

    # Energy rating
    if data.startswith("energy|rate|"):
        try:
            val = int(data.split("|")[-1])
        except:
            val = None
        daily_add(iso(utcnow()), uid, mood="", comment="energy", energy=val)
        await q.edit_message_reply_markup(None)
        await context.bot.send_message(uid, T[lang]["gm_energy_done"])
        return

    # Youth pack shortcuts
    if data.startswith("youth:"):
        act = data.split(":",1)[1]
        if act == "gm_evening":
            u = users_get(uid)
            off = _user_tz_off(uid)
            eh = (u.get("evening_hour") or DEFAULT_EVENING_LOCAL)
            users_set(uid, "evening_hour", eh)
            if _has_jq_ctx(context):
                schedule_evening_checkin(context.application, uid, off, eh, lang)
            await context.bot.send_message(uid, T[lang]["evening_set"].format(t=eh))
        elif act == "set_quiet":
            sessions.setdefault(uid, {})["await_quiet"] = True
            await context.bot.send_message(uid, T[lang]["ask_quiet"])
        elif act == "challenge":
            if challenge_get(uid):
                d = challenge_get(uid)
                await context.bot.send_message(uid, T[lang]["challenge_progress"].format(d=d.get("days_done","0"), len=d.get("length_days","7")))
            else:
                challenge_start(uid)
                await context.bot.send_message(uid, T[lang]["challenge_started"])
        elif act == "tip":
            prof = profiles_get(uid) or {}
            tip = _get_daily_tip(prof, lang)
            await context.bot.send_message(uid, f"{T[lang]['daily_tip_prefix']} {tip}")
        return

    # Cycle flow
    if data.startswith("cycle|consent|"):
        val = data.split("|")[-1]
        if val == "yes":
            sessions.setdefault(uid, {})["await_cycle_last"] = True
            await context.bot.send_message(uid, T[lang]["cycle_ask_last"])
        else:
            await context.bot.send_message(uid, T[lang]["thanks"])
        return

    # Mini-intake free text trigger (handled via msg_text)
    if data.startswith("mini|write|"):
        key = data.split("|",2)[2]
        s = sessions.setdefault(uid, {"mini_active": True, "mini_step": 0, "mini_answers": {}})
        s["mini_wait_key"] = key
        await q.edit_message_text(T[lang]["write"] + "‚Ä¶")
        return

    # Numeric 0‚Äì10 check-in (episodes)
    if data.startswith("num|"):
        try:
            val = int(data.split("|")[1])
        except:
            val = 5
        ep = episode_find_open(uid)
        if ep:
            if val <= 3:
                episode_set(ep["episode_id"], "status", "closed")
                await context.bot.send_message(uid, T[lang]["checkin_better"])
            else:
                await context.bot.send_message(uid, T[lang]["checkin_worse"])
        else:
            await context.bot.send_message(uid, T[lang]["thanks"])
        return

    # Feedback
    if data.startswith("fb|"):
        kind = data.split("|")[1]
        if kind in {"good","bad"}:
            feedback_add(iso(utcnow()), uid, name="", username=users_get(uid).get("username",""), rating=("1" if kind=="bad" else "5"), comment="")
            await q.edit_message_reply_markup(None)
            await context.bot.send_message(uid, T[lang]["fb_thanks"])
        elif kind == "free":
            sessions.setdefault(uid, {})["await_fb_msg"] = True
            await q.edit_message_text(T[lang]["fb_write"])
        return


def _fmt_reminder_set(lang: str, when_local: datetime, kind: str=""):
    hhmm = _format_hhmm(when_local)
    if lang == "ru":
        base = {"4h": f"‚è∞ –ù–∞–ø–æ–º–Ω—é –æ–∫–æ–ª–æ {hhmm} (–ª–æ–∫.)",
                "evening": f"‚è∞ –ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ –Ω–∞ {hhmm} (–≤–µ—á–µ—Ä–æ–º, –ª–æ–∫.)",
                "morning": f"‚è∞ –ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ –Ω–∞ {hhmm} (—É—Ç—Ä–æ–º, –ª–æ–∫.)"}
    elif lang == "uk":
        base = {"4h": f"‚è∞ –ù–∞–≥–∞–¥–∞—é –±–ª–∏–∑—å–∫–æ {hhmm} (–ª–æ–∫.)",
                "evening": f"‚è∞ –ù–∞–≥–∞–¥—É–≤–∞–Ω–Ω—è –Ω–∞ {hhmm} (—É–≤–µ—á–µ—Ä—ñ, –ª–æ–∫.)",
                "morning": f"‚è∞ –ù–∞–≥–∞–¥—É–≤–∞–Ω–Ω—è –Ω–∞ {hhmm} (–∑—Ä–∞–Ω–∫—É, –ª–æ–∫.)"}
    elif lang == "es":
        base = {"4h": f"‚è∞ Recordatorio ~{hhmm} (local)",
                "evening": f"‚è∞ Recordatorio {hhmm} (tarde, local)",
                "morning": f"‚è∞ Recordatorio {hhmm} (ma√±ana, local)"}
    else:
        base = {"4h": f"‚è∞ Reminder around {hhmm} (local)",
                "evening": f"‚è∞ Reminder for {hhmm} (evening, local)",
                "morning": f"‚è∞ Reminder for {hhmm} (morning, local)"}
    return base.get(kind, base["4h"])


# ---------- Evening Check-in job ----------
async def job_evening_checkin(context: ContextTypes.DEFAULT_TYPE):
    d = context.job.data or {}
    uid = d.get("user_id"); lang = norm_lang((d.get("lang") or "en"))
    if not uid:
        return
    u = users_get(uid)
    if (u.get("paused") or "").lower() == "yes":
        return
    kb = InlineKeyboardMarkup([
        [InlineKeyboardButton(T[lang]["evening_tip_btn"], callback_data="youth:tip")],
        [InlineKeyboardButton("0", callback_data="num|0"),
         InlineKeyboardButton("3", callback_data="num|3"),
         InlineKeyboardButton("6", callback_data="num|6"),
         InlineKeyboardButton("8", callback_data="num|8"),
         InlineKeyboardButton("10", callback_data="num|10")]
    ])
    try:
        await context.bot.send_message(uid, T[lang]["evening_intro"], reply_markup=kb)
    except Exception as e:
        logging.error(f"job_evening_checkin send error: {e}")


# ---------- Extra commands ----------
async def cmd_evening_on(update: Update, context: ContextTypes.DEFAULT_TYPE):
    uid = update.effective_user.id
    lang = _user_lang(uid)
    txt = (update.message.text or "")
    m = re.search(r"([01]?\d|2[0-3]):([0-5]\d)", txt)
    hhmm = m.group(0) if m else DEFAULT_EVENING_LOCAL
    users_set(uid, "evening_hour", hhmm)
    if _has_jq_ctx(context):
        schedule_evening_checkin(context.application, uid, _user_tz_off(uid), hhmm, lang)
    await update.message.reply_text(T[lang]["evening_set"].format(t=hhmm))

async def cmd_evening_off(update: Update, context: ContextTypes.DEFAULT_TYPE):
    uid = update.effective_user.id
    lang = _user_lang(uid)
    if _has_jq_ctx(context):
        for j in context.application.job_queue.get_jobs_by_name(f"evening_{uid}"):
            j.schedule_removal()
    users_set(uid, "evening_hour", "")
    await update.message.reply_text(T[lang]["evening_off"])

async def cmd_mood(update: Update, context: ContextTypes.DEFAULT_TYPE):
    uid = update.effective_user.id
    lang = _user_lang(uid)
    kb = InlineKeyboardMarkup([
        [InlineKeyboardButton(T[lang]["mood_good"], callback_data="gm|mood|good"),
         InlineKeyboardButton(T[lang]["mood_ok"],   callback_data="gm|mood|ok"),
         InlineKeyboardButton(T[lang]["mood_bad"],  callback_data="gm|mood|bad")],
        [InlineKeyboardButton(T[lang]["mood_note"], callback_data="gm|note")]
    ])
    await update.message.reply_text(T[lang]["mood_cmd"], reply_markup=kb)


# ---------- General text handler ----------
async def msg_text(update: Update, context: ContextTypes.DEFAULT_TYPE):
    uid = update.effective_user.id
    lang = _user_lang(uid)
    text = (update.message.text or "").strip()
    update_last_seen(uid)
    s = sessions.setdefault(uid, {})

    # Mini-intake free text capture
    if s.get("mini_active") and s.get("mini_wait_key"):
        key = s["mini_wait_key"]
        s["mini_wait_key"] = None
        s["mini_answers"][key] = text
        s["mini_step"] = int(s.get("mini_step", 0)) + 1
        await ask_next_mini(context, update.effective_chat.id, lang, uid)
        return

    # GM note
    if s.get("await_gm_note"):
        daily_add(iso(utcnow()), uid, mood="", comment=text, energy=None)
        s["await_gm_note"] = False
        await update.message.reply_text(T[lang]["mood_thanks"])
        return

    # Quiet hours
    if s.get("await_quiet"):
        qh = text if re.match(r"^\s*([01]?\d|2[0-3]):[0-5]\d-([01]?\d|2[0-3]):[0-5]\d\s*$", text) else DEFAULT_QUIET_HOURS
        profiles_upsert(uid, {"quiet_hours": qh})
        s["await_quiet"] = False
        await update.message.reply_text(T[lang]["quiet_saved"].format(qh=qh))
        return

    # Cycle flow
    if s.get("await_cycle_last"):
        if re.match(r"^\d{4}-\d{2}-\d{2}$", text):
            profiles_upsert(uid, {"cycle_last_date": text})
            s["await_cycle_last"] = False
            s["await_cycle_len"] = True
            await update.message.reply_text(T[lang]["cycle_ask_len"])
        else:
            await update.message.reply_text(T[lang]["cycle_ask_last"])
        return
    if s.get("await_cycle_len"):
        try:
            n = int(re.findall(r"\d+", text)[0])
        except:
            n = 28
        profiles_upsert(uid, {"cycle_avg_len": str(max(21, min(40, n))), "cycle_enabled": "1"})
        s["await_cycle_len"] = False
        await update.message.reply_text(T[lang]["cycle_saved"])
        return

    # Feedback free-form
    if s.get("await_fb_msg"):
        feedback_add(iso(utcnow()), uid, name="", username=users_get(uid).get("username",""), rating="0", comment=text[:800])
        s["await_fb_msg"] = False
        await update.message.reply_text(T[lang]["fb_thanks"])
        return

    # Health60 awaiting
    if s.get("awaiting_h60_text"):
        s["awaiting_h60_text"] = False
        await _process_health60(uid, lang, text, update.message)
        kb = InlineKeyboardMarkup([
            [InlineKeyboardButton(T[lang]["fb_good"], callback_data="fb|good"),
             InlineKeyboardButton(T[lang]["fb_bad"],  callback_data="fb|bad")],
            [InlineKeyboardButton(T[lang]["fb_free"], callback_data="fb|free")]
        ])
        await update.message.reply_text(T[lang]["ask_fb"], reply_markup=kb)
        return

    # Router default (concise assistant mode)
    prof = profiles_get(uid) or {}
    prefix = personalized_prefix(lang, prof)
    route = llm_router_answer(text, lang, prof)
    reply = route.get("assistant_reply") or T[lang]["unknown"]
    followups = route.get("followups") or []
    lines = [reply]
    if followups:
        lines.append("")
        lines.append("‚Äî " + "\n‚Äî ".join([f for f in followups if f.strip()][:4]))
    final = (prefix + "\n" if prefix else "") + "\n".join(lines).strip()
    await send_unique(update.message, uid, final)


# ---------- Main ----------
def main():
    if not TELEGRAM_TOKEN:
        logging.error("TELEGRAM_TOKEN is not set")
        return
    app = ApplicationBuilder().token(TELEGRAM_TOKEN).post_init(post_init).build()

    # PRO-intake (group 0/1)
    register_intake_pro(app)  # —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–π pattern r"^intake"

    # Commands
    app.add_handler(CommandHandler("start", cmd_start))
    app.add_handler(CommandHandler("help", cmd_help))
    app.add_handler(CommandHandler("privacy", cmd_privacy))
    app.add_handler(CommandHandler("pause", cmd_pause))
    app.add_handler(CommandHandler("resume", cmd_resume))
    app.add_handler(CommandHandler("delete_data", cmd_delete_data))
    app.add_handler(CommandHandler("profile", cmd_profile))
    app.add_handler(CommandHandler("health60", cmd_health60))
    app.add_handler(CommandHandler("mood", cmd_mood))
    app.add_handler(CommandHandler("energy", cmd_energy))
    app.add_handler(CommandHandler("hydrate", cmd_hydrate))
    app.add_handler(CommandHandler("skintip", cmd_skintip))
    app.add_handler(CommandHandler("cycle", cmd_cycle))
    app.add_handler(CommandHandler("youth", cmd_youth))
    app.add_handler(CommandHandler("settz", cmd_settz))
    app.add_handler(CommandHandler("checkin_on", cmd_checkin_on))
    app.add_handler(CommandHandler("checkin_off", cmd_checkin_off))
    app.add_handler(CommandHandler("evening_on", cmd_evening_on))
    app.add_handler(CommandHandler("evening_off", cmd_evening_off))
    app.add_handler(CommandHandler("ru", cmd_lang_ru))
    app.add_handler(CommandHandler("uk", cmd_lang_uk))
    app.add_handler(CommandHandler("en", cmd_lang_en))
    app.add_handler(CommandHandler("es", cmd_lang_es))

    # General callbacks & messages (after PRO groups 0/1)
    app.add_handler(CallbackQueryHandler(cb_handler), group=2)
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, msg_text), group=2)

    logging.info("Starting polling‚Ä¶")
    app.run_polling()

if __name__ == "__main__":
    main()
