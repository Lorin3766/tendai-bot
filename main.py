# -*- coding: utf-8 -*-
# ==========================================
# TendAI ‚Äî FULL CODE (Part 1 / 2)
# Base, i18n, storage, intake, rules, care, metrics,
# unified scheduling (quiet hours), triage scaffold
# ==========================================

import os, re, json, uuid, logging, random
from datetime import datetime, timedelta, timezone, date, time as dtime
from typing import List, Dict, Optional, Set, Tuple
from difflib import SequenceMatcher

from dotenv import load_dotenv
from langdetect import detect, DetectorFactory

from telegram import (
    Update, InlineKeyboardButton, InlineKeyboardMarkup, ReplyKeyboardRemove
)
from telegram.ext import (
    ApplicationBuilder, Application, CommandHandler, MessageHandler,
    CallbackQueryHandler, ContextTypes, filters
)

# ---------- OpenAI (optional) ----------
from openai import OpenAI

# ---------- Google Sheets (robust + memory fallback) ----------
import gspread
import gspread.utils as gsu
from gspread.exceptions import SpreadsheetNotFound, WorksheetNotFound
from oauth2client.service_account import ServiceAccountCredentials


# ---------------- Boot & Config ----------------
load_dotenv()
logging.basicConfig(level=logging.INFO, format="%(asctime)s | %(levelname)s | %(message)s")
DetectorFactory.seed = 0

TELEGRAM_TOKEN = os.getenv("TELEGRAM_TOKEN", "")
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY", "")
OPENAI_MODEL = os.getenv("OPENAI_MODEL", "gpt-4o")

SHEET_NAME = os.getenv("SHEET_NAME", "TendAI Sheets")
SHEET_ID = os.getenv("SHEET_ID", "")
ALLOW_CREATE_SHEET = os.getenv("ALLOW_CREATE_SHEET", "0") == "1"

DEFAULT_CHECKIN_LOCAL = "08:30"
DEFAULT_EVENING_LOCAL  = "20:00"
DEFAULT_MIDDAY_LOCAL   = "13:00"
DEFAULT_WEEKLY_LOCAL   = "10:00"  # Sunday
DEFAULT_QUIET_HOURS    = "22:00-08:00"

AUTO_MAX_PER_DAY = 2  # –∞–≤—Ç–æ-—Å–æ–æ–±—â–µ–Ω–∏–π/–¥–µ–Ω—å –º–∞–∫—Å–∏–º—É–º

# OpenAI client
oai: Optional[OpenAI] = None
try:
    if OPENAI_API_KEY:
        os.environ["OPENAI_API_KEY"] = OPENAI_API_KEY
        oai = OpenAI()
except Exception as e:
    logging.error(f"OpenAI init error: {e}")
    oai = None


# ---------------- i18n & text ----------------
SUPPORTED = {"ru", "en", "uk", "es"}

def norm_lang(code: Optional[str]) -> str:
    if not code: return "en"
    c = code.split("-")[0].lower()
    return c if c in SUPPORTED else "en"

T: Dict[str, Dict[str, str]] = {
    "en": {
        "welcome": "Hi! I‚Äôm TendAI ‚Äî a caring health & longevity assistant.\nShort, useful, friendly. Let‚Äôs do a 40s intake to personalize.",
        "help": "Short checkups, 24‚Äì48h plans, reminders, daily check-ins.\nCommands: /help /privacy /pause /resume /delete_data /profile /checkin_on 08:30 /checkin_off /evening_on 20:00 /evening_off /settz +2 /health60 /mood /energy /hydrate /skintip /cycle /youth /ru /uk /en /es",
        "privacy": "I‚Äôm not a medical service. Minimal data for reminders only. Use /delete_data to erase.",
        "quick_title": "Quick actions",
        "quick_h60": "‚ö° Health in 60s",
        "quick_er": "üöë Emergency info",
        "quick_lab": "üß™ Lab",
        "quick_rem": "‚è∞ Reminder",
        "profile_intro": "Quick intake (~40s). Use buttons or type.",
        "write": "‚úçÔ∏è Write", "skip": "‚è≠Ô∏è Skip",
        "start_where": "Where do you want to start? (symptom/sleep/nutrition/labs/habits/longevity)",
        "saved_profile": "Saved: ",
        "daily_gm": "Good morning! üåû How do you feel today?",
        "gm_excellent": "üëç Excellent", "gm_ok": "üôÇ Okay", "gm_tired": "üòê Tired", "gm_pain": "ü§ï In pain", "gm_skip": "‚è≠Ô∏è Skip today",
        "mood_note": "‚úçÔ∏è Comment", "mood_thanks": "Thanks! Have a smooth day üëã",
        "h60_btn": "Health in 60 seconds",
        "h60_intro": "Briefly write what‚Äôs bothering you (e.g., ‚Äúheadache‚Äù, ‚Äúfatigue‚Äù). I‚Äôll give 3 key tips in 60s.",
        "h60_t1": "Possible causes", "h60_t2": "Do now (next 24‚Äì48h)", "h60_t3": "When to see a doctor", "h60_serious":"Serious to rule out",
        "ask_fb":"Was this helpful?","fb_good":"üëç Like","fb_bad":"üëé Dislike","fb_free":"üìù Feedback","fb_write":"Write a short feedback:","fb_thanks":"Thanks for your feedback! ‚úÖ",
        "youth_pack":"Youth Pack","gm_energy":"‚ö° Energy","gm_energy_q":"Your energy (1‚Äì5)?","gm_energy_done":"Logged energy ‚Äî thanks!","gm_evening_btn":"‚è∞ Remind this evening",
        "hydrate_btn":"üíß Hydration","hydrate_nudge":"üíß Time for a glass of water","skintip_btn":"üß¥ Skin/Body tip","skintip_sent":"Tip sent.","daily_tip_prefix":"üçé Daily tip:",
        "challenge_btn":"üéØ 7-day hydration challenge","challenge_started":"Challenge started! I‚Äôll track your daily check-ins.","challenge_progress":"Challenge progress: {d}/{len} days.",
        "cycle_btn":"ü©∏ Cycle","cycle_consent":"Track your cycle for gentle timing tips?","cycle_ask_last":"Enter last period date (YYYY-MM-DD):","cycle_ask_len":"Average cycle length (e.g., 28):","cycle_saved":"Cycle tracking saved.",
        "quiet_saved":"Quiet hours saved: {qh}", "set_quiet_btn":"üåô Quiet hours", "ask_quiet":"Type quiet hours as HH:MM-HH:MM (local), e.g. 22:00-08:00",
        "evening_intro":"Evening check-in:","evening_tip_btn":"ü™Ñ Tip of the day","evening_set":"Evening check-in set to {t} (local).","evening_off":"Evening check-in disabled.",
        "ask_consent":"May I send a follow-up later to check how you feel?","yes":"Yes","no":"No",
        "unknown":"I need a bit more info: where exactly and how long?","thanks":"Got it üôå","back":"‚óÄ Back","exit":"Exit",
        "paused_on":"Notifications paused. Use /resume to enable.","paused_off":"Notifications resumed.","deleted":"All your data was deleted. Use /start to begin again.",
        "life_today":"Today is your {n}-th day of life üéâ. Target ‚Äî 36,500 (100y).","life_percent":"You‚Äôve already passed {p}% toward 100 years.","life_estimate":"(estimated by age, set birth_date for accuracy)",
        "px":"Considering your profile: {sex}, {age}y; goal ‚Äî {goal}.",
        "act_rem_4h":"‚è∞ Remind in 4h","act_rem_eve":"‚è∞ This evening","act_rem_morn":"‚è∞ Tomorrow morning","act_save_episode":"üíæ Save episode","act_ex_neck":"üßò 5-min neck routine","act_er":"üöë Emergency info",
    },
    "ru": {
        "welcome": "–ü—Ä–∏–≤–µ—Ç! –Ø TendAI ‚Äî –∑–∞–±–æ—Ç–ª–∏–≤—ã–π –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç –∑–¥–æ—Ä–æ–≤—å—è –∏ –¥–æ–ª–≥–æ–ª–µ—Ç–∏—è.\n–ö–æ—Ä–æ—Ç–∫–æ, –ø–æ–ª–µ–∑–Ω–æ –∏ –ø–æ-–¥—Ä—É–∂–µ—Å–∫–∏. –î–∞–≤–∞–π—Ç–µ –º–∏–Ω–∏-–æ–ø—Ä–æ—Å (~40—Å) –¥–ª—è –ø–µ—Ä—Å–æ–Ω–∞–ª–∏–∑–∞—Ü–∏–∏.",
        "help": "–ö–æ—Ä–æ—Ç–∫–∏–µ –ø—Ä–æ–≤–µ—Ä–∫–∏, –ø–ª–∞–Ω –Ω–∞ 24‚Äì48 —á, –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è, –µ–∂–µ–¥–Ω–µ–≤–Ω—ã–µ —á–µ–∫-–∏–Ω—ã.\n–ö–æ–º–∞–Ω–¥—ã: /help /privacy /pause /resume /delete_data /profile /checkin_on 08:30 /checkin_off /evening_on 20:00 /evening_off /settz +3 /health60 /mood /energy /hydrate /skintip /cycle /youth /ru /uk /en /es",
        "privacy": "–Ø –Ω–µ –∑–∞–º–µ–Ω—è—é –≤—Ä–∞—á–∞. –î–∞–Ω–Ω—ã–µ ‚Äî —Ç–æ–ª—å–∫–æ –¥–ª—è –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π. /delete_data ‚Äî —É–¥–∞–ª–∏—Ç—å.",
        "quick_title":"–ë—ã—Å—Ç—Ä—ã–µ –¥–µ–π—Å—Ç–≤–∏—è","quick_h60":"‚ö° –ó–¥–æ—Ä–æ–≤—å–µ –∑–∞ 60 —Å–µ–∫","quick_er":"üöë –°—Ä–æ—á–Ω–æ –≤ —Å–∫–æ—Ä—É—é","quick_lab":"üß™ –õ–∞–±–æ—Ä–∞—Ç–æ—Ä–∏—è","quick_rem":"‚è∞ –ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ",
        "profile_intro":"–ë—ã—Å—Ç—Ä—ã–π –æ–ø—Ä–æ—Å (~40—Å). –ú–æ–∂–Ω–æ –∫–Ω–æ–ø–∫–∞–º–∏ –∏–ª–∏ —Ç–µ–∫—Å—Ç–æ–º.","write":"‚úçÔ∏è –ù–∞–ø–∏—Å–∞—Ç—å","skip":"‚è≠Ô∏è –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å",
        "start_where":"–° —á–µ–≥–æ –Ω–∞—á–Ω—ë–º? (—Å–∏–º–ø—Ç–æ–º/—Å–æ–Ω/–ø–∏—Ç–∞–Ω–∏–µ/–∞–Ω–∞–ª–∏–∑—ã/–ø—Ä–∏–≤—ã—á–∫–∏/–¥–æ–ª–≥–æ–ª–µ—Ç–∏–µ)","saved_profile":"–°–æ—Ö—Ä–∞–Ω–∏–ª: ",
        "daily_gm":"–î–æ–±—Ä–æ–µ —É—Ç—Ä–æ! üåû –ö–∞–∫ —Å–µ–≥–æ–¥–Ω—è —Å–∞–º–æ—á—É–≤—Å—Ç–≤–∏–µ?","gm_excellent":"üëç –û—Ç–ª–∏—á–Ω–æ","gm_ok":"üôÇ –ù–æ—Ä–º–∞–ª—å–Ω–æ","gm_tired":"üòê –£—Å—Ç–∞–ª","gm_pain":"ü§ï –ë–æ–ª–∏—Ç","gm_skip":"‚è≠Ô∏è –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å",
        "mood_note":"‚úçÔ∏è –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π","mood_thanks":"–°–ø–∞—Å–∏–±–æ! –•–æ—Ä–æ—à–µ–≥–æ –¥–Ω—è üëã",
        "h60_btn":"–ó–¥–æ—Ä–æ–≤—å–µ –∑–∞ 60 —Å–µ–∫—É–Ω–¥","h60_intro":"–ö–æ—Ä–æ—Ç–∫–æ –Ω–∞–ø–∏—à–∏—Ç–µ, —á—Ç–æ –±–µ—Å–ø–æ–∫–æ–∏—Ç (–Ω–∞–ø—Ä–∏–º–µ—Ä: ¬´–±–æ–ª–∏—Ç –≥–æ–ª–æ–≤–∞¬ª, ¬´—É—Å—Ç–∞–ª–æ—Å—Ç—å¬ª). –î–∞–º 3 –∫–ª—é—á–µ–≤—ã—Ö —Å–æ–≤–µ—Ç–∞ –∑–∞ 60 —Å–µ–∫.",
        "h60_t1":"–í–æ–∑–º–æ–∂–Ω—ã–µ –ø—Ä–∏—á–∏–Ω—ã","h60_t2":"–ß—Ç–æ —Å–¥–µ–ª–∞—Ç—å —Å–µ–π—á–∞—Å (24‚Äì48 —á)","h60_t3":"–ö–æ–≥–¥–∞ –æ–±—Ä–∞—Ç–∏—Ç—å—Å—è –∫ –≤—Ä–∞—á—É","h60_serious":"–ß—Ç–æ —Å–µ—Ä—å—ë–∑–Ω–æ–µ –∏—Å–∫–ª—é—á–∏—Ç—å",
        "ask_fb":"–≠—Ç–æ –±—ã–ª–æ –ø–æ–ª–µ–∑–Ω–æ?","fb_good":"üëç –ù—Ä–∞–≤–∏—Ç—Å—è","fb_bad":"üëé –ù–µ –ø–æ–ª–µ–∑–Ω–æ","fb_free":"üìù –û—Ç–∑—ã–≤","fb_write":"–ù–∞–ø–∏—à–∏—Ç–µ –∫–æ—Ä–æ—Ç–∫–∏–π –æ—Ç–∑—ã–≤:","fb_thanks":"–°–ø–∞—Å–∏–±–æ –∑–∞ –æ—Ç–∑—ã–≤! ‚úÖ",
        "youth_pack":"–ú–æ–ª–æ–¥—ë–∂–Ω—ã–π –ø–∞–∫–µ—Ç","gm_energy":"‚ö° –≠–Ω–µ—Ä–≥–∏—è","gm_energy_q":"–ö–∞–∫ —ç–Ω–µ—Ä–≥–∏—è (1‚Äì5)?","gm_energy_done":"–ó–∞–ø–∏—Å–∞–ª —ç–Ω–µ—Ä–≥–∏—é ‚Äî —Å–ø–∞—Å–∏–±–æ!","gm_evening_btn":"‚è∞ –ù–∞–ø–æ–º–Ω–∏—Ç—å –≤–µ—á–µ—Ä–æ–º",
        "hydrate_btn":"üíß –ì–∏–¥—Ä–∞—Ç–∞—Ü–∏—è","hydrate_nudge":"üíß –í—Ä–µ–º—è –¥–ª—è —Å—Ç–∞–∫–∞–Ω–∞ –≤–æ–¥—ã","skintip_btn":"üß¥ –°–æ–≤–µ—Ç—ã –¥–ª—è –∫–æ–∂–∏/—Ç–µ–ª–∞","skintip_sent":"–°–æ–≤–µ—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω.","daily_tip_prefix":"üçé –ü–æ–¥—Å–∫–∞–∑–∫–∞ –¥–Ω—è:",
        "challenge_btn":"üéØ –ß–µ–ª–ª–µ–Ω–¥–∂ 7 –¥–Ω–µ–π (–≤–æ–¥–∞)","challenge_started":"–ß–µ–ª–ª–µ–Ω–¥–∂ –Ω–∞—á–∞—Ç!","challenge_progress":"–ü—Ä–æ–≥—Ä–µ—Å—Å: {d}/{len} –¥–Ω–µ–π.",
        "cycle_btn":"ü©∏ –¶–∏–∫–ª","cycle_consent":"–û—Ç—Å–ª–µ–∂–∏–≤–∞—Ç—å —Ü–∏–∫–ª –∏ –¥–∞–≤–∞—Ç—å –º—è–≥–∫–∏–µ –ø–æ–¥—Å–∫–∞–∑–∫–∏?","cycle_ask_last":"–í–≤–µ–¥–∏—Ç–µ –¥–∞—Ç—É –ø–æ—Å–ª–µ–¥–Ω–∏—Ö –º–µ—Å—è—á–Ω—ã—Ö (–ì–ì–ì–ì-–ú–ú-–î–î):","cycle_ask_len":"–°—Ä–µ–¥–Ω—è—è –¥–ª–∏–Ω–∞ —Ü–∏–∫–ª–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä, 28):","cycle_saved":"–û—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ —Ü–∏–∫–ª–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ.",
        "quiet_saved":"–¢–∏—Ö–∏–µ —á–∞—Å—ã —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã: {qh}","set_quiet_btn":"üåô –¢–∏—Ö–∏–µ —á–∞—Å—ã","ask_quiet":"–í–≤–µ–¥–∏—Ç–µ –ß–ß:–ú–ú-–ß–ß:–ú–ú (–ª–æ–∫–∞–ª—å–Ω–æ), –Ω–∞–ø—Ä. 22:00-08:00",
        "evening_intro":"–í–µ—á–µ—Ä–Ω–∏–π —á–µ–∫-–∏–Ω:","evening_tip_btn":"ü™Ñ –°–æ–≤–µ—Ç –¥–Ω—è","evening_set":"–í–µ—á–µ—Ä–Ω–∏–π —á–µ–∫-–∏–Ω –Ω–∞ {t} (–ª–æ–∫–∞–ª—å–Ω–æ).","evening_off":"–í–µ—á–µ—Ä–Ω–∏–π —á–µ–∫-–∏–Ω –æ—Ç–∫–ª—é—á—ë–Ω.",
        "ask_consent":"–ú–æ–∂–Ω–æ –ø—Ä–∏—Å–ª–∞—Ç—å –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ –ø–æ–∑–∂–µ, —á—Ç–æ–±—ã —É–∑–Ω–∞—Ç—å, –∫–∞–∫ –≤—ã?","yes":"–î–∞","no":"–ù–µ—Ç",
        "unknown":"–ù—É–∂–Ω–æ —á—É—Ç—å –±–æ–ª—å—à–µ –¥–µ—Ç–∞–ª–µ–π: –≥–¥–µ –∏–º–µ–Ω–Ω–æ –∏ –∫–∞–∫ –¥–æ–ª–≥–æ?","thanks":"–ü—Ä–∏–Ω—è—Ç–æ üôå","back":"‚óÄ –ù–∞–∑–∞–¥","exit":"–í—ã–π—Ç–∏",
        "paused_on":"–ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è –ø–æ—Å—Ç–∞–≤–ª–µ–Ω—ã –Ω–∞ –ø–∞—É–∑—É. /resume ‚Äî –≤–∫–ª—é—á–∏—Ç—å.","paused_off":"–ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è —Å–Ω–æ–≤–∞ –≤–∫–ª—é—á–µ–Ω—ã.","deleted":"–í—Å–µ –¥–∞–Ω–Ω—ã–µ —É–¥–∞–ª–µ–Ω—ã. /start ‚Äî –Ω–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ.",
        "life_today":"–°–µ–≥–æ–¥–Ω—è —Ç–≤–æ–π {n}-–π –¥–µ–Ω—å –∂–∏–∑–Ω–∏ üéâ. –¶–µ–ª—å ‚Äî 36 500 (100 –ª–µ—Ç).","life_percent":"–¢—ã –ø—Ä–æ—à—ë–ª —É–∂–µ {p}% –ø—É—Ç–∏ –∫ 100 –≥–æ–¥–∞–º.","life_estimate":"(–æ—Ü–µ–Ω–æ—á–Ω–æ –ø–æ –≤–æ–∑—Ä–∞—Å—Ç—É ‚Äî —É–∫–∞–∂–∏ birth_date –¥–ª—è —Ç–æ—á–Ω–æ—Å—Ç–∏)",
        "px":"–° —É—á—ë—Ç–æ–º –ø—Ä–æ—Ñ–∏–ª—è: {sex}, {age} –ª–µ—Ç; —Ü–µ–ª—å ‚Äî {goal}.",
        "act_rem_4h":"‚è∞ –ù–∞–ø–æ–º–Ω–∏—Ç—å —á–µ—Ä–µ–∑ 4 —á","act_rem_eve":"‚è∞ –°–µ–≥–æ–¥–Ω—è –≤–µ—á–µ—Ä–æ–º","act_rem_morn":"‚è∞ –ó–∞–≤—Ç—Ä–∞ —É—Ç—Ä–æ–º","act_save_episode":"üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å —ç–ø–∏–∑–æ–¥","act_ex_neck":"üßò 5-–º–∏–Ω —É–ø—Ä–∞–∂–Ω–µ–Ω–∏—è –¥–ª—è —à–µ–∏","act_er":"üöë –ö–æ–≥–¥–∞ —Å—Ä–æ—á–Ω–æ –≤ —Å–∫–æ—Ä—É—é",
    },
    "uk": {
        "welcome":"–ü—Ä–∏–≤—ñ—Ç! –Ø TendAI ‚Äî —Ç—É—Ä–±–æ—Ç–ª–∏–≤–∏–π –∞—Å–∏—Å—Ç–µ–Ω—Ç –∑–¥–æ—Ä–æ–≤‚Äô—è.\n–ó—Ä–æ–±—ñ–º–æ –∫–æ—Ä–æ—Ç–∫–∏–π –æ–ø–∏—Ç–Ω–∏–∫ (~40—Å) –¥–ª—è –ø–µ—Ä—Å–æ–Ω–∞–ª—ñ–∑–∞—Ü—ñ—ó.",
        "help":"–ö–æ—Ä–æ—Ç–∫—ñ –ø–µ—Ä–µ–≤—ñ—Ä–∫–∏, –ø–ª–∞–Ω –Ω–∞ 24‚Äì48 –≥–æ–¥, –Ω–∞–≥–∞–¥—É–≤–∞–Ω–Ω—è, —â–æ–¥–µ–Ω–Ω—ñ —á–µ–∫-—ñ–Ω–∏.\n–ö–æ–º–∞–Ω–¥–∏: /help /privacy /pause /resume /delete_data /profile /checkin_on 08:30 /checkin_off /evening_on 20:00 /evening_off /settz +2 /health60 /mood /energy /hydrate /skintip /cycle /youth /ru /uk /en /es",
        "privacy":"–Ø –Ω–µ –∑–∞–º—ñ–Ω—é—é –ª—ñ–∫–∞—Ä—è. –ú—ñ–Ω—ñ–º–∞–ª—å–Ω—ñ –¥–∞–Ω—ñ –ª–∏—à–µ –¥–ª—è –Ω–∞–≥–∞–¥—É–≤–∞–Ω—å. /delete_data ‚Äî –≤–∏–¥–∞–ª–∏—Ç–∏.",
        "quick_title":"–®–≤–∏–¥–∫—ñ –¥—ñ—ó","quick_h60":"‚ö° –ó–¥–æ—Ä–æ–≤‚Äô—è –∑–∞ 60 —Å","quick_er":"üöë –ù–µ–≤—ñ–¥–∫–ª–∞–¥–Ω–æ","quick_lab":"üß™ –õ–∞–±–æ—Ä–∞—Ç–æ—Ä—ñ—è","quick_rem":"‚è∞ –ù–∞–≥–∞–¥—É–≤–∞–Ω–Ω—è",
        "profile_intro":"–®–≤–∏–¥–∫–∏–π –æ–ø–∏—Ç–Ω–∏–∫ (~40—Å).","write":"‚úçÔ∏è –ù–∞–ø–∏—Å–∞—Ç–∏","skip":"‚è≠Ô∏è –ü—Ä–æ–ø—É—Å—Ç–∏—Ç–∏",
        "start_where":"–ó —á–æ–≥–æ –ø–æ—á–Ω–µ–º–æ? (—Å–∏–º–ø—Ç–æ–º/—Å–æ–Ω/—Ö–∞—Ä—á—É–≤–∞–Ω–Ω—è/–∞–Ω–∞–ª—ñ–∑–∏/–∑–≤–∏—á–∫–∏/–¥–æ–≤–≥–æ–ª—ñ—Ç—Ç—è)","saved_profile":"–ó–±–µ—Ä—ñ–≥: ",
        "daily_gm":"–î–æ–±—Ä–æ–≥–æ —Ä–∞–Ω–∫—É! üåû –Ø–∫ —Å–∞–º–æ–ø–æ—á—É—Ç—Ç—è —Å—å–æ–≥–æ–¥–Ω—ñ?","gm_excellent":"üëç –ß—É–¥–æ–≤–æ","gm_ok":"üôÇ –ù–æ—Ä–º–∞–ª—å–Ω–æ","gm_tired":"üòê –í—Ç–æ–º–∞","gm_pain":"ü§ï –ë–æ–ª–∏—Ç—å","gm_skip":"‚è≠Ô∏è –ü—Ä–æ–ø—É—Å—Ç–∏—Ç–∏",
        "mood_note":"‚úçÔ∏è –ö–æ–º–µ–Ω—Ç–∞—Ä","mood_thanks":"–î—è–∫—É—é! –ì–∞—Ä–Ω–æ–≥–æ –¥–Ω—è üëã",
        "h60_btn":"–ó–¥–æ—Ä–æ–≤‚Äô—è –∑–∞ 60 —Å–µ–∫—É–Ω–¥","h60_intro":"–ö–æ—Ä–æ—Ç–∫–æ –Ω–∞–ø–∏—à—ñ—Ç—å, —â–æ —Ç—É—Ä–±—É—î. –î–∞–º 3 –ø–æ—Ä–∞–¥–∏ –∑–∞ 60 —Å.",
        "h60_t1":"–ú–æ–∂–ª–∏–≤—ñ –ø—Ä–∏—á–∏–Ω–∏","h60_t2":"–©–æ –∑—Ä–æ–±–∏—Ç–∏ –∑–∞—Ä–∞–∑ (24‚Äì48 –≥–æ–¥)","h60_t3":"–ö–æ–ª–∏ –∑–≤–µ—Ä–Ω—É—Ç–∏—Å—å –¥–æ –ª—ñ–∫–∞—Ä—è","h60_serious":"–©–æ —Å–µ—Ä–π–æ–∑–Ω–µ –≤–∏–∫–ª—é—á–∏—Ç–∏",
        "ask_fb":"–¶–µ –±—É–ª–æ –∫–æ—Ä–∏—Å–Ω–æ?","fb_good":"üëç –ü–æ–¥–æ–±–∞—î—Ç—å—Å—è","fb_bad":"üëé –ù–µ –∫–æ—Ä–∏—Å–Ω–æ","fb_free":"üìù –í—ñ–¥–≥—É–∫","fb_write":"–ù–∞–ø–∏—à—ñ—Ç—å –∫–æ—Ä–æ—Ç–∫–∏–π –≤—ñ–¥–≥—É–∫:","fb_thanks":"–î—è–∫—É—é! ‚úÖ",
        "youth_pack":"–ú–æ–ª–æ–¥—ñ–∂–Ω–∏–π –ø–∞–∫–µ—Ç","gm_energy":"‚ö° –ï–Ω–µ—Ä–≥—ñ—è","gm_energy_q":"–ï–Ω–µ—Ä–≥—ñ—è (1‚Äì5)?","gm_energy_done":"–ó–∞–Ω–æ—Ç—É–≤–∞–≤ –µ–Ω–µ—Ä–≥—ñ—é ‚Äî –¥—è–∫—É—é!","gm_evening_btn":"‚è∞ –ù–∞–≥–∞–¥–∞—Ç–∏ –≤–≤–µ—á–µ—Ä—ñ",
        "hydrate_btn":"üíß –ì—ñ–¥—Ä–∞—Ç–∞—Ü—ñ—è","hydrate_nudge":"üíß –ß–∞—Å –¥–ª—è —Å–∫–ª—è–Ω–∫–∏ –≤–æ–¥–∏","skintip_btn":"üß¥ –ü–æ—Ä–∞–¥–∞ –¥–ª—è —à–∫—ñ—Ä–∏/—Ç—ñ–ª–∞","skintip_sent":"–ù–∞–¥—ñ—Å–ª–∞–Ω–æ.","daily_tip_prefix":"üçé –ü—ñ–¥–∫–∞–∑–∫–∞ –¥–Ω—è:",
        "challenge_btn":"üéØ –ß–µ–ª–µ–Ω–¥–∂ 7 –¥–Ω—ñ–≤ (–≤–æ–¥–∞)","challenge_started":"–ß–µ–ª–µ–Ω–¥–∂ –∑–∞–ø—É—â–µ–Ω–æ!","challenge_progress":"–ü—Ä–æ–≥—Ä–µ—Å: {d}/{len} –¥–Ω—ñ–≤.",
        "cycle_btn":"ü©∏ –¶–∏–∫–ª","cycle_consent":"–í—ñ–¥—Å—Ç–µ–∂—É–≤–∞—Ç–∏ —Ü–∏–∫–ª —ñ –º‚Äô—è–∫—ñ –ø–æ—Ä–∞–¥–∏?","cycle_ask_last":"–î–∞—Ç–∞ –æ—Å—Ç–∞–Ω–Ω—ñ—Ö –º–µ–Ω—Å—Ç—Ä—É–∞—Ü—ñ–π (–†–†–†–†-–ú–ú-–î–î):","cycle_ask_len":"–°–µ—Ä–µ–¥–Ω—è –¥–æ–≤–∂–∏–Ω–∞ —Ü–∏–∫–ª—É (–Ω–∞–ø—Ä., 28):","cycle_saved":"–ó–±–µ—Ä–µ–∂–µ–Ω–æ.",
        "quiet_saved":"–¢–∏—Ö—ñ –≥–æ–¥–∏–Ω–∏ –∑–±–µ—Ä–µ–∂–µ–Ω–æ: {qh}","set_quiet_btn":"üåô –¢–∏—Ö—ñ –≥–æ–¥–∏–Ω–∏","ask_quiet":"–í–≤–µ–¥—ñ—Ç—å –ì–ì:–•–•-–ì–ì:–•–• (–ª–æ–∫–∞–ª—å–Ω–æ), –Ω–∞–ø—Ä. 22:00-08:00",
        "evening_intro":"–í–µ—á—ñ—Ä–Ω—ñ–π —á–µ–∫-—ñ–Ω:","evening_tip_btn":"ü™Ñ –ü–æ—Ä–∞–¥–∞ –¥–Ω—è","evening_set":"–í–µ—á—ñ—Ä–Ω—ñ–π —á–µ–∫-—ñ–Ω –Ω–∞ {t} (–ª–æ–∫–∞–ª—å–Ω–æ).","evening_off":"–í–∏–º–∫–Ω–µ–Ω–æ.",
        "ask_consent":"–ú–æ–∂—É –Ω–∞–≥–∞–¥–∞—Ç–∏ –ø—ñ–∑–Ω—ñ—à–µ, —â–æ–± –¥—ñ–∑–Ω–∞—Ç–∏—Å—å —è–∫ –≤–∏?","yes":"–¢–∞–∫","no":"–ù—ñ",
        "unknown":"–ü–æ—Ç—Ä—ñ–±–Ω–æ —Ç—Ä–æ—Ö–∏ –±—ñ–ª—å—à–µ –¥–µ—Ç–∞–ª–µ–π: –¥–µ —Å–∞–º–µ —ñ —è–∫ –¥–æ–≤–≥–æ?","thanks":"–ü—Ä–∏–π–Ω—è—Ç–æ üôå","back":"‚óÄ –ù–∞–∑–∞–¥","exit":"–í–∏–π—Ç–∏",
        "paused_on":"–ù–∞–≥–∞–¥—É–≤–∞–Ω–Ω—è –ø—Ä–∏–∑—É–ø–∏–Ω–µ–Ω—ñ. /resume ‚Äî —É–≤—ñ–º–∫–Ω—É—Ç–∏.","paused_off":"–ó–Ω–æ–≤—É —É–≤—ñ–º–∫–Ω–µ–Ω–æ.","deleted":"–£—Å—ñ –¥–∞–Ω—ñ –≤–∏–¥–∞–ª–µ–Ω–æ. /start ‚Äî –ø–æ—á–∞—Ç–∏ –∑–Ω–æ–≤—É.",
        "life_today":"–°—å–æ–≥–æ–¥–Ω—ñ —Ç–≤—ñ–π {n}-–π –¥–µ–Ω—å –∂–∏—Ç—Ç—è üéâ. –ú–µ—Ç–∞ ‚Äî 36 500 (100 —Ä–æ–∫—ñ–≤).","life_percent":"–¢–∏ –ø—Ä–æ–π—à–æ–≤ {p}% —à–ª—è—Ö—É –¥–æ 100 —Ä–æ–∫—ñ–≤.","life_estimate":"(–æ—Ä—ñ—î–Ω—Ç–æ–≤–Ω–æ –∑–∞ –≤—ñ–∫–æ–º ‚Äî –≤–∫–∞–∂–∏ birth_date –¥–ª—è —Ç–æ—á–Ω–æ—Å—Ç—ñ)",
        "px":"–ó —É—Ä–∞—Ö—É–≤–∞–Ω–Ω—è–º –ø—Ä–æ—Ñ—ñ–ª—é: {sex}, {age} —Ä.; –º–µ—Ç–∞ ‚Äî {goal}.",
        "act_rem_4h":"‚è∞ –ß–µ—Ä–µ–∑ 4 –≥–æ–¥","act_rem_eve":"‚è∞ –°—å–æ–≥–æ–¥–Ω—ñ –≤–≤–µ—á–µ—Ä—ñ","act_rem_morn":"‚è∞ –ó–∞–≤—Ç—Ä–∞ –∑—Ä–∞–Ω–∫—É","act_save_episode":"üíæ –ó–±–µ—Ä–µ–≥—Ç–∏ –µ–ø—ñ–∑–æ–¥","act_ex_neck":"üßò 5-—Ö–≤ –¥–ª—è —à–∏—ó","act_er":"üöë –ö–æ–ª–∏ —Ç–µ—Ä–º—ñ–Ω–æ–≤–æ",
    },
}
T["es"] = T["en"]


# --- Localization of profile values & prefix ---
LOCALIZE_MAP = {
    "sex": {
        "ru": {"male":"–º—É–∂—Å–∫–æ–π","female":"–∂–µ–Ω—Å–∫–∏–π","other":"–¥—Ä—É–≥–æ–π"},
        "uk": {"male":"—á–æ–ª–æ–≤—ñ—á–∞","female":"–∂—ñ–Ω–æ—á–∞","other":"—ñ–Ω—à–∞"},
        "en": {"male":"male","female":"female","other":"other"},
        "es": {"male":"hombre","female":"mujer","other":"otro"},
    },
    "goal": {
        "ru": {"energy":"—ç–Ω–µ—Ä–≥–∏—è","sleep":"—Å–æ–Ω","weight":"–≤–µ—Å","strength":"—Å–∏–ª–∞","longevity":"–¥–æ–ª–≥–æ–ª–µ—Ç–∏–µ"},
        "uk": {"energy":"–µ–Ω–µ—Ä–≥—ñ—è","sleep":"—Å–æ–Ω","weight":"–≤–∞–≥–∞","strength":"—Å–∏–ª–∞","longevity":"–¥–æ–≤–≥–æ–ª—ñ—Ç—Ç—è"},
        "en": {"energy":"energy","sleep":"sleep","weight":"weight","strength":"strength","longevity":"longevity"},
        "es": {"energy":"energ√≠a","sleep":"sue√±o","weight":"peso","strength":"fuerza","longevity":"longevidad"},
    },
    "activity": {
        "ru": {"low":"–Ω–∏–∑–∫–∞—è","mid":"—Å—Ä–µ–¥–Ω—è—è","high":"–≤—ã—Å–æ–∫–∞—è","sport":"—Å–ø–æ—Ä—Ç"},
        "uk": {"low":"–Ω–∏–∑—å–∫–∞","mid":"—Å–µ—Ä–µ–¥–Ω—è","high":"–≤–∏—Å–æ–∫–∞","sport":"—Å–ø–æ—Ä—Ç"},
        "en": {"low":"low","mid":"medium","high":"high","sport":"sport"},
        "es": {"low":"baja","mid":"media","high":"alta","sport":"deporte"},
    },
    "diet_focus": {
        "ru":{"balanced":"—Å–±–∞–ª–∞–Ω—Å.","lowcarb":"–Ω–∏–∑–∫–æ—É–≥–ª.","plant":"—Ä–∞—Å—Ç–∏—Ç.","irregular":"–Ω–µ—Ä–µ–≥—É–ª."},
        "uk":{"balanced":"–∑–±–∞–ª–∞–Ω—Å.","lowcarb":"–º–∞–ª–æ–≤—É–≥–ª.","plant":"—Ä–æ—Å–ª–∏–Ω–Ω–µ","irregular":"–Ω–µ—Ä–µ–≥—É–ª."},
        "en":{"balanced":"balanced","lowcarb":"low-carb","plant":"plant-based","irregular":"irregular"},
        "es":{"balanced":"equilibrada","lowcarb":"baja carb.","plant":"vegetal","irregular":"irregular"},
    }
}

def localize_value(lang: str, field: str, value: str) -> str:
    v = (value or "").strip().lower()
    m = LOCALIZE_MAP.get(field, {}).get(lang, {})
    return m.get(v, value)

def detect_lang_from_text(text: str, fallback: str) -> str:
    s = (text or "").strip()
    if not s: return fallback
    low = s.lower()
    if re.search(r"[–∞-—è—ë—ñ—ó—î“ë]", low):
        return "uk" if re.search(r"[—ñ—ó—î“ë]", low) else "ru"
    try:
        return norm_lang(detect(s))
    except Exception:
        return fallback

def personalized_prefix(lang: str, profile: dict) -> str:
    sex_raw = (profile.get("sex") or "")
    goal_raw = (profile.get("goal") or "")
    age_raw  = str(profile.get("age") or "")
    m = re.search(r"\d+", age_raw or "")
    age = m.group(0) if m else ""
    sex  = localize_value(lang, "sex", sex_raw)
    goal = localize_value(lang, "goal", goal_raw)
    if sum(bool(x) for x in (sex, age, goal)) >= 2:
        tpl = (T.get(lang) or T["en"]).get("px", T["en"]["px"])
        return tpl.format(sex=sex or "‚Äî", age=age or "‚Äî", goal=goal or "‚Äî")
    return ""


# ---------------- Helpers ----------------
def utcnow() -> datetime: return datetime.now(timezone.utc)
def iso(dt: Optional[datetime]) -> str:
    return "" if not dt else dt.astimezone(timezone.utc).strftime("%Y-%m-%d %H:%M:%S%z")

def profile_is_incomplete(profile_row: dict) -> bool:
    keys = ["sex","age","goal"]
    return sum(1 for k in keys if str(profile_row.get(k) or "").strip()) < 2

def age_to_band(age: int) -> str:
    if age <= 0: return "unknown"
    if age <= 25: return "18‚Äì25"
    if age <= 35: return "26‚Äì35"
    if age <= 45: return "36‚Äì45"
    if age <= 60: return "46‚Äì60"
    return "60+"

def _ratio(a: str, b: str) -> float:
    return SequenceMatcher(None, (a or "").lower(), (b or "").lower()).ratio()


# -------- Sessions (runtime) ----------
sessions: Dict[int, dict] = {}  # ephemeral state per user


# -------- Sheets (with memory fallback) --------
SHEETS_ENABLED = True
ss = None
ws_feedback = ws_users = ws_profiles = ws_episodes = ws_reminders = ws_daily = None
ws_rules = ws_challenges = None

GSPREAD_CLIENT: Optional[gspread.client.Client] = None
SPREADSHEET_ID_FOR_INTAKE: str = ""

def _ws_headers(ws):
    try: return ws.row_values(1) if ws else []
    except Exception: return []

def _ws_ensure_columns(ws, desired_headers: List[str]):
    try:
        current = _ws_headers(ws)
        if not current:
            if ws.col_count < len(desired_headers):
                ws.add_cols(len(desired_headers) - ws.col_count)
            ws.append_row(desired_headers); return
        if ws.col_count < len(desired_headers):
            ws.add_cols(len(desired_headers) - ws.col_count)
        missing = [h for h in desired_headers if h not in current]
        if missing:
            for h in missing:
                ws.update_cell(1, len(current)+1, h)
                current.append(h)
    except Exception as e:
        logging.warning(f"ensure columns failed for {getattr(ws,'title','?')}: {e}")

def _sheets_init():
    global SHEETS_ENABLED, ss, ws_feedback, ws_users, ws_profiles, ws_episodes, ws_reminders, ws_daily, ws_rules, ws_challenges
    global GSPREAD_CLIENT, SPREADSHEET_ID_FOR_INTAKE
    try:
        scope = ["https://spreadsheets.google.com/feeds", "https://www.googleapis.com/auth/drive"]
        creds_json = os.getenv("GOOGLE_CREDENTIALS_JSON")
        if not creds_json: raise RuntimeError("GOOGLE_CREDENTIALS_JSON is not set")
        creds = json.loads(creds_json)
        credentials = ServiceAccountCredentials.from_json_keyfile_dict(creds, scope)
        gclient = gspread.authorize(credentials)
        GSPREAD_CLIENT = gclient

        try:
            ss = gclient.open_by_key(SHEET_ID) if SHEET_ID else gclient.open(SHEET_NAME)
        except SpreadsheetNotFound:
            if ALLOW_CREATE_SHEET: ss = gclient.create(SHEET_NAME)
            else: raise

        SPREADSHEET_ID_FOR_INTAKE = getattr(ss, "id", SHEET_ID or "")

        def _ensure_ws(title: str, headers: List[str]):
            try:
                ws = ss.worksheet(title)
            except WorksheetNotFound:
                ws = ss.add_worksheet(title=title, rows=4000, cols=max(60, len(headers)))
                ws.append_row(headers)
            if not ws.get_all_values(): ws.append_row(headers)
            _ws_ensure_columns(ws, headers)
            return ws

        ws_feedback   = _ensure_ws("Feedback",   ["timestamp","user_id","name","username","rating","comment"])
        ws_users      = _ensure_ws("Users",      ["user_id","username","lang","consent","tz_offset","checkin_hour","evening_hour","paused","last_seen","last_auto_date","last_auto_count","streak","streak_best","gm_last_date"])
        ws_profiles   = _ensure_ws("Profiles",   [
            "user_id","sex","age","goal","goals","conditions","meds","allergies",
            "sleep","activity","diet","diet_focus","steps_target","habits",
            "cycle_enabled","cycle_last_date","cycle_avg_len","last_cycle_tip_date",
            "quiet_hours","consent_flags","notes","updated_at","city","surgeries","ai_profile","birth_date"
        ])
        ws_episodes   = _ensure_ws("Episodes",   ["episode_id","user_id","topic","started_at","baseline_severity","red_flags","plan_accepted","target","reminder_at","next_checkin_at","status","last_update","notes"])
        ws_daily      = _ensure_ws("DailyCheckins",["timestamp","user_id","mood","energy","comment"])
        ws_rules      = _ensure_ws("Rules",      ["rule_id","topic","segment","trigger","advice_text","citation","last_updated","enabled"])
        ws_challenges = _ensure_ws("Challenges", ["user_id","challenge_id","name","start_date","length_days","days_done","status"])
        ws_reminders  = _ensure_ws("Reminders",  ["id","user_id","text","when_utc","created_at","status"])

        logging.info("Google Sheets connected.")
    except Exception as e:
        SHEETS_ENABLED = False
        logging.error(f"SHEETS disabled (fallback to memory). Reason: {e}")

_sheets_init()

# --------- Memory fallback stores ----------
MEM_USERS: Dict[int, dict] = {}
MEM_PROFILES: Dict[int, dict] = {}
MEM_EPISODES: List[dict] = []
MEM_REMINDERS: List[dict] = []
MEM_FEEDBACK: List[dict] = []
MEM_DAILY: List[dict] = []
MEM_CHALLENGES: List[dict] = []
MEM_RULES: List[dict] = []

def _headers(ws): return _ws_headers(ws)

# -------- Wrappers: Users / Profiles / Daily / Episodes / Reminders / Feedback / Challenges --------
def users_get(uid: int) -> dict:
    if SHEETS_ENABLED:
        try:
            for r in ws_users.get_all_records():
                if str(r.get("user_id")) == str(uid):
                    return r
        except Exception as e:
            logging.warning(f"users_get fallback: {e}")
    return MEM_USERS.get(uid, {})

def users_upsert(uid: int, username: str, lang: str):
    base = {
        "user_id": str(uid), "username": username or "", "lang": lang, "consent": "no",
        "tz_offset": "0", "checkin_hour": DEFAULT_CHECKIN_LOCAL, "evening_hour": "",
        "paused": "no", "last_seen": iso(utcnow()), "last_auto_date": "", "last_auto_count": "0",
        "streak": "0","streak_best":"0","gm_last_date": "",
    }
    if SHEETS_ENABLED:
        try:
            vals = ws_users.get_all_records()
            hdr = _headers(ws_users)
            end_col = gsu.rowcol_to_a1(1, len(hdr)).rstrip("1")
            for i, r in enumerate(vals, start=2):
                if str(r.get("user_id")) == str(uid):
                    merged = {**r, **{k: base[k] for k in base if not str(r.get(k) or "").strip()}}
                    ws_users.update(f"A{i}:{end_col}{i}", [[merged.get(h, "") for h in hdr]])
                    return
            ws_users.append_row([base.get(h, "") for h in hdr]); return
        except Exception as e:
            logging.warning(f"users_upsert -> memory fallback: {e}")
    MEM_USERS[uid] = {**MEM_USERS.get(uid, {}), **base}

def users_set(uid: int, field: str, value: str):
    if SHEETS_ENABLED:
        try:
            vals = ws_users.get_all_records()
            for i, r in enumerate(vals, start=2):
                if str(r.get("user_id")) == str(uid):
                    hdr = _headers(ws_users)
                    if field not in hdr:
                        _ws_ensure_columns(ws_users, hdr + [field]); hdr = _headers(ws_users)
                    ws_users.update_cell(i, hdr.index(field)+1, value); return
        except Exception as e:
            logging.warning(f"users_set -> memory fallback: {e}")
    u = MEM_USERS.setdefault(uid, {}); u[field] = value

def profiles_get(uid: int) -> dict:
    if SHEETS_ENABLED:
        try:
            for r in ws_profiles.get_all_records():
                if str(r.get("user_id")) == str(uid): return r
        except Exception as e:
            logging.warning(f"profiles_get fallback: {e}")
    return MEM_PROFILES.get(uid, {})

def profiles_upsert(uid: int, patch: dict):
    patch = dict(patch or {}); patch["user_id"] = str(uid); patch["updated_at"] = iso(utcnow())
    if SHEETS_ENABLED:
        try:
            vals = ws_profiles.get_all_records(); hdr = _headers(ws_profiles)
            if hdr:
                for k in patch.keys():
                    if k not in hdr:
                        _ws_ensure_columns(ws_profiles, hdr + [k]); hdr = _headers(ws_profiles)
            for i, r in enumerate(vals, start=2):
                if str(r.get("user_id")) == str(uid):
                    merged = {**r, **patch}
                    ws_profiles.update(f"A{i}:{gsu.rowcol_to_a1(i, len(hdr))}", [[merged.get(h, "") for h in hdr]]); return
            ws_profiles.append_row([patch.get(h, "") for h in hdr]); return
        except Exception as e:
            logging.warning(f"profiles_upsert -> memory fallback: {e}")
    MEM_PROFILES[uid] = {**MEM_PROFILES.get(uid, {}), **patch}

def feedback_add(ts: str, uid: int, name: str, username: str, rating: str, comment: str):
    row = {"timestamp":ts, "user_id":str(uid), "name":name, "username":username, "rating":rating, "comment":comment}
    if SHEETS_ENABLED:
        try:
            hdr = _headers(ws_feedback); ws_feedback.append_row([row.get(h, "") for h in hdr]); return
        except Exception as e:
            logging.warning(f"feedback_add -> memory fallback: {e}")
    MEM_FEEDBACK.append(row)

def daily_add(ts: str, uid: int, mood: str="", comment: str="", energy: Optional[int]=None):
    row = {"timestamp":ts, "user_id":str(uid), "mood":mood, "energy":("" if energy is None else str(energy)), "comment":comment}
    if SHEETS_ENABLED:
        try:
            hdr = _headers(ws_daily); ws_daily.append_row([row.get(h, "") for h in hdr]); return
        except Exception as e:
            logging.warning(f"daily_add -> memory fallback: {e}")
    MEM_DAILY.append(row)

def episode_create(uid: int, topic: str, severity: int=5, red: str="") -> str:
    eid = str(uuid.uuid4())
    row = {"episode_id":eid,"user_id":str(uid),"topic":topic,"started_at":iso(utcnow()),
           "baseline_severity":str(severity),"red_flags":red,"plan_accepted":"","target":"",
           "reminder_at":"","next_checkin_at":"","status":"open","last_update":iso(utcnow()),"notes":""}
    if SHEETS_ENABLED:
        try:
            hdr = _headers(ws_episodes); ws_episodes.append_row([row.get(h, "") for h in hdr])
        except Exception as e:
            logging.warning(f"episode_create -> memory fallback: {e}"); MEM_EPISODES.append(row)
    else: MEM_EPISODES.append(row)
    return eid

def episode_set(eid: str, key: str, val: str):
    if SHEETS_ENABLED:
        try:
            vals = ws_episodes.get_all_records(); hdr = _headers(ws_episodes)
            for i, r in enumerate(vals, start=2):
                if r.get("episode_id") == eid:
                    if key not in hdr: _ws_ensure_columns(ws_episodes, hdr + [key]); hdr=_headers(ws_episodes)
                    row = [r.get(h, "") if h!=key else val for h in hdr]
                    ws_episodes.update(f"A{i}:{gsu.rowcol_to_a1(i,len(hdr))}", [row]); return
        except Exception as e:
            logging.warning(f"episode_set -> memory fallback: {e}")
    for r in MEM_EPISODES:
        if r.get("episode_id")==eid:
            r[key]=val; return

def episode_find_open(uid: int) -> Optional[dict]:
    if SHEETS_ENABLED:
        try:
            for r in ws_episodes.get_all_records():
                if str(r.get("user_id"))==str(uid) and (r.get("status")=="open"):
                    return r
        except Exception as e:
            logging.warning(f"episode_find_open fallback: {e}")
    for r in reversed(MEM_EPISODES):
        if r.get("user_id")==str(uid) and r.get("status")=="open":
            return r
    return None

def reminder_add(uid: int, text: str, when_utc: datetime) -> str:
    rid = str(uuid.uuid4())
    row = {"id":rid,"user_id":str(uid),"text":text,"when_utc":iso(when_utc),"created_at":iso(utcnow()),"status":"open"}
    if SHEETS_ENABLED:
        try:
            hdr = _headers(ws_reminders); ws_reminders.append_row([row.get(h, "") for h in hdr]); return rid
        except Exception as e:
            logging.warning(f"reminder_add -> memory fallback: {e}")
    MEM_REMINDERS.append(row); return rid

def challenge_get(uid: int) -> Optional[dict]:
    if SHEETS_ENABLED:
        try:
            for r in ws_challenges.get_all_records():
                if r.get("user_id")==str(uid) and r.get("status")!="done":
                    return r
        except Exception as e:
            logging.warning(f"challenge_get fallback: {e}")
    for r in MEM_CHALLENGES:
        if r.get("user_id")==str(uid) and r.get("status")!="done":
            return r
    return None

def challenge_start(uid: int, name: str="water7", length_days: int=7):
    row = {"user_id":str(uid),"challenge_id":str(uuid.uuid4()),"name":name,"start_date":iso(utcnow()),
           "length_days":str(length_days),"days_done":"0","status":"active"}
    if SHEETS_ENABLED:
        try:
            hdr = _headers(ws_challenges); ws_challenges.append_row([row.get(h,"") for h in hdr]); return
        except Exception as e:
            logging.warning(f"challenge_start -> memory fallback: {e}")
    MEM_CHALLENGES.append(row)


# ---------- Quickbar & Menus ----------
def quickbar_kb(lang: str) -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup([
        [InlineKeyboardButton(T[lang]["quick_h60"], callback_data="menu|h60")],
        [InlineKeyboardButton(T[lang]["quick_er"], callback_data="menu|er"),
         InlineKeyboardButton(T[lang]["quick_lab"], callback_data="menu|lab")],
        [InlineKeyboardButton(T[lang]["quick_rem"], callback_data="menu|rem")]
    ])

async def show_quickbar(context: ContextTypes.DEFAULT_TYPE, chat_id: int, lang: str, uid: Optional[int]=None, force: bool=False):
    """–ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–∞–Ω–µ–ª—å –∏ –Ω–µ —Å–ø–∞–º–∏–º –µ—ë –ø–æ–≤—Ç–æ—Ä–Ω–æ –≤ —Ä–∞–º–∫–∞—Ö —à–∞–≥–∞ –¥–∏–∞–ª–æ–≥–∞ (–ø–æ sessions[uid]['qb_sent'])."""
    try:
        if uid and not force:
            s = sessions.setdefault(uid, {})
            if s.get("qb_sent"):  # —É–∂–µ –ø–æ–∫–∞–∑—ã–≤–∞–ª–∏ –≤ —ç—Ç–æ–º —à–∞–≥–µ
                return
            s["qb_sent"] = True
        await context.bot.send_message(chat_id, T[lang]["quick_title"], reply_markup=quickbar_kb(lang))
    except Exception as e:
        logging.warning(f"show_quickbar failed: {e}")


def inline_topic_kb(lang: str) -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup([
        [InlineKeyboardButton("‚ö° " + T[lang]["h60_btn"], callback_data="menu|h60")],
        [InlineKeyboardButton("üß™ Lab", callback_data="menu|lab"),
         InlineKeyboardButton("ü©∫ Sleep", callback_data="menu|sleep")],
        [InlineKeyboardButton("ü•ó Food", callback_data="menu|food"),
         InlineKeyboardButton("üèÉ Habits", callback_data="menu|habits")],
    ])


# ---------- Time & Quiet hours ----------
def _user_tz_off(uid: int) -> int:
    try: return int((users_get(uid) or {}).get("tz_offset") or "0")
    except: return 0

def user_local_now(uid: int) -> datetime:
    return datetime.utcnow().replace(tzinfo=timezone.utc) + timedelta(hours=_user_tz_off(uid))

def hhmm_tuple(hhmm: str) -> Tuple[int,int]:
    m = re.match(r"^\s*([01]?\d|2[0-3]):([0-5]\d)\s*$", hhmm or "")
    if not m: return (8,30)
    return (int(m.group(1)), int(m.group(2)))

def local_to_utc_dt(uid: int, local_dt: datetime) -> datetime:
    return local_dt - timedelta(hours=_user_tz_off(uid))

def _user_quiet_hours(uid: int) -> str:
    prof = profiles_get(uid) or {}
    return (prof.get("quiet_hours") or DEFAULT_QUIET_HOURS).strip()

def adjust_out_of_quiet(local_dt: datetime, qh: str) -> datetime:
    m = re.match(r"^\s*([01]?\d|2[0-3]):[0-5]\d-([01]?\d|2[0-3]):[0-5]\d\s*$", qh or "")
    if not m: return local_dt
    start, end = qh.split("-")
    sh, sm = hhmm_tuple(start); eh, em = hhmm_tuple(end)
    st = local_dt.replace(hour=sh, minute=sm, second=0, microsecond=0)
    en = local_dt.replace(hour=eh, minute=em, second=0, microsecond=0)
    if st < en:
        in_quiet = (st <= local_dt < en)
    else:
        in_quiet = (local_dt >= st or local_dt < en)
    return en if in_quiet else local_dt


# ---------- Life metrics ----------
def life_metrics(profile: dict) -> Dict[str,int]:
    b = (profile or {}).get("birth_date","").strip()
    days = None
    if re.match(r"^\d{4}-\d{2}-\d{2}$", b):
        try:
            y,m,d = map(int, b.split("-"))
            bd = datetime(y,m,d,tzinfo=timezone.utc)
            days = (utcnow()-bd).days
        except Exception:
            days = None
    if days is None:
        try: a = int(re.search(r"\d+", str((profile or {}).get("age","") or "0")).group(0))
        except Exception: a = 0
        days = max(0, a*365)
    percent = min(100, round(days/36500*100, 1))
    return {"days_lived": days, "percent_to_100": percent}

def progress_bar(percent: float, width: int=12) -> str:
    fill = int(round(width*percent/100.0))
    return "‚ñà"*fill + "‚ñë"*(width-fill)


# ------------- LLM Router (concise) -------------
SYS_ROUTER = (
    "You are TendAI ‚Äî a concise, warm, professional health & longevity assistant (not a doctor). "
    "Always answer strictly in {lang}. Keep replies short (<=6 lines + up to 4 bullets). "
    "Personalize using the profile (sex/age/goal/conditions, diet_focus, steps_target). "
    "TRIAGE: ask 1‚Äì2 clarifiers first; recommend ER only for clear red flags. "
    "Return JSON ONLY: {\"intent\":\"symptom|nutrition|sleep|labs|habits|longevity|other\","
    "\"assistant_reply\":\"...\",\"followups\":[\"...\"],\"needs_more\":true,\"red_flags\":false,\"confidence\":0.0}"
)

def llm_router_answer(text: str, lang: str, profile: dict) -> dict:
    if not oai:
        clar = {
            "ru":"–ì–¥–µ –∏–º–µ–Ω–Ω–æ –±–æ–ª–∏—Ç –∏ —Å–∫–æ–ª—å–∫–æ –¥–ª–∏—Ç—Å—è? –ï—Å—Ç—å —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞/—Ç—Ä–∞–≤–º–∞?",
            "uk":"–î–µ —Å–∞–º–µ –±–æ–ª–∏—Ç—å —ñ —Å–∫—ñ–ª—å–∫–∏ —Ç—Ä–∏–≤–∞—î? –Ñ —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞/—Ç—Ä–∞–≤–º–∞?",
            "en":"Where exactly is the pain and for how long? Any fever/trauma?",
            "es":"¬øD√≥nde exactamente y desde cu√°ndo? ¬øFiebre/trauma?",
        }[lang]
        return {"intent":"other","assistant_reply":clar,"followups":[clar],"needs_more":True,"red_flags":False,"confidence":0.3}
    sys = SYS_ROUTER.replace("{lang}", lang) + f"\nUserProfile: {json.dumps(profile, ensure_ascii=False)}"
    try:
        resp = oai.chat_completions.create(  # openai>=1.0 style also available; keep compat
            model=OPENAI_MODEL, temperature=0.25, max_tokens=420,
            response_format={"type":"json_object"},
            messages=[{"role":"system","content":sys},{"role":"user","content":text}]
        )
        # For SDK parity
        content = getattr(resp.choices[0].message, "content", None) or getattr(resp.choices[0], "message", {}).get("content","")
        data = json.loads((content or "{}").strip() or "{}")
        if "followups" not in data or data["followups"] is None:
            data["followups"] = []
        return data
    except Exception as e:
        logging.error(f"router LLM error: {e}")
        clar = {
            "ru":"–ì–¥–µ –∏–º–µ–Ω–Ω–æ –∏ –∫–∞–∫ –¥–∞–≤–Ω–æ? –ï—Å—Ç—å –ª–∏ –ø–æ–∫—Ä–∞—Å–Ω–µ–Ω–∏–µ, —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞, —Ç—Ä–∞–≤–º–∞?",
            "uk":"–î–µ —Å–∞–º–µ —ñ —è–∫ –¥–∞–≤–Ω–æ? –Ñ –ø–æ—á–µ—Ä–≤–æ–Ω—ñ–Ω–Ω—è/—Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞/—Ç—Ä–∞–≤–º–∞?",
            "en":"Where exactly and since when? Any redness, fever or injury?",
            "es":"¬øD√≥nde exactamente y desde cu√°ndo? ¬øEnrojecimiento, fiebre o lesi√≥n?",
        }[lang]
        return {"intent":"other","assistant_reply":clar,"followups":[clar],"needs_more":True,"red_flags":False,"confidence":0.3}


# ===== Health60 =====
def _fmt_bullets(items: list) -> str:
    return "\n".join([f"‚Ä¢ {x}" for x in items if isinstance(x, str) and x.strip()])

SYS_H60 = (
    "You are TendAI ‚Äî a concise, warm, professional assistant (not a doctor). "
    "Answer strictly in {lang}. JSON ONLY: {\"causes\":[\"...\"],\"serious\":\"...\",\"do_now\":[\"...\"],\"see_doctor\":[\"...\"]}. "
    "Rules: 2‚Äì4 simple causes; exactly 1 serious item to rule out; 3‚Äì5 concrete do_now steps; 2‚Äì3 see_doctor cues."
)

def health60_make_plan(lang: str, symptom_text: str, profile: dict) -> str:
    fallback_map = {
        "ru": (f"{T['ru']['h60_t1']}:\n‚Ä¢ –ë—ã—Ç–æ–≤—ã–µ –ø—Ä–∏—á–∏–Ω—ã\n{T['ru']['h60_serious']}: ‚Ä¢ –ò—Å–∫–ª—é—á–∏—Ç—å —Ä–µ–¥–∫–∏–µ, –Ω–æ —Å–µ—Ä—å—ë–∑–Ω—ã–µ –ø—Ä–∏ —É—Ö—É–¥—à–µ–Ω–∏–∏\n\n"
               f"{T['ru']['h60_t2']}:\n‚Ä¢ –í–æ–¥–∞ 300‚Äì500 –º–ª\n‚Ä¢ –û—Ç–¥—ã—Ö 15‚Äì20 –º–∏–Ω\n‚Ä¢ –ü—Ä–æ–≤–µ—Ç—Ä–∏–≤–∞–Ω–∏–µ\n\n"
               f"{T['ru']['h60_t3']}:\n‚Ä¢ –£—Ö—É–¥—à–µ–Ω–∏–µ\n‚Ä¢ –í—ã—Å–æ–∫–∞—è —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞/–∫—Ä–∞—Å–Ω—ã–µ —Ñ–ª–∞–≥–∏\n‚Ä¢ –ë–æ–ª—å ‚â•7/10"),
        "uk": (f"{T['uk']['h60_t1']}:\n‚Ä¢ –ü–æ–±—É—Ç–æ–≤—ñ –ø—Ä–∏—á–∏–Ω–∏\n{T['uk']['h60_serious']}: ‚Ä¢ –í–∏–∫–ª—é—á–∏—Ç–∏ —Ä—ñ–¥–∫—ñ—Å–Ω—ñ, –∞–ª–µ —Å–µ—Ä–π–æ–∑–Ω—ñ –ø—Ä–∏ –ø–æ–≥—ñ—Ä—à–µ–Ω–Ω—ñ\n\n"
               f"{T['uk']['h60_t2']}:\n‚Ä¢ –í–æ–¥–∞ 300‚Äì500 –º–ª\n‚Ä¢ –í—ñ–¥–ø–æ—á–∏–Ω–æ–∫ 15‚Äì20 —Ö–≤\n‚Ä¢ –ü—Ä–æ–≤—ñ—Ç—Ä—é–≤–∞–Ω–Ω—è\n\n"
               f"{T['uk']['h60_t3']}:\n‚Ä¢ –ü–æ–≥—ñ—Ä—à–µ–Ω–Ω—è\n‚Ä¢ –í–∏—Å–æ–∫–∞ —Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞/–ø—Ä–∞–ø–æ—Ä—Ü—ñ\n‚Ä¢ –ë—ñ–ª—å ‚â•7/10"),
        "en": (f"{T['en']['h60_t1']}:\n‚Ä¢ Everyday causes\n{T['en']['h60_serious']}: ‚Ä¢ Rule out rare but serious if worsening\n\n"
               f"{T['en']['h60_t2']}:\n‚Ä¢ Drink 300‚Äì500 ml water\n‚Ä¢ 15‚Äì20 min rest\n‚Ä¢ Ventilate\n\n"
               f"{T['en']['h60_t3']}:\n‚Ä¢ Worsening\n‚Ä¢ High fever/red flags\n‚Ä¢ Pain ‚â•7/10"),
    }
    fallback = fallback_map.get(lang, fallback_map["en"])
    if not oai: return fallback
    sys = SYS_H60.replace("{lang}", lang)
    user = {"symptom": (symptom_text or "").strip()[:500],
            "profile": {k: profile.get(k, "") for k in ["sex","age","goal","conditions","meds","sleep","activity","diet","diet_focus","steps_target"]}}
    try:
        resp = oai.chat_completions.create(
            model=OPENAI_MODEL, temperature=0.2, max_tokens=420,
            response_format={"type":"json_object"},
            messages=[{"role":"system","content":sys},{"role":"user","content":json.dumps(user, ensure_ascii=False)}]
        )
        content = getattr(resp.choices[0].message, "content", None) or getattr(resp.choices[0], "message", {}).get("content","")
        data = json.loads((content or "{}").strip() or "{}")
        causes  = _fmt_bullets(data.get("causes") or [])
        serious = (data.get("serious") or "").strip()
        do_now  = _fmt_bullets(data.get("do_now") or [])
        see_doc = _fmt_bullets(data.get("see_doctor") or [])
        parts = []
        if causes:  parts.append(f"{T[lang]['h60_t1']}:\n{causes}")
        if serious: parts.append(f"{T[lang]['h60_serious']}: {serious}")
        if do_now:  parts.append(f"\n{T[lang]['h60_t2']}:\n{do_now}")
        if see_doc: parts.append(f"\n{T[lang]['h60_t3']}:\n{see_doc}")
        return "\n".join(parts).strip()
    except Exception as e:
        logging.error(f"health60 LLM error: {e}")
        return fallback


# ---------- Lightweight content helpers ----------
def _get_skin_tip(lang: str, sex: str, age: int) -> str:
    pool_ru = [
        "–ú—è–≥–∫–æ–µ SPF –∫–∞–∂–¥—ã–π –¥–µ–Ω—å ‚Äî —Å–∞–º–∞—è –Ω–µ–¥–æ–æ—Ü–µ–Ω—ë–Ω–Ω–∞—è –∏–Ω–≤–µ—Å—Ç–∏—Ü–∏—è –≤ –∫–æ–∂—É.",
        "–î—É—à: —Ç—ë–ø–ª–∞—è –≤–æ–¥–∞, –Ω–µ –≥–æ—Ä—è—á–∞—è; 3‚Äì5 –º–∏–Ω—É—Ç ‚Äî –∫–æ–∂–∞ —Å–∫–∞–∂–µ—Ç —Å–ø–∞—Å–∏–±–æ.",
        "–£–º—ã–≤–∞–ª–∫–∞ –±–µ–∑ SLS, —É–≤–ª–∞–∂–Ω—è—é—â–∏–π –∫—Ä–µ–º —Å—Ä–∞–∑—É –ø–æ—Å–ª–µ –≤–æ–¥—ã."
    ]
    pool_en = [
        "Daily light SPF is the most underrated skin investment.",
        "Keep showers warm, not hot; 3‚Äì5 minutes protects your skin barrier.",
        "Use a gentle cleanser and moisturize right after water."
    ]
    pools = {"ru": pool_ru, "uk": pool_ru, "en": pool_en, "es": pool_en}
    return random.choice(pools.get(lang, pool_en))

def _get_daily_tip(profile: dict, lang: str) -> str:
    base = {
        "ru": ["1 –º–∏–Ω—É—Ç—É –¥—ã—Ö–∞–Ω–∏—è 4-6 ‚Äî –∏ –ø—É–ª—å—Å —Å–ø–æ–∫–æ–π–Ω–µ–µ.", "–°—Ç–∞–∫–∞–Ω –≤–æ–¥—ã —Ä—è–¥–æ–º ‚Äî –≥–ª–æ—Ç–æ–∫ –∫–∞–∂–¥—ã–π —Ä–∞–∑, –∫–∞–∫ —Ä–∞–∑–±–ª–æ–∫–∏—Ä—É–µ—à—å —Ç–µ–ª–µ—Ñ–æ–Ω."],
        "uk": ["1 —Ö–≤–∏–ª–∏–Ω–∞ –¥–∏—Ö–∞–Ω–Ω—è 4-6 ‚Äî –ø—É–ª—å—Å —Å–ø–æ–∫—ñ–π–Ω—ñ—à–∏–π.", "–°–∫–ª—è–Ω–∫–∞ –≤–æ–¥–∏ –ø–æ—Ä—É—á ‚Äî –∫–æ–≤—Ç–æ–∫ —â–æ—Ä–∞–∑—É —è–∫ —Ä–æ–∑–±–ª–æ–∫–æ–≤—É—î—à —Ç–µ–ª–µ—Ñ–æ–Ω."],
        "en": ["Try 1 minute of 4-6 breathing ‚Äî heart rate calms down.", "Keep a glass of water nearby ‚Äî sip when you unlock your phone."]
    }
    return random.choice(base.get(lang, base["en"]))


# ---------- CARE engine (habits memory & nudges) ----------
def _ai_obj(profile: dict) -> dict:
    try:
        raw = profile.get("ai_profile") or "{}"
        return json.loads(raw) if isinstance(raw, str) else (raw or {})
    except Exception:
        return {}

def _ai_get(profile: dict, key: str, default=None):
    return _ai_obj(profile).get(key, default)

def _ai_set(uid: int, key: str, value):
    p = profiles_get(uid) or {}
    obj = _ai_obj(p); obj[key] = value
    profiles_upsert(uid, {"ai_profile": json.dumps(obj, ensure_ascii=False)})

def learn_from_text(uid: int, text: str):
    """–û—á–µ–Ω—å –ª—ë–≥–∫–∞—è —ç–≤—Ä–∏—Å—Ç–∏–∫–∞ ‚Äî —Å—á–∏—Ç–∞–µ–º —É–ø–æ–º–∏–Ω–∞–Ω–∏—è (–∫–æ—Ñ–µ–∏–Ω/—Å–æ–Ω/–≥–æ–ª–æ–≤–∞/–≤–æ–¥–∞)."""
    low = (text or "").lower()
    p = profiles_get(uid) or {}
    obj = _ai_obj(p)
    def inc(k, dv=1): obj[k] = int(obj.get(k, 0)) + dv
    if any(w in low for w in ["–∫–æ—Ñ–µ","coffee","espresso","–∫–∞–ø—É—á–∏–Ω–æ","latte"]): inc("caf_mentions")
    if any(w in low for w in ["–≥–æ–ª–æ–≤–∞","headache","–º–∏–≥—Ä–µ–Ω—å","migraine"]): inc("headache_mentions")
    if any(w in low for w in ["—Å–æ–Ω","sleep","insomnia","–±–µ—Å—Å–æ–Ω"]): inc("sleep_mentions")
    if any(w in low for w in ["–≤–æ–¥–∞","hydrate","–∂–∞–∂–¥–∞","water"]): inc("water_prompt")
    profiles_upsert(uid, {"ai_profile": json.dumps(obj, ensure_ascii=False)})

def life_stage_from_profile(profile: dict) -> str:
    try:
        a = int(re.search(r"\d+", str(profile.get("age","") or "0")).group(0))
    except Exception:
        a = 0
    if a <= 25: return "20s"
    if a <= 40: return "30s"
    if a <= 55: return "40s-50s"
    return "60+"

def build_care_nudge(uid: int, lang: str) -> str:
    p = profiles_get(uid) or {}
    stage = life_stage_from_profile(p)
    ai = _ai_obj(p)
    if int(ai.get("headache_mentions",0)) >= 2:
        return {"ru":"–ó–∞–º–µ—Ç—å —Ç—Ä–∏–≥–≥–µ—Ä—ã –≥–æ–ª–æ–≤–Ω–æ–π –±–æ–ª–∏: –∫–æ—Ñ–µ–∏–Ω, —ç–∫—Ä–∞–Ω, –Ω–µ–¥–æ—Å—ã–ø ‚Äî —Å–µ–≥–æ–¥–Ω—è –ø–æ–ø—Ä–æ–±—É–π 10-–º–∏–Ω –ø—Ä–æ–≥—É–ª–∫—É –±–µ–∑ —Ç–µ–ª–µ—Ñ–æ–Ω–∞.",
                "uk":"–ó–≤–µ—Ä–Ω–∏ —É–≤–∞–≥—É –Ω–∞ —Ç—Ä–∏–≥–µ—Ä–∏ –≥–æ–ª–æ–≤–Ω–æ–≥–æ –±–æ–ª—é: –∫–æ—Ñ–µ—ó–Ω, –µ–∫—Ä–∞–Ω, –Ω–µ–¥–æ—Å–∏–ø ‚Äî —Å—å–æ–≥–æ–¥–Ω—ñ 10-—Ö–≤ –ø—Ä–æ–≥—É–ª—è–Ω–∫–∞ –±–µ–∑ —Ç–µ–ª–µ—Ñ–æ–Ω—É.",
                "en":"Track headache triggers: caffeine, screens, poor sleep ‚Äî try a 10-min walk phone-free today.",
                "es":"Detecta desencadenantes de dolor de cabeza: cafe√≠na, pantallas, sue√±o ‚Äî camina 10 min sin m√≥vil."}[lang]
    if stage=="20s":
        return {"ru":"‚ö° –ú–∏–Ω–∏-—á–µ–ª–ª–µ–Ω–¥–∂: 2 —Å—Ç–∞–∫–∞–Ω–∞ –≤–æ–¥—ã –¥–æ –ø–æ–ª—É–¥–Ω—è ‚Äî –æ—Ç–º–µ—Ç—å —Ä–µ–∞–∫—Ü–∏—é —ç–Ω–µ—Ä–≥–∏–∏.",
                "uk":"‚ö° –ú—ñ–Ω—ñ-—á–µ–ª–µ–Ω–¥–∂: 2 —Å–∫–ª—è–Ω–∫–∏ –≤–æ–¥–∏ –¥–æ –ø–æ–ª—É–¥–Ω—è ‚Äî –≤—ñ–¥–º—ñ—Ç—å –µ–Ω–µ—Ä–≥—ñ—é.",
                "en":"‚ö° Mini-challenge: 2 glasses of water before noon ‚Äî notice energy boost.",
                "es":"‚ö° Mini-reto: 2 vasos de agua antes del mediod√≠a ‚Äî nota la energ√≠a."}[lang]
    return f"{T[lang]['daily_tip_prefix']} {_get_daily_tip(p, lang)}"


# ---------- Auto-message limiter (unified) ----------
def _auto_allowed(uid: int) -> bool:
    today = datetime.utcnow().date().isoformat()
    u = users_get(uid) or {}
    last = (u.get("last_auto_date") or "")
    cnt = int(str(u.get("last_auto_count") or "0") or "0")
    if last != today:
        users_set(uid, "last_auto_date", today)
        users_set(uid, "last_auto_count", "0")
        cnt = 0
    return cnt < AUTO_MAX_PER_DAY

def _auto_inc(uid: int):
    today = datetime.utcnow().date().isoformat()
    u = users_get(uid) or {}
    last = (u.get("last_auto_date") or "")
    cnt = int(str(u.get("last_auto_count") or "0") or "0")
    if last != today:
        users_set(uid, "last_auto_date", today); users_set(uid, "last_auto_count", "1")
    else:
        users_set(uid, "last_auto_count", str(cnt+1))


# ---------- Scheduling (unified; quiet hours respected) ----------
def _remove_jobs(app, name: str):
    if not getattr(app, "job_queue", None):
        return
    for j in list(app.job_queue.jobs()):
        if j.name == name:
            j.schedule_removal()

def _run_daily(app, name: str, hour_local: int, minute_local: int, tz_off: int, data: dict, callback):
    if not getattr(app, "job_queue", None):
        return
    _remove_jobs(app, name)
    utc_h = (hour_local - tz_off) % 24
    t = dtime(hour=utc_h, minute=minute_local, tzinfo=timezone.utc)
    app.job_queue.run_daily(callback, time=t, data=data, name=name)

def schedule_daily_checkin(app, uid: int, tz_off: int, hhmm: str, lang: str):
    h, m = hhmm_tuple(hhmm)
    _run_daily(app, f"gm_{uid}", h, m, tz_off, {"user_id": uid, "kind": "gm"}, job_gm)

def schedule_evening_checkin(app, uid: int, tz_off: int, hhmm: str, lang: str):
    h, m = hhmm_tuple(hhmm)
    _run_daily(app, f"eve_{uid}", h, m, tz_off, {"user_id": uid, "kind": "eve"}, job_evening)

async def job_gm(context: ContextTypes.DEFAULT_TYPE):
    d = context.job.data or {}
    uid = d.get("user_id")
    lang = norm_lang((users_get(uid) or {}).get("lang") or "en")
    if not _auto_allowed(uid):  # –ª–∏–º–∏—Ç–µ—Ä
        return
    local_now = user_local_now(uid)
    if adjust_out_of_quiet(local_now, _user_quiet_hours(uid)) != local_now:
        return  # —Ç–∏—Ö–∏–µ —á–∞—Å—ã
    kb = InlineKeyboardMarkup([
        [InlineKeyboardButton(T[lang]["gm_excellent"], callback_data="gm|mood|excellent"),
         InlineKeyboardButton(T[lang]["gm_ok"],        callback_data="gm|mood|ok")],
        [InlineKeyboardButton(T[lang]["gm_tired"],     callback_data="gm|mood|tired"),
         InlineKeyboardButton(T[lang]["gm_pain"],      callback_data="gm|mood|pain")],
        [InlineKeyboardButton(T[lang]["gm_skip"],      callback_data="gm|skip")],
        [InlineKeyboardButton(T[lang]["mood_note"],    callback_data="gm|note")]
    ])
    try:
        await context.bot.send_message(uid, T[lang]["daily_gm"], reply_markup=kb)
        _auto_inc(uid)
    except Exception as e:
        logging.warning(f"job_gm send failed: {e}")

async def job_evening(context: ContextTypes.DEFAULT_TYPE):
    d = context.job.data or {}
    uid = d.get("user_id")
    lang = norm_lang((users_get(uid) or {}).get("lang") or "en")
    if not _auto_allowed(uid):
        return
    local_now = user_local_now(uid)
    if adjust_out_of_quiet(local_now, _user_quiet_hours(uid)) != local_now:
        return
    kb = InlineKeyboardMarkup([
        [InlineKeyboardButton(T[lang]["evening_tip_btn"], callback_data="eve|tip")],
        [InlineKeyboardButton(T[lang]["hydrate_btn"],     callback_data="water|nudge")]
    ])
    try:
        await context.bot.send_message(uid, T[lang]["evening_intro"], reply_markup=kb)
        _auto_inc(uid)
    except Exception as e:
        logging.warning(f"job_evening send failed: {e}")

async def job_oneoff_reminder(context: ContextTypes.DEFAULT_TYPE):
    d = context.job.data or {}
    uid = d.get("user_id")
    rid = d.get("reminder_id")
    lang = norm_lang((users_get(uid) or {}).get("lang") or "en")
    # —á–∏—Ç–∞–µ–º —Ç–µ–∫—Å—Ç –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è
    text = None
    if SHEETS_ENABLED and ws_reminders:
        try:
            vals = ws_reminders.get_all_records()
            for r in vals:
                if r.get("id")==rid:
                    text = r.get("text"); break
        except Exception:
            pass
    if not text:
        for r in MEM_REMINDERS:
            if r.get("id")==rid: text = r.get("text"); break
    try:
        await context.bot.send_message(uid, f"‚è∞ {text or T[lang]['thanks']}")
    except Exception:
        pass

def schedule_oneoff_local(app, uid: int, local_after_hours: float, text: str):
    """–†–∞–∑–æ–≤–æ–µ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ —á–µ—Ä–µ–∑ N —á–∞—Å–æ–≤ (–ª–æ–∫–∞–ª—å–Ω–æ, —Å —Ç–∏—Ö–∏–º–∏ —á–∞—Å–∞–º–∏)."""
    now_local = user_local_now(uid)
    when_local = now_local + timedelta(hours=local_after_hours)
    when_local = adjust_out_of_quiet(when_local, _user_quiet_hours(uid))
    when_utc = local_to_utc_dt(uid, when_local)
    rid = reminder_add(uid, text, when_utc)
    if getattr(app, "job_queue", None):
        app.job_queue.run_once(job_oneoff_reminder, when=(when_utc - utcnow()), data={"user_id":uid, "reminder_id":rid})
    return rid


# ---------- Rules (evidence-based) ----------
def rules_lookup(topic: str, segment: str, lang: str) -> Optional[str]:
    """–ò—â–µ–º –≥–æ—Ç–æ–≤—ã–π —Å–æ–≤–µ—Ç –∏–∑ –ª–∏—Å—Ç–∞ Rules (–¥–æ–∫–∞–∑–∞—Ç–µ–ª—å–Ω–∞—è –±–∞–∑–∞)."""
    try:
        if SHEETS_ENABLED and ws_rules:
            rows = ws_rules.get_all_records()
            for r in rows:
                if (r.get("enabled","").strip().lower() in {"1","true","yes"}) and \
                   (r.get("topic","").strip().lower() == (topic or "").strip().lower()):
                    seg = (r.get("segment") or "").strip().lower()
                    if not seg or seg == (segment or "").strip().lower():
                        txt = (r.get("advice_text") or "").strip()
                        if not txt:
                            continue
                        m = re.search(r"\[\[\s*"+re.escape(lang)+r"\s*:(.*?)\]\]", txt, re.DOTALL)
                        if m:
                            return m.group(1).strip()
                        return txt
    except Exception as e:
        logging.warning(f"rules_lookup fallback: {e}")
    return None


# ---------- Gentle one-liners (–ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã–µ –∫–æ—Ä–æ—Ç–∫–∏–µ –ø–æ–¥—Å–∫–∞–∑–∫–∏) ----------
def tiny_care_tip(lang: str, mood: str, profile: dict) -> str:
    if lang == "ru":
        if mood == "excellent": return "üî• –û—Ç–ª–∏—á–Ω–æ! –°–æ—Ö—Ä–∞–Ω–∏–º —Ä–∏—Ç–º ‚Äî 5 –º–∏–Ω—É—Ç –¥–≤–∏–∂–µ–Ω–∏—è –∫ –∫–æ—Ñ–µ?"
        if mood == "ok":        return "üôÇ 300 –º–ª –≤–æ–¥—ã –∏ 1 –º–∏–Ω—É—Ç—É –¥—ã—Ö–∞–Ω–∏—è 4-6."
        if mood == "tired":     return "üò¥ –ü—Ä–æ–≥—É–ª–∫–∞ 5‚Äì7 –º–∏–Ω + —Å—Ç–∞–∫–∞–Ω –≤–æ–¥—ã."
        if mood == "pain":      return "ü§ï –ù–∞–±–ª—é–¥–∞–µ–º –∑–∞ –±–æ–ª—å—é. –ï—Å–ª–∏ —É—Å–∏–ª–∏–≤–∞–µ—Ç—Å—è ‚Äî ¬´‚ö° 60 —Å–µ–∫¬ª."
        return "üëç –ë–µ—Ä–µ–∂—ë–º —Ç–µ–º–ø –∏ –≤–æ–¥—É —Ä—è–¥–æ–º."
    if lang == "uk":
        if mood == "excellent": return "üî• –ö—Ä—É—Ç–æ! 5 —Ö–≤–∏–ª–∏–Ω —Ä—É—Ö—É –¥–æ –∫–∞–≤–∏?"
        if mood == "ok":        return "üôÇ 300 –º–ª –≤–æ–¥–∏ —ñ 1 —Ö–≤ –¥–∏—Ö–∞–Ω–Ω—è 4-6."
        if mood == "tired":     return "üò¥ –ü—Ä–æ–≥—É–ª—è–Ω–∫–∞ 5‚Äì7 —Ö–≤ + –≤–æ–¥–∞."
        if mood == "pain":      return "ü§ï –Ø–∫—â–æ –ø–æ—Å–∏–ª—é—î—Ç—å—Å—è ‚Äî ¬´‚ö° 60 c¬ª."
        return "üëç –ë–µ—Ä–µ–∂–µ–º–æ —Ç–µ–º–ø —ñ –≤–æ–¥—É –ø–æ—Ä—É—á."
    if mood == "excellent": return "üî• Nice! 5-min walk before coffee?"
    if mood == "ok":        return "üôÇ 300 ml water + 1-min 4-6 breathing."
    if mood == "tired":     return "üò¥ Try 5‚Äì7 min walk + water."
    if mood == "pain":      return "ü§ï If worsening, tap ‚Äú‚ö° 60s‚Äù."
    return "üëç Keep the pace and keep water nearby."


# ---------- Challenge helpers ----------
def _challenge_tick(uid: int) -> Optional[str]:
    ch = challenge_get(uid)
    if not ch:
        return None
    try:
        done = int(ch.get("days_done") or "0")
        length = int(ch.get("length_days") or "7")
    except Exception:
        done, length = 0, 7
    done = min(length, done + 1)
    if SHEETS_ENABLED and ws_challenges:
        try:
            vals = ws_challenges.get_all_records()
            for i, r in enumerate(vals, start=2):
                if r.get("user_id")==str(uid) and r.get("challenge_id")==ch.get("challenge_id"):
                    ws_challenges.update_cell(i, ( _headers(ws_challenges).index("days_done")+1 ), str(done))
                    if done >= length:
                        ws_challenges.update_cell(i, ( _headers(ws_challenges).index("status")+1 ), "done")
                    break
        except Exception as e:
            logging.warning(f"challenge_tick -> memory fallback: {e}")
            ch["days_done"] = str(done)
            if done >= length: ch["status"] = "done"
    else:
        ch["days_done"] = str(done)
        if done >= length: ch["status"] = "done"
    return f"{T[norm_lang((users_get(uid) or {}).get('lang') or 'en')]['challenge_progress'].format(d=done, len=length)}"


# ---------- Streak helpers ----------
def streak_update(uid: int) -> Optional[str]:
    """–ò–Ω–∫—Ä–µ–º–µ–Ω—Ç streak –ø–æ –¥–∞—Ç–∞–º GM-–æ—Ç–≤–µ—Ç–æ–≤."""
    u = users_get(uid) or {}
    today = datetime.utcnow().date().isoformat()
    last = (u.get("gm_last_date") or "")
    if last == today:
        return None
    try:
        streak = int(u.get("streak") or "0")
        best   = int(u.get("streak_best") or "0")
    except Exception:
        streak, best = 0, 0
    streak = streak + 1 if last else 1
    best = max(best, streak)
    users_set(uid, "streak", str(streak))
    users_set(uid, "streak_best", str(best))
    users_set(uid, "gm_last_date", today)
    if streak in (3, 7, 14, 30):
        lang = norm_lang((u.get("lang") or "en"))
        msg = {
            "ru": f"üî• {streak} –¥–Ω–µ–π –ø–æ–¥—Ä—è–¥! –î–µ—Ä–∂–∏–º –º—è–≥–∫–∏–π —Ç–µ–º–ø.",
            "uk": f"üî• {streak} –¥–Ω—ñ–≤ –ø–æ—Å–ø—ñ–ª—å! –¢—Ä–∏–º–∞—î–º–æ —Ç–µ–º–ø.",
            "en": f"üî• {streak} days in a row! Keep it gentle.",
            "es": f"üî• ¬°{streak} d√≠as seguidos! Suave y constante.",
        }[lang]
        return msg
    return None


# ---------- Cycle helpers ----------
def _calc_cycle_phase(last: str, avg_len: int, today: Optional[date]=None) -> str:
    try:
        y,m,d = map(int, last.split("-"))
        lmp = date(y,m,d)
        t = today or datetime.utcnow().date()
        day = (t - lmp).days % max(24, min(40, avg_len or 28))
        if day <= 5:   return "menstruation"
        if day <= 13:  return "follicular"
        if day <= 16:  return "ovulation"
        return "luteal"
    except Exception:
        return "unknown"

def _cycle_tip(lang: str, phase: str) -> str:
    tips_ru = {
        "menstruation":"–ú—è–≥–∫–∏–π —Ä–µ–∂–∏–º: –≤–æ–¥–∞, —Å–æ–Ω, –ª—ë–≥–∫–∞—è —Ä–∞—Å—Ç—è–∂–∫–∞.",
        "follicular":"–•–æ—Ä–æ—à–µ–µ –≤—Ä–µ–º—è –¥–ª—è —Ç—Ä–µ–Ω–∏—Ä–æ–≤–æ–∫ –∏ –∑–∞–¥–∞—á —Å —Ñ–æ–∫—É—Å–æ–º.",
        "ovulation":"–ë–æ–ª—å—à–µ —ç–Ω–µ—Ä–≥–∏–∏ ‚Äî –Ω–æ —Å–ª–µ–¥–∏ –∑–∞ —Å–Ω–æ–º –∏ –≤–æ–¥–æ–π.",
        "luteal":"–ú–∞–≥–Ω–∏–π/–æ–º–µ–≥–∞ –ø–æ —Å–æ–≥–ª–∞—Å–æ–≤–∞–Ω–∏—é —Å –≤—Ä–∞—á–æ–º, –±–µ—Ä–µ–≥–∏ —Ä–∏—Ç–º."
    }
    tips_en = {
        "menstruation":"Gentle mode: hydration, sleep, light stretching.",
        "follicular":"Great window for training and focus tasks.",
        "ovulation":"Energy is up ‚Äî guard sleep and hydration.",
        "luteal":"Consider magnesium/omega (doctor-approved), keep the pace."
    }
    src = tips_ru if lang in {"ru","uk"} else tips_en
    return src.get(phase, src["follicular"])


# ---------- MINI-INTAKE ----------
MINI_KEYS = ["sex","age","goal","conditions","meds_allergies","activity","diet_focus","steps_target","habits","birth_date"]
MINI_FREE_KEYS: Set[str] = {"meds_allergies","birth_date"}
MINI_STEPS = {
    "sex": {
        "ru":[("–ú—É–∂—Å–∫–æ–π","male"),("–ñ–µ–Ω—Å–∫–∏–π","female"),("–î—Ä—É–≥–æ–µ","other")],
        "en":[("Male","male"),("Female","female"),("Other","other")],
        "uk":[("–ß–æ–ª–æ–≤—ñ—á–∞","male"),("–ñ—ñ–Ω–æ—á–∞","female"),("–Ü–Ω—à–∞","other")],
        "es":[("Hombre","male"),("Mujer","female"),("Otro","other")],
        "label":{"ru":"–ü–æ–ª:","en":"Sex:","uk":"–°—Ç–∞—Ç—å:","es":"Sexo:"}
    },
    "age": {
        "ru":[("18‚Äì25","22"),("26‚Äì35","30"),("36‚Äì45","40"),("46‚Äì60","50"),("60+","65")],
        "en":[("18‚Äì25","22"),("26‚Äì35","30"),("36‚Äì45","40"),("46‚Äì60","50"),("60+","65")],
        "uk":[("18‚Äì25","22"),("26‚Äì35","30"),("36‚Äì45","40"),("46‚Äì60","50"),("60+","65")],
        "es":[("18‚Äì25","22"),("26‚Äì35","30"),("36‚Äì45","40"),("46‚Äì60","50"),("60+","65")],
        "label":{"ru":"–í–æ–∑—Ä–∞—Å—Ç:","en":"Age:","uk":"–í—ñ–∫:","es":"Edad:"}
    },
    "goal": {
        "ru":[("–≠–Ω–µ—Ä–≥–∏—è","energy"),("–°–æ–Ω","sleep"),("–ü–æ—Ö—É–¥–µ–Ω–∏–µ","weight"),("–°–∏–ª–∞","strength"),("–î–æ–ª–≥–æ–ª–µ—Ç–∏–µ","longevity")],
        "en":[("Energy","energy"),("Sleep","sleep"),("Weight","weight"),("Strength","strength"),("Longevity","longevity")],
        "uk":[("–ï–Ω–µ—Ä–≥—ñ—è","energy"),("–°–æ–Ω","sleep"),("–í–∞–≥–∞","weight"),("–°–∏–ª–∞","strength"),("–î–æ–≤–≥–æ–ª—ñ—Ç—Ç—è","longevity")],
        "es":[("Energ√≠a","energy"),("Sue√±o","sleep"),("Peso","weight"),("Fuerza","strength"),("Longevidad","longevity")],
        "label":{"ru":"–ì–ª–∞–≤–Ω–∞—è —Ü–µ–ª—å:","en":"Main goal:","uk":"–ú–µ—Ç–∞:","es":"Objetivo:"}
    },
    "conditions": {
        "ru":[("–ù–µ—Ç","none"),("–°–µ—Ä–¥–µ—á–Ω–æ-—Å–æ—Å—É–¥.","cvd"),("–©–ñ/—ç–Ω–¥–æ–∫—Ä.","endocrine"),("–ñ–ö–¢","gi"),("–ê–ª–ª–µ—Ä–≥–∏—è","allergy"),("–î—Ä—É–≥–æ–µ","other")],
        "en":[("None","none"),("Cardio/vascular","cvd"),("Thyroid/endocrine","endocrine"),("GI","gi"),("Allergy","allergy"),("Other","other")],
        "uk":[("–ù–µ–º–∞—î","none"),("–°–µ—Ä—Ü–µ–≤–æ-—Å—É–¥.","cvd"),("–©–ó/–µ–Ω–¥–æ–∫—Ä.","endocrine"),("–®–ö–¢","gi"),("–ê–ª–µ—Ä–≥—ñ—è","allergy"),("–Ü–Ω—à–µ","other")],
        "es":[("Ninguno","none"),("Cardio","cvd"),("Tiroides","endocrine"),("GI","gi"),("Alergia","allergy"),("Otro","other")],
        "label":{"ru":"–•—Ä–æ–Ω–∏—á–µ—Å–∫–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è:","en":"Chronic conditions:","uk":"–•—Ä–æ–Ω—ñ—á–Ω—ñ —Å—Ç–∞–Ω–∏:","es":"Condiciones cr√≥nicas:"}
    },
    "meds_allergies": {
        "ru":[], "en":[], "uk":[], "es":[],
        "label":{"ru":"–õ–µ–∫–∞—Ä—Å—Ç–≤–∞/–¥–æ–±–∞–≤–∫–∏/–∞–ª–ª–µ—Ä–≥–∏–∏ (–∫–æ—Ä–æ—Ç–∫–æ):","en":"Meds/supplements/allergies (short):","uk":"–õ—ñ–∫–∏/–¥–æ–±–∞–≤–∫–∏/–∞–ª–µ—Ä–≥—ñ—ó (–∫–æ—Ä–æ—Ç–∫–æ):","es":"Medicamentos/suplementos/alergias (corto):"}
    },
    "activity": {
        "ru":[("–ù–∏–∑–∫–∞—è","low"),("–°—Ä–µ–¥–Ω—è—è","mid"),("–í—ã—Å–æ–∫–∞—è","high"),("–°–ø–æ—Ä—Ç","sport")],
        "en":[("Low","low"),("Medium","mid"),("High","high"),("Sport","sport")],
        "uk":[("–ù–∏–∑—å–∫–∞","low"),("–°–µ—Ä–µ–¥–Ω—è","mid"),("–í–∏—Å–æ–∫–∞","high"),("–°–ø–æ—Ä—Ç","sport")],
        "es":[("Baja","low"),("Media","mid"),("Alta","high"),("Deporte","sport")],
        "label":{"ru":"–ê–∫—Ç–∏–≤–Ω–æ—Å—Ç—å:","en":"Activity:","uk":"–ê–∫—Ç–∏–≤–Ω—ñ—Å—Ç—å:","es":"Actividad:"}
    },
    "diet_focus": {
        "ru":[("–°–±–∞–ª–∞–Ω—Å.","balanced"),("–ù–∏–∑–∫–æ—É–≥–ª.","lowcarb"),("–†–∞—Å—Ç–∏—Ç.","plant"),("–ù–µ—Ä–µ–≥—É–ª.","irregular")],
        "en":[("Balanced","balanced"),("Low-carb","lowcarb"),("Plant-based","plant"),("Irregular","irregular")],
        "uk":[("–ó–±–∞–ª–∞–Ω—Å.","balanced"),("–ú–∞–ª–æ–≤—É–≥–ª.","lowcarb"),("–†–æ—Å–ª–∏–Ω–Ω–µ","plant"),("–ù–µ—Ä–µ–≥—É–ª.","irregular")],
        "es":[("Equilibrada","balanced"),("Baja carb.","lowcarb"),("Vegetal","plant"),("Irregular","irregular")],
        "label":{"ru":"–ü–∏—Ç–∞–Ω–∏–µ —á–∞—â–µ –≤—Å–µ–≥–æ:","en":"Diet mostly:","uk":"–•–∞—Ä—á—É–≤–∞–Ω–Ω—è –ø–µ—Ä–µ–≤–∞–∂–Ω–æ:","es":"Dieta:"}
    },
    "steps_target": {
        "ru":[("<5–∫","5000"),("5‚Äì8–∫","8000"),("8‚Äì12–∫","12000"),("–°–ø–æ—Ä—Ç","15000")],
        "en":[("<5k","5000"),("5‚Äì8k","8000"),("8‚Äì12k","12000"),("Sport","15000")],
        "uk":[("<5–∫","5000"),("5‚Äì8–∫","8000"),("8‚Äì12–∫","12000"),("–°–ø–æ—Ä—Ç","15000")],
        "es":[("<5k","5000"),("5‚Äì8k","8000"),("8‚Äì12k","12000"),("Deporte","15000")],
        "label":{"ru":"–®–∞–≥–∏/–∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å:","en":"Steps/activity:","uk":"–ö—Ä–æ–∫–∏/–∞–∫—Ç–∏–≤–Ω—ñ—Å—Ç—å:","es":"Pasos/actividad:"}
    },
    "habits": {
        "ru":[("–ù–µ –∫—É—Ä—é","no_smoke"),("–ö—É—Ä—é","smoke"),("–ê–ª–∫. —Ä–µ–¥–∫–æ","alc_low"),("–ê–ª–∫. —á–∞—Å—Ç–æ","alc_high"),("–ö–æ—Ñ–µ–∏–Ω 0‚Äì1","caf_low"),("–ö–æ—Ñ–µ–∏–Ω 2‚Äì3","caf_mid"),("–ö–æ—Ñ–µ–∏–Ω 4+","caf_high")],
        "en":[("No smoking","no_smoke"),("Smoking","smoke"),("Alcohol rare","alc_low"),("Alcohol often","alc_high"),("Caffeine 0‚Äì1","caf_low"),("Caffeine 2‚Äì3","caf_mid"),("Caffeine 4+","caf_high")],
        "uk":[("–ù–µ –∫—É—Ä—é","no_smoke"),("–ö—É—Ä—é","smoke"),("–ê–ª–∫. —Ä—ñ–¥–∫–æ","alc_low"),("–ê–ª–∫. —á–∞—Å—Ç–æ","alc_high"),("–ö–æ—Ñ–µ—ó–Ω 0‚Äì1","caf_low"),("–ö–æ—Ñ–µ—ó–Ω 2‚Äì3","caf_mid"),("–ö–æ—Ñ–µ—ó–Ω 4+","caf_high")],
        "es":[("No fuma","no_smoke"),("Fuma","smoke"),("Alcohol raro","alc_low"),("Alcohol a menudo","alc_high"),("Cafe√≠na 0‚Äì1","caf_low"),("Cafe√≠na 2‚Äì3","caf_mid"),("Cafe√≠na 4+","caf_high")],
        "label":{"ru":"–ü—Ä–∏–≤—ã—á–∫–∏ (–≤—ã–±–µ—Ä–∏—Ç–µ –±–ª–∏–∂–µ –≤—Å–µ–≥–æ):","en":"Habits (pick closest):","uk":"–ó–≤–∏—á–∫–∏ (–æ–±–µ—Ä—ñ—Ç—å –±–ª–∏–∂—á–µ):","es":"H√°bitos (elige):"}
    },
    "birth_date": {
        "ru":[], "en":[], "uk":[], "es":[],
        "label":{"ru":"–î–∞—Ç–∞ —Ä–æ–∂–¥–µ–Ω–∏—è (–ì–ì–ì–ì-–ú–ú-–î–î) ‚Äî –ø–æ –∂–µ–ª–∞–Ω–∏—é:","en":"Birth date (YYYY-MM-DD) ‚Äî optional:","uk":"–î–∞—Ç–∞ –Ω–∞—Ä–æ–¥–∂–µ–Ω–Ω—è (–†–†–†–†-–ú–ú-–î–î) ‚Äî –æ–ø—Ü—ñ–π–Ω–æ:","es":"Fecha de nacimiento (AAAA-MM-DD) ‚Äî opcional:"}
    },
}

def build_mini_kb(lang: str, key: str) -> InlineKeyboardMarkup:
    opts = MINI_STEPS[key].get(lang, [])
    rows, row = [], []
    for label, val in opts:
        row.append(InlineKeyboardButton(label, callback_data=f"mini|choose|{key}|{val}"))
        if len(row) == 3:
            rows.append(row); row=[]
    if row: rows.append(row)
    if key in MINI_FREE_KEYS or (not opts):
        rows.append([InlineKeyboardButton(T[lang]["write"], callback_data=f"mini|write|{key}")])
    rows.append([InlineKeyboardButton(T[lang]["skip"], callback_data=f"mini|skip|{key}")])
    return InlineKeyboardMarkup(rows)

async def start_mini_intake(context: ContextTypes.DEFAULT_TYPE, chat_id: int, lang: str, uid: int):
    sessions[uid] = sessions.get(uid, {})
    sessions[uid].update({"mini_active": True, "mini_step": 0, "mini_answers": {}, "qb_sent": False})
    await context.bot.send_message(chat_id, {
        "ru":"üîé –ú–∏–Ω–∏-–æ–ø—Ä–æ—Å –¥–ª—è –ø–µ—Ä—Å–æ–Ω–∞–ª–∏–∑–∞—Ü–∏–∏ (4‚Äì6 –∫–ª–∏–∫–æ–≤).",
        "uk":"üîé –ú—ñ–Ω—ñ-–æ–ø–∏—Ç—É–≤–∞–Ω–Ω—è –¥–ª—è –ø–µ—Ä—Å–æ–Ω–∞–ª—ñ–∑–∞—Ü—ñ—ó (4‚Äì6 –∫–ª—ñ–∫—ñ–≤).",
        "en":"üîé Mini-intake for personalization (4‚Äì6 taps).",
        "es":"üîé Mini-intake para personalizaci√≥n (4‚Äì6 toques).",
    }[lang], reply_markup=ReplyKeyboardRemove())
    await ask_next_mini(context, chat_id, lang, uid)

def mini_handle_choice(uid: int, key: str, value: str):
    s = sessions.setdefault(uid, {"mini_active": True, "mini_step": 0, "mini_answers": {}})
    s["mini_answers"][key] = value
    s["mini_step"] = int(s.get("mini_step", 0)) + 1

async def ask_next_mini(context: ContextTypes.DEFAULT_TYPE, chat_id: int, lang: str, uid: int):
    s = sessions.get(uid, {})
    step_idx = s.get("mini_step", 0)
    if step_idx >= len(MINI_KEYS):
        answers = s.get("mini_answers", {})
        if answers.get("meds_allergies"):
            profiles_upsert(uid, {"meds":answers["meds_allergies"], "allergies":answers["meds_allergies"]})
        if answers.get("birth_date"):
            profiles_upsert(uid, {"birth_date": answers["birth_date"]})
        profiles_upsert(uid, answers)
        sessions[uid]["mini_active"] = False
        profiles_upsert(uid, {"ai_profile": json.dumps({"v":1,"habits":answers.get("habits","")}, ensure_ascii=False)})
        await context.bot.send_message(chat_id, T[lang]["start_where"], reply_markup=inline_topic_kb(lang))
        await show_quickbar(context, chat_id, lang, uid)
        return
    key = MINI_KEYS[step_idx]
    label = MINI_STEPS[key]["label"][lang]
    await context.bot.send_message(chat_id, label, reply_markup=build_mini_kb(lang, key))


# ---------- TRIAGE (guided clarifiers; scaffold) ----------
# state kept in sessions[uid]['tri'] = {'area':..., 'duration':..., 'intensity':..., 'triggers':set(), 'red':bool}
TRI_STEPS = ["area","duration","intensity","triggers","red"]
TRI_OPTS = {
    "area": {
        "ru":[("–ì–æ–ª–æ–≤–∞","head"),("–®–µ—è","neck"),("–ì—Ä—É–¥—å","chest"),("–ñ–∏–≤–æ—Ç","abdomen"),("–°–ø–∏–Ω–∞","back"),("–ö–æ–Ω–µ—á–Ω.","limbs")],
        "en":[("Head","head"),("Neck","neck"),("Chest","chest"),("Abdomen","abdomen"),("Back","back"),("Limbs","limbs")],
        "uk":[("–ì–æ–ª–æ–≤–∞","head"),("–®–∏—è","neck"),("–ì—Ä—É–¥–∏","chest"),("–ñ–∏–≤—ñ—Ç","abdomen"),("–°–ø–∏–Ω–∞","back"),("–ö—ñ–Ω—Ü—ñ–≤–∫–∏","limbs")],
        "es":[("Cabeza","head"),("Cuello","neck"),("Pecho","chest"),("Abdomen","abdomen"),("Espalda","back"),("Extrem.","limbs")],
        "label":{"ru":"–ì–¥–µ –∏–º–µ–Ω–Ω–æ?","en":"Where exactly?","uk":"–î–µ —Å–∞–º–µ?","es":"¬øD√≥nde exactamente?"}
    },
    "duration": {
        "ru":[("<24 —á","<24h"),("1‚Äì3 –¥","1-3d"),(">3 –¥",">3d")],
        "en":[("<24 h","<24h"),("1‚Äì3 d","1-3d"),(">3 d",">3d")],
        "uk":[("<24 –≥–æ–¥","<24h"),("1‚Äì3 –¥","1-3d"),(">3 –¥",">3d")],
        "es":[("<24 h","<24h"),("1‚Äì3 d","1-3d"),(">3 d",">3d")],
        "label":{"ru":"–ö–∞–∫ –¥–∞–≤–Ω–æ?","en":"Since when?","uk":"–Ø–∫ –¥–∞–≤–Ω–æ?","es":"¬øDesde cu√°ndo?"}
    },
    "intensity": {
        "ru":[("1‚Äì3","1-3"),("4‚Äì6","4-6"),("7‚Äì10","7-10")],
        "en":[("1‚Äì3","1-3"),("4‚Äì6","4-6"),("7‚Äì10","7-10")],
        "uk":[("1‚Äì3","1-3"),("4‚Äì6","4-6"),("7‚Äì10","7-10")],
        "es":[("1‚Äì3","1-3"),("4‚Äì6","4-6"),("7‚Äì10","7-10")],
        "label":{"ru":"–ù–∞—Å–∫–æ–ª—å–∫–æ —Å–∏–ª—å–Ω–æ?","en":"How strong?","uk":"–ù–∞—Å–∫—ñ–ª—å–∫–∏ —Å–∏–ª—å–Ω–æ?","es":"¬øQu√© intensidad?"}
    },
    "triggers": {
        "ru":[("–î–≤–∏–∂–µ–Ω–∏–µ","move"),("–ï–¥–∞","food"),("–°—Ç—Ä–µ—Å—Å","stress"),("–≠–∫—Ä–∞–Ω","screen"),("–ö–æ—Ñ–µ–∏–Ω","caffeine"),("–¢—Ä–∞–≤–º–∞","trauma"),("–ù–µ –∑–Ω–∞—é","na")],
        "en":[("Movement","move"),("Food","food"),("Stress","stress"),("Screen","screen"),("Caffeine","caffeine"),("Trauma","trauma"),("Don‚Äôt know","na")],
        "uk":[("–†—É—Ö","move"),("–á–∂–∞","food"),("–°—Ç—Ä–µ—Å","stress"),("–ï–∫—Ä–∞–Ω","screen"),("–ö–æ—Ñ–µ—ó–Ω","caffeine"),("–¢—Ä–∞–≤–º–∞","trauma"),("–ù–µ –∑–Ω–∞—é","na")],
        "es":[("Movimiento","move"),("Comida","food"),("Estr√©s","stress"),("Pantalla","screen"),("Cafe√≠na","caffeine"),("Trauma","trauma"),("No s√©","na")],
        "label":{"ru":"–ß—Ç–æ –≤–ª–∏—è–µ—Ç? (–º–æ–∂–Ω–æ –Ω–µ—Å–∫–æ–ª—å–∫–æ)","en":"What affects it? (multi)","uk":"–©–æ –≤–ø–ª–∏–≤–∞—î? (–∫—ñ–ª—å–∫–∞)","es":"¬øQu√© influye? (multi)"}
    },
    "red": {
        "ru":[("–ï—Å—Ç—å —Ç—Ä–µ–≤–æ–∂–Ω—ã–µ –ø—Ä–∏–∑–Ω–∞–∫–∏","yes"),("–ù–µ—Ç","no")],
        "en":[("Red flags present","yes"),("No","no")],
        "uk":[("–Ñ —Ç—Ä–∏–≤–æ–∂–Ω—ñ –æ–∑–Ω–∞–∫–∏","yes"),("–ù—ñ","no")],
        "es":[("Hay se√±ales de alarma","yes"),("No","no")],
        "label":{"ru":"–ï—Å—Ç—å ¬´–∫—Ä–∞—Å–Ω—ã–µ —Ñ–ª–∞–≥–∏¬ª? (–ø–æ—Ç–µ—Ä—è —Å–æ–∑–Ω–∞–Ω–∏—è, –ø–∞—Ä–∞–ª–∏—á, –∫—Ä–æ–≤—å, —Å–∏–ª—å–Ω–∞—è —Ç—Ä–∞–≤–º–∞)","en":"Any red flags? (fainting, paralysis, bleeding, major injury)","uk":"–Ñ ¬´—á–µ—Ä–≤–æ–Ω—ñ –ø—Ä–∞–ø–æ—Ä—Ü—ñ¬ª?","es":"¬øSe√±ales de alarma?"}
    },
}

def tri_kb(lang: str, key: str, state: dict) -> InlineKeyboardMarkup:
    opts = TRI_OPTS[key].get(lang, [])
    rows = []
    if key == "triggers":
        # Toggle buttons in 2 rows
        row = []
        for label,val in opts:
            row.append(InlineKeyboardButton(("‚úÖ " if val in state.get("triggers", set()) else "") + label,
                        callback_data=f"tri|toggle|{key}|{val}"))
            if len(row)==3:
                rows.append(row); row=[]
        if row: rows.append(row)
        rows.append([InlineKeyboardButton("‚û°Ô∏è OK", callback_data="tri|next")])
    else:
        row = []
        for label,val in opts:
            row.append(InlineKeyboardButton(label, callback_data=f"tri|choose|{key}|{val}"))
            if len(row)==3:
                rows.append(row); row=[]
        if row: rows.append(row)
    return InlineKeyboardMarkup(rows)

def tri_start(uid: int):
    s = sessions.setdefault(uid, {})
    s["tri"] = {"step":0, "area":"", "duration":"", "intensity":"", "triggers":set(), "red":False}

def tri_next_step(uid: int) -> Optional[str]:
    tri = sessions.get(uid, {}).get("tri", {})
    step = tri.get("step", 0)
    return TRI_STEPS[step] if step < len(TRI_STEPS) else None

def tri_advance(uid: int):
    tri = sessions.get(uid, {}).get("tri", {})
    tri["step"] = int(tri.get("step", 0)) + 1

def tri_finalize_text(uid: int, lang: str) -> str:
    tri = sessions.get(uid, {}).get("tri", {})
    # simple plan based on answers
    red = tri.get("red", False)
    if red:
        return {"ru":"üöë –ü–æ—Ö–æ–∂–µ –Ω–∞ —Ç—Ä–µ–≤–æ–∂–Ω—ã–µ –ø—Ä–∏–∑–Ω–∞–∫–∏. –ï—Å–ª–∏ —É—Ö—É–¥—à–∞–µ—Ç—Å—è ‚Äî —Å—Ä–æ—á–Ω–æ –≤—ã–∑—ã–≤–∞–π—Ç–µ —Å–∫–æ—Ä—É—é.",
                "uk":"üöë –°—Ö–æ–∂–µ –Ω–∞ —Ç—Ä–∏–≤–æ–∂–Ω—ñ –æ–∑–Ω–∞–∫–∏. –Ø–∫—â–æ –ø–æ–≥—ñ—Ä—à—É—î—Ç—å—Å—è ‚Äî –≤–∏–∫–ª–∏–∫–∞–π—Ç–µ —à–≤–∏–¥–∫—É.",
                "en":"üöë Possible red flags. If worsening ‚Äî call emergency.",
                "es":"üöë Posibles se√±ales de alarma. Si empeora ‚Äî emergencias."}[lang]
    seg = ""
    try:
        age = int(re.search(r"\d+", str((profiles_get(uid) or {}).get("age","") or "0")).group(0))
    except Exception:
        age = 30
    seg = age_to_band(age)
    rule_txt = rules_lookup("triage_"+(tri.get("area") or "general"), seg, lang) or ""
    # baseline advice
    base = {
        "ru":"–ü–æ–ø—Ä–æ–±—É–µ–º 24‚Äì48 —á: –≤–æ–¥–∞ 300‚Äì500 –º–ª, –æ—Ç–¥—ã—Ö 15‚Äì20 –º–∏–Ω, –ø—Ä–æ–≤–µ—Ç—Ä–∏–≤–∞–Ω–∏–µ. –ù–∞–±–ª—é–¥–∞–π —Ç—Ä–∏–≥–≥–µ—Ä—ã.",
        "uk":"24‚Äì48 –≥–æ–¥: 300‚Äì500 –º–ª –≤–æ–¥–∏, –≤—ñ–¥–ø–æ—á–∏–Ω–æ–∫ 15‚Äì20 —Ö–≤, –ø—Ä–æ–≤—ñ—Ç—Ä—é–≤–∞–Ω–Ω—è. –°–ø–æ—Å—Ç–µ—Ä—ñ–≥–∞–π —Ç—Ä–∏–≥–µ—Ä–∏.",
        "en":"Next 24‚Äì48h: 300‚Äì500 ml water, 15‚Äì20 min rest, fresh air. Track triggers.",
        "es":"Pr√≥ximas 24‚Äì48h: 300‚Äì500 ml de agua, 15‚Äì20 min de descanso, aire fresco. Observa desencadenantes.",
    }[lang]
    parts = []
    if rule_txt: parts.append(rule_txt)
    parts.append(base)
    return "\n".join(parts)


# ===== end of Part 1 / 2 =====
# Part 2 will add:
# - auto language on each message; /start, /help, /privacy, /pause, /resume, /delete_data
# - callbacks (mini, consent, menu, gm, energy, eve, water, cycle, triage, ep|save)
# - on_text with learn_from_text, router/triage, quickbar de-dupe
# - handlers registration, build_app(), main()
# =========================
# TendAI ‚Äî Part 2/2: Dialog, Triage, Lang autodetect each msg, Unified scheduler, Streak, Fixes
# =========================

# ---------- Localization maps for profile values ----------
_LOC = {
    "sex": {
        "male":   {"ru": "–º—É–∂—Å–∫–æ–π",   "uk": "—á–æ–ª–æ–≤—ñ—á–∞", "en": "male",     "es": "hombre"},
        "female": {"ru": "–∂–µ–Ω—Å–∫–∏–π",   "uk": "–∂—ñ–Ω–æ—á–∞",   "en": "female",   "es": "mujer"},
        "other":  {"ru": "–¥—Ä—É–≥–æ–µ",    "uk": "—ñ–Ω—à–∞",     "en": "other",    "es": "otro"},
    },
    "goal": {
        "energy":     {"ru":"—ç–Ω–µ—Ä–≥–∏—è","uk":"–µ–Ω–µ—Ä–≥—ñ—è","en":"energy","es":"energ√≠a"},
        "sleep":      {"ru":"—Å–æ–Ω","uk":"—Å–æ–Ω","en":"sleep","es":"sue√±o"},
        "weight":     {"ru":"–≤–µ—Å","uk":"–≤–∞–≥–∞","en":"weight","es":"peso"},
        "strength":   {"ru":"—Å–∏–ª–∞","uk":"—Å–∏–ª–∞","en":"strength","es":"fuerza"},
        "longevity":  {"ru":"–¥–æ–ª–≥–æ–ª–µ—Ç–∏–µ","uk":"–¥–æ–≤–≥–æ–ª—ñ—Ç—Ç—è","en":"longevity","es":"longevidad"},
    },
    "activity": {
        "low":{"ru":"–Ω–∏–∑–∫–∞—è","uk":"–Ω–∏–∑—å–∫–∞","en":"low","es":"baja"},
        "mid":{"ru":"—Å—Ä–µ–¥–Ω—è—è","uk":"—Å–µ—Ä–µ–¥–Ω—è","en":"medium","es":"media"},
        "high":{"ru":"–≤—ã—Å–æ–∫–∞—è","uk":"–≤–∏—Å–æ–∫–∞","en":"high","es":"alta"},
        "sport":{"ru":"—Å–ø–æ—Ä—Ç","uk":"—Å–ø–æ—Ä—Ç","en":"sport","es":"deporte"},
    },
    "diet_focus": {
        "balanced":{"ru":"—Å–±–∞–ª–∞–Ω—Å.","uk":"–∑–±–∞–ª–∞–Ω—Å.","en":"balanced","es":"equilibrada"},
        "lowcarb":{"ru":"–Ω–∏–∑–∫–æ—É–≥–ª.","uk":"–º–∞–ª–æ–≤—É–≥–ª.","en":"low-carb","es":"baja en carbos"},
        "plant":{"ru":"—Ä–∞—Å—Ç–∏—Ç.","uk":"—Ä–æ—Å–ª–∏–Ω–Ω–µ","en":"plant-based","es":"vegetal"},
        "irregular":{"ru":"–Ω–µ—Ä–µ–≥—É–ª.","uk":"–Ω–µ—Ä–µ–≥—É–ª.","en":"irregular","es":"irregular"},
    },
}

def _loc_value(field: str, value: str, lang: str) -> str:
    v = (value or "").strip().lower()
    if field in _LOC and v in _LOC[field]:
        return _LOC[field][v].get(lang, v)
    return value or "‚Äî"

# Override: personalized_prefix with localization
def personalized_prefix(lang: str, profile: dict) -> str:
    sex = _loc_value("sex", profile.get("sex") or "", lang)
    goal = _loc_value("goal", profile.get("goal") or "", lang)
    age_raw = str(profile.get("age") or "")
    m = re.search(r"\d+", age_raw)
    age = m.group(0) if m else ""
    if sum(bool(x) for x in (sex, age, goal)) >= 2:
        tpl = (T.get(lang) or T["en"]).get("px", T["en"]["px"])
        return tpl.format(sex=sex or "‚Äî", age=age or "‚Äî", goal=goal or "‚Äî")
    return ""

# ---------- Language: autodetect on every message + remember for callbacks ----------
def _update_msg_lang(uid: int, text: str) -> str:
    # soft update of users.lang + keep in session for callbacks
    guessed = detect_lang_from_text(text, _user_lang(uid))
    s = sessions.setdefault(uid, {})
    s["last_msg_lang"] = guessed
    if guessed != _user_lang(uid):
        users_set(uid, "lang", guessed)
    return guessed

def _lang_for_cb(uid: int) -> str:
    return sessions.get(uid, {}).get("last_msg_lang") or _user_lang(uid)

# ---------- Unified scheduler (overrides any earlier duplicates) ----------
def _remove_jobs(app, prefix: str):
    if not getattr(app, "job_queue", None):
        return
    for j in list(app.job_queue.jobs()):
        if j.name and j.name.startswith(prefix):
            j.schedule_removal()

def _run_daily(app, name: str, hour_local: int, minute_local: int, tz_off: int, data: dict, callback):
    if not getattr(app, "job_queue", None):
        return
    _remove_jobs(app, name)
    utc_h = (hour_local - tz_off) % 24
    t = dtime(hour=utc_h, minute=minute_local, tzinfo=timezone.utc)
    app.job_queue.run_daily(callback, time=t, data=data, name=name)

def schedule_daily_checkin(app, uid: int, tz_off: int, hhmm: str, lang: str):
    h, m = hhmm_tuple(hhmm); _run_daily(app, f"gm_{uid}", h, m, tz_off, {"user_id": uid, "kind": "gm"}, job_gm)

def schedule_evening_checkin(app, uid: int, tz_off: int, hhmm: str, lang: str):
    h, m = hhmm_tuple(hhmm); _run_daily(app, f"eve_{uid}", h, m, tz_off, {"user_id": uid, "kind": "eve"}, job_evening)

def schedule_midday_care(app, uid: int, tz_off: int, hhmm: str=DEFAULT_MIDDAY_LOCAL, lang: str="en"):
    h, m = hhmm_tuple(hhmm); _run_daily(app, f"care_{uid}", h, m, tz_off, {"user_id": uid, "kind": "care"}, job_daily_care)

def schedule_weekly_report(app, uid: int, tz_off: int, hhmm: str=DEFAULT_WEEKLY_LOCAL, weekday: int=6, lang: str="en"):
    # run once a week
    if not getattr(app, "job_queue", None): return
    _remove_jobs(app, f"weekly_{uid}")
    h, m = hhmm_tuple(hhmm)
    utc_h = (h - tz_off) % 24
    app.job_queue.run_daily(job_weekly_report, time=dtime(hour=utc_h, minute=m, tzinfo=timezone.utc),
                            days=(weekday,), name=f"weekly_{uid}", data={"user_id": uid, "kind": "weekly"})

async def job_gm(context: ContextTypes.DEFAULT_TYPE):
    d = context.job.data or {}; uid = d.get("user_id")
    lang = _user_lang(uid)
    if not _auto_allowed(uid): return
    local_now = user_local_now(uid)
    if adjust_out_of_quiet(local_now, _user_quiet_hours(uid)) != local_now: return
    kb = InlineKeyboardMarkup([
        [InlineKeyboardButton(T[lang]["gm_excellent"], callback_data="gm|mood|excellent"),
         InlineKeyboardButton(T[lang]["gm_ok"],        callback_data="gm|mood|ok")],
        [InlineKeyboardButton(T[lang]["gm_tired"],     callback_data="gm|mood|tired"),
         InlineKeyboardButton(T[lang]["gm_pain"],      callback_data="gm|mood|pain")],
        [InlineKeyboardButton(T[lang]["gm_skip"],      callback_data="gm|skip")],
        [InlineKeyboardButton(T[lang]["mood_note"],    callback_data="gm|note")]
    ])
    try:
        await context.bot.send_message(uid, T[lang]["daily_gm"], reply_markup=kb)
        _auto_inc(uid)
    except Exception as e:
        logging.warning(f"job_gm send failed: {e}")

async def job_evening(context: ContextTypes.DEFAULT_TYPE):
    d = context.job.data or {}; uid = d.get("user_id")
    lang = _user_lang(uid)
    if not _auto_allowed(uid): return
    local_now = user_local_now(uid)
    if adjust_out_of_quiet(local_now, _user_quiet_hours(uid)) != local_now: return
    kb = InlineKeyboardMarkup([
        [InlineKeyboardButton(T[lang]["evening_tip_btn"], callback_data="eve|tip")],
        [InlineKeyboardButton(T[lang]["hydrate_btn"],     callback_data="water|nudge")]
    ])
    try:
        await context.bot.send_message(uid, T[lang]["evening_intro"], reply_markup=kb)
        _auto_inc(uid)
    except Exception as e:
        logging.warning(f"job_evening send failed: {e}")

async def job_daily_care(context: ContextTypes.DEFAULT_TYPE):
    d = context.job.data or {}; uid = d.get("user_id")
    lang = _user_lang(uid)
    if not _auto_allowed(uid): return
    local_now = user_local_now(uid)
    if adjust_out_of_quiet(local_now, _user_quiet_hours(uid)) != local_now: return
    tip = build_care_nudge(uid, lang)
    try:
        await context.bot.send_message(uid, tip)
        _auto_inc(uid)
    except Exception as e:
        logging.warning(f"job_daily_care send failed: {e}")

async def job_weekly_report(context: ContextTypes.DEFAULT_TYPE):
    d = context.job.data or {}; uid = d.get("user_id")
    lang = _user_lang(uid)
    last7 = [r for r in MEM_DAILY if r.get("user_id")==str(uid)][-7:]
    good = sum(1 for r in last7 if r.get("mood") in {"excellent","ok"})
    txt = {
        "ru": f"–ò—Ç–æ–≥–∏ –Ω–µ–¥–µ–ª–∏: {len(last7)} —á–µ–∫-–∏–Ω–æ–≤, {good} ‚Äî –æ–∫/–æ—Ç–ª–∏—á–Ω–æ. –î–µ—Ä–∂–∏–º —Ä–∏—Ç–º üòä",
        "uk": f"–ü—ñ–¥—Å—É–º–∫–∏ —Ç–∏–∂–Ω—è: {len(last7)} —á–µ–∫-—ñ–Ω—ñ–≤, {good} ‚Äî –æ–∫/—á—É–¥–æ–≤–æ. –¢—Ä–∏–º–∞—î–º–æ —Ä–∏—Ç–º üòä",
        "en": f"Weekly wrap: {len(last7)} check-ins, {good} felt ok/great. Gentle & steady üòä",
        "es": f"Semana: {len(last7)} check-ins, {good} ok/genial. Suave y constante üòä",
    }[lang]
    await context.bot.send_message(uid, txt)

async def job_oneoff_reminder(context: ContextTypes.DEFAULT_TYPE):
    d = context.job.data or {}; uid = d.get("user_id"); rid = d.get("reminder_id")
    lang = _user_lang(uid)
    text = None
    if SHEETS_ENABLED and ws_reminders:
        try:
            for r in ws_reminders.get_all_records():
                if r.get("id")==rid: text = r.get("text"); break
        except Exception: pass
    if not text:
        for r in MEM_REMINDERS:
            if r.get("id")==rid: text = r.get("text"); break
    try:
        await context.bot.send_message(uid, f"‚è∞ {text or T[lang]['thanks']}")
    except Exception: pass

# ---------- Simple streak helpers ----------
def _streak_touch(uid: int):
    u = users_get(uid) or {}
    today = datetime.utcnow().date().isoformat()
    last = (u.get("gm_last_date") or "")
    try:
        streak = int(u.get("streak") or "0")
        best = int(u.get("streak_best") or "0")
    except:
        streak, best = 0, 0
    if last == today:
        return streak, best  # already counted today
    # if yesterday -> +1 else -> 1
    yest = (datetime.utcnow().date() - timedelta(days=1)).isoformat()
    if last == yest:
        streak += 1
    else:
        streak = 1
    best = max(best, streak)
    users_set(uid, "streak", str(streak))
    users_set(uid, "streak_best", str(best))
    users_set(uid, "gm_last_date", today)
    return streak, best

# ---------- Lightweight triage (no LLM) ----------
_TRI_LOC = {
    "ru":[("–ì–æ–ª–æ–≤–∞","head"),("–®–µ—è","neck"),("–ì—Ä—É–¥—å","chest"),("–ñ–∏–≤–æ—Ç","abdomen"),("–°–ø–∏–Ω–∞","back"),("–ö–æ–Ω–µ—á–Ω–æ—Å—Ç–∏","limb")],
    "uk":[("–ì–æ–ª–æ–≤–∞","head"),("–®–∏—è","neck"),("–ì—Ä—É–¥–∏","chest"),("–ñ–∏–≤—ñ—Ç","abdomen"),("–°–ø–∏–Ω–∞","back"),("–ö—ñ–Ω—Ü—ñ–≤–∫–∏","limb")],
    "en":[("Head","head"),("Neck","neck"),("Chest","chest"),("Abdomen","abdomen"),("Back","back"),("Limbs","limb")],
    "es":[("Cabeza","head"),("Cuello","neck"),("Pecho","chest"),("Abdomen","abdomen"),("Espalda","back"),("Extrem.","limb")],
}
_TRI_DUR = {
    "ru":[("<24 —á","<24h"),("1‚Äì3 –¥","1-3d"),(">3 –¥",">3d")],
    "uk":[("<24 –≥–æ–¥","<24h"),("1‚Äì3 –¥","1-3d"),(">3 –¥",">3d")],
    "en":[("<24h","<24h"),("1‚Äì3d","1-3d"),(">3d",">3d")],
    "es":[("<24h","<24h"),("1‚Äì3d","1-3d"),(">3d",">3d")],
}
_TRI_TRG = {
    "ru":[("–î–≤–∏–∂–µ–Ω–∏–µ","move"),("–ï–¥–∞","food"),("–°—Ç—Ä–µ—Å—Å","stress"),("–≠–∫—Ä–∞–Ω","screen"),("–ö–æ—Ñ–µ–∏–Ω","caffeine"),("–¢—Ä–∞–≤–º–∞","trauma"),("–ù–µ –∑–Ω–∞—é","na")],
    "uk":[("–†—É—Ö","move"),("–á–∂–∞","food"),("–°—Ç—Ä–µ—Å","stress"),("–ï–∫—Ä–∞–Ω","screen"),("–ö–æ—Ñ–µ—ó–Ω","caffeine"),("–¢—Ä–∞–≤–º–∞","trauma"),("–ù–µ –∑–Ω–∞—é","na")],
    "en":[("Movement","move"),("Food","food"),("Stress","stress"),("Screen","screen"),("Caffeine","caffeine"),("Trauma","trauma"),("Not sure","na")],
    "es":[("Movimiento","move"),("Comida","food"),("Estr√©s","stress"),("Pantalla","screen"),("Cafe√≠na","caffeine"),("Trauma","trauma"),("No s√©","na")],
}

def _kb(items, prefix):
    row, rows = [], []
    for label, val in items:
        row.append(InlineKeyboardButton(label, callback_data=f"{prefix}|{val}"))
        if len(row) == 3: rows.append(row); row=[]
    if row: rows.append(row)
    return InlineKeyboardMarkup(rows)

def _tri_state(uid:int):
    return sessions.setdefault(uid, {}).setdefault("tri", {"step":0, "data":{}})

async def _tri_start(chat_id:int, uid:int, lang:str, bot):
    st = _tri_state(uid); st["step"]=0; st["data"]={}
    await bot.send_message(chat_id, {
        "ru":"–û–∫, —É—Ç–æ—á–Ω—é –∫–æ—Ä–æ—Ç–∫–æ –ø–æ —à–∞–≥–∞–º. –ì–¥–µ –∏–º–µ–Ω–Ω–æ –¥–∏—Å–∫–æ–º—Ñ–æ—Ä—Ç?",
        "uk":"–î–æ–±—Ä–µ, —É—Ç–æ—á–Ω—é –∫–æ—Ä–æ—Ç–∫–æ –ø–æ –∫—Ä–æ–∫–∞—Ö. –î–µ —Å–∞–º–µ –¥–∏—Å–∫–æ–º—Ñ–æ—Ä—Ç?",
        "en":"Okay, a few quick clarifiers. Where exactly is it?",
        "es":"Vale, unas aclaraciones r√°pidas. ¬øD√≥nde exactamente?",
    }[lang], reply_markup=_kb(_TRI_LOC[lang], "tri|loc"))

async def _tri_next(chat_id:int, uid:int, lang:str, bot):
    st = _tri_state(uid)
    step = st["step"]
    if step == 1:
        await bot.send_message(chat_id, {
            "ru":"–°–∫–æ–ª—å–∫–æ –¥–ª–∏—Ç—Å—è?",
            "uk":"–°–∫—ñ–ª—å–∫–∏ —Ç—Ä–∏–≤–∞—î?",
            "en":"How long?",
            "es":"¬øDesde cu√°ndo?",
        }[lang], reply_markup=_kb(_TRI_DUR[lang], "tri|dur"))
    elif step == 2:
        # intensity 1..10
        row = [InlineKeyboardButton(str(i), callback_data=f"tri|int|{i}") for i in range(1,11)]
        await bot.send_message(chat_id, {
            "ru":"–ù–∞—Å–∫–æ–ª—å–∫–æ —Å–∏–ª—å–Ω–æ (1‚Äì10)?","uk":"–ù–∞—Å–∫—ñ–ª—å–∫–∏ —Å–∏–ª—å–Ω–æ (1‚Äì10)?","en":"How intense (1‚Äì10)?","es":"¬øQu√© tan intenso (1‚Äì10)?"
        }[lang], reply_markup=InlineKeyboardMarkup([row[:5], row[5:]]))
    elif step == 3:
        await bot.send_message(chat_id, {
            "ru":"–ï—Å—Ç—å —è–≤–Ω—ã–π —Ç—Ä–∏–≥–≥–µ—Ä?","uk":"–Ñ —è–≤–Ω–∏–π —Ç—Ä–∏–≥–µ—Ä?","en":"Any obvious trigger?","es":"¬øAlg√∫n detonante claro?",
        }[lang], reply_markup=_kb(_TRI_TRG[lang], "tri|trg"))
    elif step == 4:
        await bot.send_message(chat_id, {
            "ru":"–ï—Å—Ç—å –∫—Ä–∞—Å–Ω—ã–µ —Ñ–ª–∞–≥–∏ (–ø–∞—Ä–∞–ª–∏—á, —Å–ª–∞–±–æ—Å—Ç—å –æ–¥–Ω–æ–π —Å—Ç–æ—Ä–æ–Ω—ã, —Å–∏–ª—å–Ω–∞—è —Ç—Ä–∞–≤–º–∞, –∫—Ä–æ–≤—å/—Ä–≤–æ—Ç–∞ —Å –∫—Ä–æ–≤—å—é, –ø–æ—Ç–µ—Ä—è —Å–æ–∑–Ω–∞–Ω–∏—è)?",
            "uk":"–Ñ —á–µ—Ä–≤–æ–Ω—ñ –ø—Ä–∞–ø–æ—Ä—Ü—ñ (–ø–∞—Ä–∞–ª—ñ—á, —Å–ª–∞–±–∫—ñ—Å—Ç—å –æ–¥–Ω—ñ—î—ó —Å—Ç–æ—Ä–æ–Ω–∏, —Å–∏–ª—å–Ω–∞ —Ç—Ä–∞–≤–º–∞, –∫—Ä–æ–≤/–±–ª—é–≤–∞–Ω–Ω—è –∫—Ä–æ–≤‚Äô—é, –≤—Ç—Ä–∞—Ç–∞ —Å–≤—ñ–¥–æ–º–æ—Å—Ç—ñ)?",
            "en":"Any red flags (paralysis, one-sided weakness, major trauma, blood/coffee-ground vomit, fainting)?",
            "es":"¬øAlguna bandera roja (par√°lisis, debilidad unilateral, trauma mayor, sangre/v√≥mito, desmayo)?",
        }[lang], reply_markup=InlineKeyboardMarkup([
            [InlineKeyboardButton(T[lang]["yes"], callback_data="tri|rf|yes"),
             InlineKeyboardButton(T[lang]["no"],  callback_data="tri|rf|no")]
        ]))

def _tri_plan(lang:str, data:dict) -> str:
    loc = data.get("loc","")
    dur = data.get("dur","")
    intensity = int(data.get("int","5"))
    trg = data.get("trg","na")
    red = data.get("rf","no") == "yes"

    # Quick ER
    if red or (loc=="chest" and intensity>=7) or (loc=="head" and intensity>=8 and dur in {"<24h","1-3d"}):
        er = {
            "ru":"üöë –¢—Ä–µ–≤–æ–∂–Ω—ã–µ –ø—Ä–∏–∑–Ω–∞–∫–∏. –ï—Å–ª–∏ —É—Å–∏–ª–∏–≤–∞–µ—Ç—Å—è ‚Äî –Ω–µ–º–µ–¥–ª–µ–Ω–Ω–æ –≤—ã–∑—ã–≤–∞–π—Ç–µ —Å–∫–æ—Ä—É—é.",
            "uk":"üöë –¢—Ä–∏–≤–æ–∂–Ω—ñ –æ–∑–Ω–∞–∫–∏. –Ø–∫—â–æ –ø–æ—Å–∏–ª—é—î—Ç—å—Å—è ‚Äî –Ω–µ–≥–∞–π–Ω–æ —à–≤–∏–¥–∫—É.",
            "en":"üöë Concerning signs. If worsening ‚Äî call emergency now.",
            "es":"üöë Signos preocupantes. Si empeora ‚Äî llama a emergencias.",
        }[lang]
        return er

    causes = []
    if loc in {"head"}:
        causes += {
            "ru":["–ù–∞–ø—Ä—è–∂–µ–Ω–∏–µ, –æ–±–µ–∑–≤–æ–∂–∏–≤–∞–Ω–∏–µ, —ç–∫—Ä–∞–Ω, –∫–æ—Ñ–µ–∏–Ω"],
            "uk":["–ù–∞–ø—Ä—É–∂–µ–Ω–Ω—è, –∑–Ω–µ–≤–æ–¥–Ω–µ–Ω–Ω—è, –µ–∫—Ä–∞–Ω, –∫–æ—Ñ–µ—ó–Ω"],
            "en":["Tension, dehydration, screen time, caffeine"],
            "es":["Tensi√≥n, deshidrataci√≥n, pantallas, cafe√≠na"],
        }[lang]
    if loc in {"abdomen"}:
        causes += {
            "ru":["–ü–∏—â–∞/–≥–∞–∑, —Å–ø–∞–∑–º, —Å—Ç—Ä–µ—Å—Å"],
            "uk":["–á–∂–∞/–≥–∞–∑, —Å–ø–∞–∑–º, —Å—Ç—Ä–µ—Å"],
            "en":["Food/gas, spasm, stress"],
            "es":["Comida/gases, espasmo, estr√©s"],
        }[lang]
    if not causes:
        causes = {"ru":["–§—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–µ –ø—Ä–∏—á–∏–Ω—ã"],"uk":["–§—É–Ω–∫—Ü—ñ–æ–Ω–∞–ª—å–Ω—ñ –ø—Ä–∏—á–∏–Ω–∏"],"en":["Functional causes"],"es":["Causas funcionales"]}[lang]

    do_now = []
    do_now += {"ru":["–í–æ–¥–∞ 300‚Äì500 –º–ª","15‚Äì20 –º–∏–Ω —Å–ø–æ–∫–æ–π—Å—Ç–≤–∏—è"],
               "uk":["–í–æ–¥–∞ 300‚Äì500 –º–ª","15‚Äì20 —Ö–≤ —Å–ø–æ–∫–æ—é"],
               "en":["Drink 300‚Äì500 ml water","15‚Äì20 min rest"],
               "es":["Bebe 300‚Äì500 ml de agua","Descanso 15‚Äì20 min"]}[lang]
    if trg in {"screen"}:
        do_now += {"ru":["–ü–∞—É–∑–∞ –¥–ª—è –≥–ª–∞–∑ 5‚Äì10 –º–∏–Ω"],"uk":["–ü–∞—É–∑–∞ –¥–ª—è –æ—á–µ–π 5‚Äì10 —Ö–≤"],"en":["Screen break 5‚Äì10 min"],"es":["Descanso de pantallas 5‚Äì10 min"]}[lang]
    if trg in {"caffeine"}:
        do_now += {"ru":["–ü–æ–∫–∞ –±–µ–∑ –∫–æ—Ñ–µ–∏–Ω–∞"],"uk":["–ü–æ–∫–∏ –±–µ–∑ –∫–æ—Ñ–µ—ó–Ω—É"],"en":["Skip caffeine today"],"es":["Evita cafe√≠na hoy"]}[lang]
    if loc=="neck":
        do_now += {"ru":["–ú—è–≥–∫–∞—è —Ä–∞–∑–º–∏–Ω–∫–∞ —à–µ–∏ 3‚Äì5 –º–∏–Ω"],"uk":["–ú‚Äô—è–∫–∞ —Ä–æ–∑–º–∏–Ω–∫–∞ —à–∏—ó 3‚Äì5 —Ö–≤"],"en":["Gentle neck mobility 3‚Äì5 min"],"es":["Movilidad cervical 3‚Äì5 min"]}[lang]

    see = []
    if dur==">3d" or intensity>=7:
        see += {"ru":["–ï—Å–ª–∏ —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç—Å—è >3 –¥–Ω–µ–π –∏–ª–∏ ‚â•7/10 ‚Äî –æ–±—Ä–∞—Ç–∏—Ç—å—Å—è –∫ –≤—Ä–∞—á—É"],
                "uk":["–Ø–∫—â–æ >3 –¥–Ω—ñ–≤ –∞–±–æ ‚â•7/10 ‚Äî –¥–æ –ª—ñ–∫–∞—Ä—è"],
                "en":["If >3 days or ‚â•7/10 ‚Äî see a clinician"],
                "es":["Si >3 d√≠as o ‚â•7/10 ‚Äî consulta m√©dico"]}[lang]

    # rules (evidence) by segment
    seg = "36‚Äì45"  # fallback
    try:
        prof = profiles_get(int(data.get("uid") or 0)) or {}
        seg = age_to_band(int(re.search(r"\d+", str(prof.get("age","") or "0")).group(0))) if re.search(r"\d+", str(prof.get("age","") or "0")) else seg
    except: pass
    rule = rules_lookup(topic=f"tri_{loc}", segment=seg, lang=lang)

    out = []
    out.append(f"{T[lang]['h60_t1']}:\n" + "\n".join(f"‚Ä¢ {c}" for c in causes))
    if rule:
        out.append(f"{T[lang]['daily_tip_prefix']} {rule}")
    out.append(f"\n{T[lang]['h60_t2']}:\n" + "\n".join(f"‚Ä¢ {x}" for x in do_now))
    if see:
        out.append(f"\n{T[lang]['h60_t3']}:\n" + "\n".join(f"‚Ä¢ {x}" for x in see))
    return "\n".join(out).strip()

# ---------- Extend callback handler (language, triage, episode save, neck routine) ----------
# Wrap original cb_handler if exists; else we define new.
_original_cb = cb_handler if 'cb_handler' in globals() else None

async def cb_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    q = update.callback_query
    if not q: return
    await q.answer()
    uid = q.from_user.id
    lang = _lang_for_cb(uid)
    data = (q.data or "")
    parts = data.split("|")
    kind = parts[0]

    # TRIAGE flow
    if kind == "tri":
        st = _tri_state(uid)
        sub = parts[1]
        if sub == "start":
            await _tri_start(q.message.chat_id, uid, lang, context.bot); return
        if sub == "loc":
            st["data"]["loc"] = parts[2]; st["step"]=1
            await _tri_next(q.message.chat_id, uid, lang, context.bot); return
        if sub == "dur":
            st["data"]["dur"] = parts[2]; st["step"]=2
            await _tri_next(q.message.chat_id, uid, lang, context.bot); return
        if sub == "int":
            st["data"]["int"] = parts[2]; st["step"]=3
            await _tri_next(q.message.chat_id, uid, lang, context.bot); return
        if sub == "trg":
            st["data"]["trg"] = parts[2]; st["step"]=4
            await _tri_next(q.message.chat_id, uid, lang, context.bot); return
        if sub == "rf":
            st["data"]["rf"] = parts[2]; st["data"]["uid"]=str(uid)
            plan = _tri_plan(lang, st["data"])
            await q.message.reply_text(plan)
            sessions[uid]["tri"] = {"step":0,"data":{}}  # reset
            await show_quickbar(context, q.message.chat_id, lang)
            return

    # Episode save
    if kind == "ep" and parts[1] == "save":
        eid = parts[2]
        try:
            episode_set(eid, "status", "closed")
        except Exception: pass
        await q.message.reply_text({"ru":"–≠–ø–∏–∑–æ–¥ —Å–æ—Ö—Ä–∞–Ω—ë–Ω ‚úÖ","uk":"–ï–ø—ñ–∑–æ–¥ –∑–±–µ—Ä–µ–∂–µ–Ω–æ ‚úÖ","en":"Episode saved ‚úÖ","es":"Episodio guardado ‚úÖ"}[lang])
        return

    # 5-min neck routine
    if kind == "yt" and parts[1] == "neck":
        txt = {
            "ru":"üßò 3‚Äì5 –º–∏–Ω—É—Ç: –º—è–≥–∫–∏–µ –∫—Ä—É–≥–∏ –ø–ª–µ—á–∞–º–∏, –Ω–∞–∫–ª–æ–Ω—ã –≥–æ–ª–æ–≤—ã, ¬´–ø–æ–¥–±–æ—Ä –¥–≤–æ–π–Ω–æ–≥–æ –ø–æ–¥–±–æ—Ä–æ–¥–∫–∞¬ª, –ª—ë–≥–∫–∞—è —Ä–∞—Å—Ç—è–∂–∫–∞ —Ç—Ä–∞–ø–µ—Ü–∏–π. –ë–µ–∑ –±–æ–ª–∏.",
            "uk":"üßò 3‚Äì5 —Ö–≤: –º‚Äô—è–∫—ñ –∫–æ–ª–∞ –ø–ª–µ—á–∏–º–∞, –Ω–∞—Ö–∏–ª–∏ –≥–æ–ª–æ–≤–∏, ¬´–ø—ñ–¥–±–æ—Ä –ø—ñ–¥–±–æ—Ä—ñ–¥–¥—è¬ª, –ª–µ–≥–∫–∞ —Ä–æ–∑—Ç—è–∂–∫–∞ —Ç—Ä–∞–ø–µ—Ü—ñ–π. –ë–µ–∑ –±–æ–ª—é.",
            "en":"üßò 3‚Äì5 min: shoulder rolls, gentle neck tilts, chin tucks, light upper-trap stretch. Pain-free.",
            "es":"üßò 3‚Äì5 min: c√≠rculos de hombros, inclinaciones de cuello, retracci√≥n de ment√≥n, estiramiento trapecio. Sin dolor.",
        }[lang]
        await q.message.reply_text(txt)
        return

    # GM streak on mood
    if kind == "gm" and parts[1] == "mood":
        streak, best = _streak_touch(uid)
        if streak in (3,7,14,30):
            msg = {
                "ru":f"üî• –°–µ—Ä–∏—è {streak} –¥–Ω–µ–π –ø–æ–¥—Ä—è–¥! –õ—É—á—à–µ–µ ‚Äî {best}.",
                "uk":f"üî• –°–µ—Ä—ñ—è {streak} –¥–Ω—ñ–≤ –ø–æ—Å–ø—ñ–ª—å! –ù–∞–π–∫—Ä–∞—â–µ ‚Äî {best}.",
                "en":f"üî• Streak {streak} days! Best ‚Äî {best}.",
                "es":f"üî• Racha de {streak} d√≠as! Mejor ‚Äî {best}.",
            }[lang]
            await q.message.reply_text(msg)

    # Fallback to original handler logic (menus, reminders, cycle, evening tips, etc.)
    if _original_cb:
        return await _original_cb(update, context)

# ---------- Extend text handler (autodetect, learn_from_text, triage entry) ----------
_original_on_text = on_text if 'on_text' in globals() else None

async def on_text(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not update.message: 
        if _original_on_text: 
            return await _original_on_text(update, context)
        return
    uid = update.effective_user.id
    raw = (update.message.text or "").strip()

    # Per-message language (soft)
    lang = _update_msg_lang(uid, raw)

    # Learn habits from free text
    try: learn_from_text(uid, raw)
    except Exception: pass

    # If profile incomplete ‚Äî do not block the dialog, just offer triage + intake button
    prof = profiles_get(uid) or {}
    s = sessions.setdefault(uid, {})

    # Quick symptom heuristics ‚Üí launch lightweight triage
    low = raw.lower()
    symptomish = any(k in low for k in [
        "–±–æ–ª–∏—Ç","–±–æ–ª—å","—Ç–æ—à–Ω–æ","—Ä–≤–µ—Ç","—Ä–≤–æ—Ç–∞","–∫–∞—à–µ–ª—å","—Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä","–º–∏–≥—Ä–µ–Ω—å","–≥–æ–ª–æ–≤–∞","–≥–æ–ª–æ–≤–Ω–∞—è",
        "pain","ache","nausea","vomit","cough","fever","headache","migraine","dolor","fiebre","n√°usea"
    ])
    if symptomish and not s.get("awaiting_h60_text") and not s.get("tri",{}).get("step"):
        await _tri_start(update.effective_chat.id, uid, lang, context.bot)
        # Also offer intake gently if profile weak
        if profile_is_incomplete(prof):
            kb = InlineKeyboardMarkup([[InlineKeyboardButton(
                {"ru":"üß© –ó–∞–ø–æ–ª–Ω–∏—Ç—å –ø—Ä–æ—Ñ–∏–ª—å (40—Å)","uk":"üß© –ó–∞–ø–æ–≤–Ω–∏—Ç–∏ –ø—Ä–æ—Ñ—ñ–ª—å (40—Å)","en":"üß© Fill profile (40s)","es":"üß© Completar perfil (40s)"}[lang],
                callback_data="intake:start")]])
            await update.message.reply_text({"ru":"–ß—Ç–æ–±—ã —Å–æ–≤–µ—Ç—ã –±—ã–ª–∏ —Ç–æ—á–Ω–µ–µ ‚Äî –º–æ–∂–Ω–æ –ø—Ä–æ–π—Ç–∏ –º–∏–Ω–∏-–æ–ø—Ä–æ—Å.",
                                             "uk":"–©–æ–± –ø–æ—Ä–∞–¥–∏ –±—É–ª–∏ —Ç–æ—á–Ω—ñ—à—ñ ‚Äî –º–æ–∂–Ω–∞ –ø—Ä–æ–π—Ç–∏ –º—ñ–Ω—ñ-–æ–ø–∏—Ç–Ω–∏–∫.",
                                             "en":"For sharper tips, you can take a quick mini-intake.",
                                             "es":"Para consejos m√°s precisos ‚Äî haz el mini-intake."}[lang],
                                             reply_markup=kb)
        return

    # Fall back to original handler (which includes Health60/LLM/router etc.)
    if _original_on_text:
        return await _original_on_text(update, context)

# ---------- Small menu entry to start triage manually ----------
def triage_quick_kb(lang: str) -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup([[InlineKeyboardButton("‚ö° 60s triage" if lang=="en" else
                                                       ("‚ö° 60 —Å–µ–∫" if lang=="ru" else
                                                       ("‚ö° 60 —Å" if lang=="uk" else "‚ö° 60s")),
                                  callback_data="tri|start")]])

# Optionally show next to quickbar from any command/flow (use when needed)
